diff --git a/GenOpCodes/App.config b/GenOpCodes/App.config
index 787dcbe..ecdcf8a 100644
--- a/GenOpCodes/App.config
+++ b/GenOpCodes/App.config
@@ -1,6 +1,6 @@
-ï»¿<?xml version="1.0" encoding="utf-8" ?>
+<?xml version="1.0" encoding="utf-8"?>
 <configuration>
     <startup> 
-        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.1" />
+        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/>
     </startup>
-</configuration>
\ No newline at end of file
+</configuration>
diff --git a/GenOpCodes/GenOpCodes.vbproj b/GenOpCodes/GenOpCodes.vbproj
index cc03ac1..af19449 100644
--- a/GenOpCodes/GenOpCodes.vbproj
+++ b/GenOpCodes/GenOpCodes.vbproj
@@ -11,9 +11,10 @@
     <AssemblyName>GenOpCodes</AssemblyName>
     <FileAlignment>512</FileAlignment>
     <MyType>Console</MyType>
-    <TargetFrameworkVersion>v4.7.1</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
     <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
     <Deterministic>true</Deterministic>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <PlatformTarget>AnyCPU</PlatformTarget>
@@ -47,6 +48,52 @@
   <PropertyGroup>
     <OptionInfer>On</OptionInfer>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DocumentationFile>GenOpCodes.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>true</Prefer32Bit>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DocumentationFile>GenOpCodes.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>true</Prefer32Bit>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DocumentationFile>GenOpCodes.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>true</Prefer32Bit>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DocumentationFile>GenOpCodes.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>true</Prefer32Bit>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Data" />
diff --git a/GenOpCodes/ModuleMain.vb b/GenOpCodes/ModuleMain.vb
index af35afb..fd0dde7 100644
--- a/GenOpCodes/ModuleMain.vb
+++ b/GenOpCodes/ModuleMain.vb
@@ -4,6 +4,26 @@
 
 Module ModuleMain
     Sub Main()
+        Dim abortMsg As String = "This tool can only be run in DEBUG mode while inside the IDE"
+#If DEBUG Then
+        If Debugger.IsAttached Then
+            Console.WriteLine("Are you sure you want to parse the opcodes' emulation code? [y/N]")
+            If Console.ReadKey(True).Key = ConsoleKey.Y Then
+                RunParser()
+            Else
+                Console.WriteLine("Process aborted...")
+            End If
+        Else
+            Console.WriteLine(abortMsg)
+        End If
+#Else
+        Console.WriteLine(abortMsg)
+#End If
+
+        Console.ReadKey()
+    End Sub
+
+    Private Sub RunParser()
         Dim src As String = IO.File.ReadAllText("..\x8086.vb")
         Dim trg As String = "Partial Public Class X8086
                                 Private Delegate Sub ExecOpcode()
@@ -28,13 +48,18 @@ Module ModuleMain
         Dim startIndex As Integer
         Dim endIndex As Integer
 
+        Dim comment As String = ""
+
         src = src.Replace(" : ", "' " + vbCrLf)
         Dim eof As Integer = src.IndexOf("If useIPAddrOffset Then", p1)
         needle = "Case &H"
 
         Dim addSubCall = Sub(addComment As Boolean, v As Integer)
                              subCalls(v) = $"AddressOf {subName},"
-                             If addComment Then subCalls(v) += $"{vbTab}{src.Substring(p2, p3 - p2)}"
+                             If addComment AndAlso src.Substring(p2, p3 - p2).Trim() <> "'" Then
+                                 comment = $"{vbTab}{src.Substring(p2, p3 - p2)}"
+                                 subCalls(v) += comment
+                             End If
                          End Sub
 
         Dim addSubCalls = Sub(fName As String, range As Boolean)
@@ -49,7 +74,7 @@ Module ModuleMain
                                   Next
                               Else
                                   For i As Integer = 1 To subTokens.Length - 1
-                                      addSubCall(False, Integer.Parse(subTokens(i).Replace("&H", ""), Globalization.NumberStyles.HexNumber))
+                                      addSubCall(True, Integer.Parse(subTokens(i).Replace("&H", ""), Globalization.NumberStyles.HexNumber))
                                   Next
                               End If
                           End Sub
@@ -58,12 +83,12 @@ Module ModuleMain
                             p2 = src.IndexOf("Case &H", p3)
                             If p2 > eof Then p2 = src.IndexOf("Case Else", p3) - Len("Case Else")
                             tmp = src.Substring(p3, p2 - p3).Trim().Replace("Exit Select", "Exit Sub")
-                            subBody += subSkel.Replace("%1", subName).Replace("%2", tmp) + vbCrLf + vbCrLf
+                            subBody += subSkel.Replace("%1", subName + comment).Replace("%2", tmp) + vbCrLf + vbCrLf
                         End Sub
 
         Dim parseCase = Sub()
                             startIndex = Integer.Parse(tokens(0).Replace("&H", ""), Globalization.NumberStyles.HexNumber)
-                            subName = $"_{tokens(0).Replace("&H", "").PadLeft(2, "0")}"
+                            subName += $"_{tokens(0).Replace("&H", "").PadLeft(2, "0")}"
                         End Sub
 
         Dim parseCaseTo = Sub()
@@ -76,8 +101,6 @@ Module ModuleMain
                                  Dim subTokens() As String
                                  Dim fName As String = ""
 
-                                 If tmp.Contains("A4") Then Stop
-
                                  subTokens = tmp.Split(","c)
                                  ReDim tokens(0)
                                  For i As Integer = 0 To subTokens.Length - 1
@@ -101,6 +124,9 @@ Module ModuleMain
                              End Sub
 
         Do
+            comment = ""
+            subName = ""
+
             p1 = src.IndexOf(needle, p1) + needle.Length
             p2 = src.IndexOf("'", p1)
             p3 = src.IndexOf(vbCr, p2)
diff --git a/GenOpCodes/My Project/AssemblyInfo.vb b/GenOpCodes/My Project/AssemblyInfo.vb
index 07dee22..6b610c8 100644
--- a/GenOpCodes/My Project/AssemblyInfo.vb	
+++ b/GenOpCodes/My Project/AssemblyInfo.vb	
@@ -31,5 +31,5 @@ Imports System.Runtime.InteropServices
 ' by using the '*' as shown below:
 ' <Assembly: AssemblyVersion("1.0.*")>
 
-<Assembly: AssemblyVersion("2018.8.27.181")>
-<Assembly: AssemblyFileVersion("2018.8.27.181")>
+<Assembly: AssemblyVersion("2019.2.13.422")>
+<Assembly: AssemblyFileVersion("2019.2.13.422")>
diff --git a/GenOpCodes/My Project/Resources.Designer.vb b/GenOpCodes/My Project/Resources.Designer.vb
index 18c075c..1944561 100644
--- a/GenOpCodes/My Project/Resources.Designer.vb	
+++ b/GenOpCodes/My Project/Resources.Designer.vb	
@@ -11,9 +11,10 @@
 Option Strict On
 Option Explicit On
 
+Imports System
 
 Namespace My.Resources
-
+    
     'This class was auto-generated by the StronglyTypedResourceBuilder
     'class via a tool like ResGen or Visual Studio.
     'To add or remove a member, edit your .ResX file then rerun ResGen
@@ -21,20 +22,20 @@ Namespace My.Resources
     '''<summary>
     '''  A strongly-typed resource class, for looking up localized strings, etc.
     '''</summary>
-    <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0"), _
-     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), _
-     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(), _
-     Global.Microsoft.VisualBasic.HideModuleNameAttribute()> _
+    <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0"),  _
+     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
+     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
+     Global.Microsoft.VisualBasic.HideModuleNameAttribute()>  _
     Friend Module Resources
-
+        
         Private resourceMan As Global.System.Resources.ResourceManager
-
+        
         Private resourceCulture As Global.System.Globalization.CultureInfo
-
+        
         '''<summary>
         '''  Returns the cached ResourceManager instance used by this class.
         '''</summary>
-        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
+        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
         Friend ReadOnly Property ResourceManager() As Global.System.Resources.ResourceManager
             Get
                 If Object.ReferenceEquals(resourceMan, Nothing) Then
@@ -44,17 +45,17 @@ Namespace My.Resources
                 Return resourceMan
             End Get
         End Property
-
+        
         '''<summary>
         '''  Overrides the current thread's CurrentUICulture property for all
         '''  resource lookups using this strongly typed resource class.
         '''</summary>
-        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
+        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
         Friend Property Culture() As Global.System.Globalization.CultureInfo
             Get
                 Return resourceCulture
             End Get
-            Set(ByVal value As Global.System.Globalization.CultureInfo)
+            Set
                 resourceCulture = value
             End Set
         End Property
diff --git a/GenOpCodes/My Project/Settings.Designer.vb b/GenOpCodes/My Project/Settings.Designer.vb
index 93b000b..1768bbc 100644
--- a/GenOpCodes/My Project/Settings.Designer.vb	
+++ b/GenOpCodes/My Project/Settings.Designer.vb	
@@ -13,42 +13,42 @@ Option Explicit On
 
 
 Namespace My
-
-    <Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(), _
-     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0"), _
-     Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
+    
+    <Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
+     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.8.0.0"),  _
+     Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
     Partial Friend NotInheritable Class MySettings
         Inherits Global.System.Configuration.ApplicationSettingsBase
-
-        Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings), MySettings)
-
+        
+        Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings()),MySettings)
+        
 #Region "My.Settings Auto-Save Functionality"
 #If _MyType = "WindowsForms" Then
-        Private Shared addedHandler As Boolean
+    Private Shared addedHandler As Boolean
 
-        Private Shared addedHandlerLockObject As New Object
+    Private Shared addedHandlerLockObject As New Object
 
-        <Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
-        Private Shared Sub AutoSaveSettings(ByVal sender As Global.System.Object, ByVal e As Global.System.EventArgs)
-            If My.Application.SaveMySettingsOnExit Then
-                My.Settings.Save()
-            End If
-        End Sub
+    <Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
+    Private Shared Sub AutoSaveSettings(sender As Global.System.Object, e As Global.System.EventArgs)
+        If My.Application.SaveMySettingsOnExit Then
+            My.Settings.Save()
+        End If
+    End Sub
 #End If
 #End Region
-
+        
         Public Shared ReadOnly Property [Default]() As MySettings
             Get
-
+                
 #If _MyType = "WindowsForms" Then
-                   If Not addedHandler Then
-                        SyncLock addedHandlerLockObject
-                            If Not addedHandler Then
-                                AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
-                                addedHandler = True
-                            End If
-                        End SyncLock
-                    End If
+               If Not addedHandler Then
+                    SyncLock addedHandlerLockObject
+                        If Not addedHandler Then
+                            AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
+                            addedHandler = True
+                        End If
+                    End SyncLock
+                End If
 #End If
                 Return defaultInstance
             End Get
@@ -57,13 +57,13 @@ Namespace My
 End Namespace
 
 Namespace My
-
-    <Global.Microsoft.VisualBasic.HideModuleNameAttribute(), _
-     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), _
-     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()> _
+    
+    <Global.Microsoft.VisualBasic.HideModuleNameAttribute(),  _
+     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
+     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()>  _
     Friend Module MySettingsProperty
-
-        <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")> _
+        
+        <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")>  _
         Friend ReadOnly Property Settings() As Global.GenOpCodes.My.MySettings
             Get
                 Return Global.GenOpCodes.My.MySettings.Default
diff --git a/README.md b/README.md
index 687ee58..c5a92ab 100644
--- a/README.md
+++ b/README.md
@@ -9,15 +9,16 @@ Although it still has some bugs, it is a fairly stable and capable 8088/86/186 e
 
 - Full 8086 architecture emulation: CPU, Memory, Flags, Registers and Stack
 - Peripherals: PIC/8259, PIT/8254, DMA/8237 and PPI/8255
-  - RTC CMOS is currently being implemented
 - Mostly working Adapters: CGA, Speaker and Keyboard
-- Partially working Adapters: VGA, Adlib, Mouse
+- Partially working Adapters: VGA, Adlib and Mouse
 - Integrated Debugger and Console
-- Support for both Floppy and Hard Disk images
 - No BIOS hacks required
 - WinForms and Console samples included
 - Cross-platform support through Mono (the emulator has been tested under Windows, [MacOS, Linux and RaspberryPi](https://whenimbored.xfx.net/2013/10/x8086netemu-linux-mac-os-x-raspberry-pi/))
-- Hard disk and floppy images inspector (FAT12 and FAT16 support only and it's quite buggy)
+- Support for both Floppy and Hard Disk images
+- Hard disk and floppy images inspector / Disk Explorer (FAT12 and FAT16 support only)
+- Support to drag & drop files and folders from the Disk Explorer to the host
+- Support to copy/paste text to/from the emulator and the host
 
 ![Integrated Debugger](http://whenimbored.xfx.net/wp-content/uploads/2018/01/debugger.png)
 
@@ -35,3 +36,14 @@ The speaker emulation uses [NAudio](https://github.com/naudio/NAudio), which onl
 So in order to compile a version of x8086 that works under non-Windows platforms, the Win32 custom constant in the project properties of all the projects in the solution must be set to `False`.
 
 If the aforementioned bug or bugs can be resolved, I will switch the sound backend support to the cross-platform library [BASS](http://www.un4seen.com/).
+
+### Experimental Web UI
+
+![Experimental Web UI](https://xfx.net/stackoverflow/x8086netEmu/x8086_WebUI_01.png)
+
+Since [commit 248](https://github.com/morphx666/x8086NetEmu/commit/c08b69b7c6ffbe165a036b811ff8e2b71e529854) the emulator can be viewed and controlled through a browser by initializing one of the WinForms video adapters with the `enableWebUI` parameter set to `true`.
+
+`cpu.Adapters.Add(New CGAWinForms(cpu, videoPort, ,, True))`
+
+This will create a web server at http://localhost:8086 which uses a simple script to render the emulator's display and capture key events, which will be sent back to the emulator for processing.
+Mouse support is not currently available.
diff --git a/RunTests/App.config b/RunTests/App.config
index 787dcbe..ecdcf8a 100644
--- a/RunTests/App.config
+++ b/RunTests/App.config
@@ -1,6 +1,6 @@
-ï»¿<?xml version="1.0" encoding="utf-8" ?>
+<?xml version="1.0" encoding="utf-8"?>
 <configuration>
     <startup> 
-        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.1" />
+        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/>
     </startup>
-</configuration>
\ No newline at end of file
+</configuration>
diff --git a/RunTests/ModuleMain.vb b/RunTests/ModuleMain.vb
index 82779d2..2573a86 100644
--- a/RunTests/ModuleMain.vb
+++ b/RunTests/ModuleMain.vb
@@ -4,10 +4,14 @@ Imports System.Threading
 Module ModuleMain
     Private cpu As X8086
     Private validData() As Byte = Nothing
+    Private testsTotal As Integer = 0
+    Private failedTotal As Integer = 0
+    Private prefix As String
 
     Sub Main()
         Dim waiter As New AutoResetEvent(False)
 
+        ' X8086.Models.IBMPC_5150 is required as fake86 does not properly handle eflags
         cpu = New X8086(True, False,, X8086.Models.IBMPC_5150) With {.Clock = 47700000}
         AddHandler cpu.EmulationHalted, Sub()
                                             Compare()
@@ -27,7 +31,8 @@ Module ModuleMain
             If Not IO.File.Exists(dataFileName) Then Continue For
             validData = IO.File.ReadAllBytes(dataFileName)
 
-            Console.Write($"Running: {fileName}")
+            prefix = $"Running: {fileName}"
+            Console.Write(prefix)
 
             If cpu.IsHalted Then cpu.HardReset()
             cpu.LoadBIN(f.FullName, &HF000, &H0)
@@ -37,17 +42,28 @@ Module ModuleMain
         Next
         cpu.Close()
 
-#If DEBUG Then
+        Dim passedTotal As Integer = testsTotal - failedTotal
+        Console.ForegroundColor = ConsoleColor.Magenta
+        Console.WriteLine($"Score: {passedTotal}/{testsTotal} [{passedTotal / testsTotal * 100:N2}%]")
+        Console.ForegroundColor = ConsoleColor.Gray
+        Console.WriteLine()
+
         Console.WriteLine("Press any key to exit")
         Console.ReadKey()
-#End If
     End Sub
 
     Private Sub Compare()
+        Const p As Integer = 28
+
+        Dim txt As String = ""
         Dim v1 As String
         Dim v2 As String
         Dim invalidData As New List(Of String)
-        For i As Integer = 0 To validData.Length / 2 - 1 Step 2
+        Dim dataLen As Integer = validData.Length / 2
+
+        testsTotal += dataLen
+
+        For i As Integer = 0 To dataLen - 1 Step 2
             v1 = cpu.RAM16(0, i).ToString("X4")
             v2 = BitConverter.ToInt16(validData, i).ToString("X4")
             If v1 <> v2 Then
@@ -55,7 +71,8 @@ Module ModuleMain
             End If
         Next
         If invalidData.Any() Then
-            Console.WriteLine($" > FAILED [{invalidData.Count}]")
+            txt = $" > FAILED [{invalidData.Count}/{dataLen}]"
+            Console.WriteLine(txt.PadLeft(p - prefix.Length + txt.Length))
             invalidData.ForEach(Sub(id)
                                     Dim t() As String = id.Split(" "c)
                                     Console.ForegroundColor = ConsoleColor.White
@@ -69,8 +86,10 @@ Module ModuleMain
                                     Console.ForegroundColor = ConsoleColor.Gray
                                     'Console.WriteLine($"  {id}")
                                 End Sub)
+            failedTotal += invalidData.Count
         Else
-            Console.WriteLine(" > PASSED")
+            txt = $" > PASSED [{dataLen}]"
+            Console.WriteLine(txt.PadLeft(p - prefix.Length + txt.Length))
         End If
     End Sub
 End Module
\ No newline at end of file
diff --git a/RunTests/My Project/AssemblyInfo.vb b/RunTests/My Project/AssemblyInfo.vb
index 5beccfe..369f21c 100644
--- a/RunTests/My Project/AssemblyInfo.vb	
+++ b/RunTests/My Project/AssemblyInfo.vb	
@@ -31,5 +31,5 @@ Imports System.Runtime.InteropServices
 ' by using the '*' as shown below:
 ' <Assembly: AssemblyVersion("1.0.*")>
 
-<Assembly: AssemblyVersion("2018.8.27.283")>
-<Assembly: AssemblyFileVersion("2018.8.27.283")>
+<Assembly: AssemblyVersion("2019.2.13.721")>
+<Assembly: AssemblyFileVersion("2019.2.13.721")>
diff --git a/RunTests/My Project/Resources.Designer.vb b/RunTests/My Project/Resources.Designer.vb
index 55c9b84..6250345 100644
--- a/RunTests/My Project/Resources.Designer.vb	
+++ b/RunTests/My Project/Resources.Designer.vb	
@@ -11,9 +11,10 @@
 Option Strict On
 Option Explicit On
 
+Imports System
 
 Namespace My.Resources
-
+    
     'This class was auto-generated by the StronglyTypedResourceBuilder
     'class via a tool like ResGen or Visual Studio.
     'To add or remove a member, edit your .ResX file then rerun ResGen
@@ -21,20 +22,20 @@ Namespace My.Resources
     '''<summary>
     '''  A strongly-typed resource class, for looking up localized strings, etc.
     '''</summary>
-    <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0"), _
-     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), _
-     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(), _
-     Global.Microsoft.VisualBasic.HideModuleNameAttribute()> _
+    <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0"),  _
+     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
+     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
+     Global.Microsoft.VisualBasic.HideModuleNameAttribute()>  _
     Friend Module Resources
-
+        
         Private resourceMan As Global.System.Resources.ResourceManager
-
+        
         Private resourceCulture As Global.System.Globalization.CultureInfo
-
+        
         '''<summary>
         '''  Returns the cached ResourceManager instance used by this class.
         '''</summary>
-        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
+        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
         Friend ReadOnly Property ResourceManager() As Global.System.Resources.ResourceManager
             Get
                 If Object.ReferenceEquals(resourceMan, Nothing) Then
@@ -44,17 +45,17 @@ Namespace My.Resources
                 Return resourceMan
             End Get
         End Property
-
+        
         '''<summary>
         '''  Overrides the current thread's CurrentUICulture property for all
         '''  resource lookups using this strongly typed resource class.
         '''</summary>
-        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
+        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
         Friend Property Culture() As Global.System.Globalization.CultureInfo
             Get
                 Return resourceCulture
             End Get
-            Set(ByVal value As Global.System.Globalization.CultureInfo)
+            Set
                 resourceCulture = value
             End Set
         End Property
diff --git a/RunTests/My Project/Settings.Designer.vb b/RunTests/My Project/Settings.Designer.vb
index dc0d59d..95aa273 100644
--- a/RunTests/My Project/Settings.Designer.vb	
+++ b/RunTests/My Project/Settings.Designer.vb	
@@ -13,42 +13,42 @@ Option Explicit On
 
 
 Namespace My
-
-    <Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(), _
-     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0"), _
-     Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
+    
+    <Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
+     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.8.0.0"),  _
+     Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
     Partial Friend NotInheritable Class MySettings
         Inherits Global.System.Configuration.ApplicationSettingsBase
-
-        Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings), MySettings)
-
+        
+        Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings()),MySettings)
+        
 #Region "My.Settings Auto-Save Functionality"
 #If _MyType = "WindowsForms" Then
-        Private Shared addedHandler As Boolean
+    Private Shared addedHandler As Boolean
 
-        Private Shared addedHandlerLockObject As New Object
+    Private Shared addedHandlerLockObject As New Object
 
-        <Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
-        Private Shared Sub AutoSaveSettings(ByVal sender As Global.System.Object, ByVal e As Global.System.EventArgs)
-            If My.Application.SaveMySettingsOnExit Then
-                My.Settings.Save()
-            End If
-        End Sub
+    <Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
+    Private Shared Sub AutoSaveSettings(sender As Global.System.Object, e As Global.System.EventArgs)
+        If My.Application.SaveMySettingsOnExit Then
+            My.Settings.Save()
+        End If
+    End Sub
 #End If
 #End Region
-
+        
         Public Shared ReadOnly Property [Default]() As MySettings
             Get
-
+                
 #If _MyType = "WindowsForms" Then
-                   If Not addedHandler Then
-                        SyncLock addedHandlerLockObject
-                            If Not addedHandler Then
-                                AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
-                                addedHandler = True
-                            End If
-                        End SyncLock
-                    End If
+               If Not addedHandler Then
+                    SyncLock addedHandlerLockObject
+                        If Not addedHandler Then
+                            AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
+                            addedHandler = True
+                        End If
+                    End SyncLock
+                End If
 #End If
                 Return defaultInstance
             End Get
@@ -57,13 +57,13 @@ Namespace My
 End Namespace
 
 Namespace My
-
-    <Global.Microsoft.VisualBasic.HideModuleNameAttribute(), _
-     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), _
-     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()> _
+    
+    <Global.Microsoft.VisualBasic.HideModuleNameAttribute(),  _
+     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
+     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()>  _
     Friend Module MySettingsProperty
-
-        <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")> _
+        
+        <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")>  _
         Friend ReadOnly Property Settings() As Global.RunTests.My.MySettings
             Get
                 Return Global.RunTests.My.MySettings.Default
diff --git a/RunTests/RunTests.vbproj b/RunTests/RunTests.vbproj
index bcb5bb4..31d2b6e 100644
--- a/RunTests/RunTests.vbproj
+++ b/RunTests/RunTests.vbproj
@@ -11,8 +11,9 @@
     <AssemblyName>RunTests</AssemblyName>
     <FileAlignment>512</FileAlignment>
     <MyType>Console</MyType>
-    <TargetFrameworkVersion>v4.7.1</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
     <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <PlatformTarget>x86</PlatformTarget>
@@ -46,6 +47,52 @@
   <PropertyGroup>
     <OptionInfer>On</OptionInfer>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DocumentationFile>RunTests.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>true</Prefer32Bit>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DocumentationFile>RunTests.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>true</Prefer32Bit>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DocumentationFile>RunTests.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>true</Prefer32Bit>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DocumentationFile>RunTests.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>true</Prefer32Bit>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Data" />
diff --git a/x8086NetEmu.sln b/x8086NetEmu.sln
index e9d5fd1..cc7f42b 100644
--- a/x8086NetEmu.sln
+++ b/x8086NetEmu.sln
@@ -21,83 +21,139 @@ EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug (Non Win)|Any CPU = Debug (Non Win)|Any CPU
+		Debug (Non Win)|x64 = Debug (Non Win)|x64
 		Debug (Non Win)|x86 = Debug (Non Win)|x86
 		Debug|Any CPU = Debug|Any CPU
+		Debug|x64 = Debug|x64
 		Debug|x86 = Debug|x86
 		Release (Non Win)|Any CPU = Release (Non Win)|Any CPU
+		Release (Non Win)|x64 = Release (Non Win)|x64
 		Release (Non Win)|x86 = Release (Non Win)|x86
 		Release|Any CPU = Release|Any CPU
+		Release|x64 = Release|x64
 		Release|x86 = Release|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug (Non Win)|Any CPU.ActiveCfg = Debug (Non Win)|x86
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug (Non Win)|Any CPU.ActiveCfg = Debug (Non Win)|Any CPU
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug (Non Win)|Any CPU.Build.0 = Debug (Non Win)|Any CPU
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug (Non Win)|x64.ActiveCfg = Debug (Non Win)|x64
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug (Non Win)|x64.Build.0 = Debug (Non Win)|x64
 		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug (Non Win)|x86.ActiveCfg = Debug (Non Win)|x86
 		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug (Non Win)|x86.Build.0 = Debug (Non Win)|x86
-		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug|Any CPU.ActiveCfg = Debug|x86
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug|x64.ActiveCfg = Debug|x64
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug|x64.Build.0 = Debug|x64
 		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug|x86.ActiveCfg = Debug|x86
 		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Debug|x86.Build.0 = Debug|x86
-		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release (Non Win)|Any CPU.ActiveCfg = Release (Non Win)|x86
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release (Non Win)|Any CPU.ActiveCfg = Release (Non Win)|Any CPU
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release (Non Win)|Any CPU.Build.0 = Release (Non Win)|Any CPU
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release (Non Win)|x64.ActiveCfg = Release (Non Win)|x64
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release (Non Win)|x64.Build.0 = Release (Non Win)|x64
 		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release (Non Win)|x86.ActiveCfg = Release (Non Win)|x86
 		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release (Non Win)|x86.Build.0 = Release (Non Win)|x86
-		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release|Any CPU.ActiveCfg = Release|x86
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release|Any CPU.Build.0 = Release|Any CPU
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release|x64.ActiveCfg = Release|x64
+		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release|x64.Build.0 = Release|x64
 		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release|x86.ActiveCfg = Release|x86
 		{2D0B2D2C-0261-4FF8-AA8C-5E7E7C134840}.Release|x86.Build.0 = Release|x86
-		{27276D22-D0B7-4995-B687-924CF829E595}.Debug (Non Win)|Any CPU.ActiveCfg = Debug (Non Win)|x86
+		{27276D22-D0B7-4995-B687-924CF829E595}.Debug (Non Win)|Any CPU.ActiveCfg = Debug (Non Win)|Any CPU
+		{27276D22-D0B7-4995-B687-924CF829E595}.Debug (Non Win)|Any CPU.Build.0 = Debug (Non Win)|Any CPU
+		{27276D22-D0B7-4995-B687-924CF829E595}.Debug (Non Win)|x64.ActiveCfg = Debug (Non Win)|x64
+		{27276D22-D0B7-4995-B687-924CF829E595}.Debug (Non Win)|x64.Build.0 = Debug (Non Win)|x64
 		{27276D22-D0B7-4995-B687-924CF829E595}.Debug (Non Win)|x86.ActiveCfg = Debug (Non Win)|x86
 		{27276D22-D0B7-4995-B687-924CF829E595}.Debug (Non Win)|x86.Build.0 = Debug (Non Win)|x86
-		{27276D22-D0B7-4995-B687-924CF829E595}.Debug|Any CPU.ActiveCfg = Debug|x86
+		{27276D22-D0B7-4995-B687-924CF829E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{27276D22-D0B7-4995-B687-924CF829E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{27276D22-D0B7-4995-B687-924CF829E595}.Debug|x64.ActiveCfg = Debug|x64
+		{27276D22-D0B7-4995-B687-924CF829E595}.Debug|x64.Build.0 = Debug|x64
 		{27276D22-D0B7-4995-B687-924CF829E595}.Debug|x86.ActiveCfg = Debug|x86
 		{27276D22-D0B7-4995-B687-924CF829E595}.Debug|x86.Build.0 = Debug|x86
-		{27276D22-D0B7-4995-B687-924CF829E595}.Release (Non Win)|Any CPU.ActiveCfg = Release (Non Win)|x86
+		{27276D22-D0B7-4995-B687-924CF829E595}.Release (Non Win)|Any CPU.ActiveCfg = Release (Non Win)|Any CPU
+		{27276D22-D0B7-4995-B687-924CF829E595}.Release (Non Win)|Any CPU.Build.0 = Release (Non Win)|Any CPU
+		{27276D22-D0B7-4995-B687-924CF829E595}.Release (Non Win)|x64.ActiveCfg = Release (Non Win)|x64
+		{27276D22-D0B7-4995-B687-924CF829E595}.Release (Non Win)|x64.Build.0 = Release (Non Win)|x64
 		{27276D22-D0B7-4995-B687-924CF829E595}.Release (Non Win)|x86.ActiveCfg = Release (Non Win)|x86
 		{27276D22-D0B7-4995-B687-924CF829E595}.Release (Non Win)|x86.Build.0 = Release (Non Win)|x86
-		{27276D22-D0B7-4995-B687-924CF829E595}.Release|Any CPU.ActiveCfg = Release|x86
+		{27276D22-D0B7-4995-B687-924CF829E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{27276D22-D0B7-4995-B687-924CF829E595}.Release|Any CPU.Build.0 = Release|Any CPU
+		{27276D22-D0B7-4995-B687-924CF829E595}.Release|x64.ActiveCfg = Release|x64
+		{27276D22-D0B7-4995-B687-924CF829E595}.Release|x64.Build.0 = Release|x64
 		{27276D22-D0B7-4995-B687-924CF829E595}.Release|x86.ActiveCfg = Release|x86
 		{27276D22-D0B7-4995-B687-924CF829E595}.Release|x86.Build.0 = Release|x86
-		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug (Non Win)|Any CPU.ActiveCfg = Debug (Non Win)|x86
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug (Non Win)|Any CPU.ActiveCfg = Debug (Non Win)|Any CPU
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug (Non Win)|Any CPU.Build.0 = Debug (Non Win)|Any CPU
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug (Non Win)|x64.ActiveCfg = Debug (Non Win)|x64
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug (Non Win)|x64.Build.0 = Debug (Non Win)|x64
 		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug (Non Win)|x86.ActiveCfg = Debug (Non Win)|x86
 		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug (Non Win)|x86.Build.0 = Debug (Non Win)|x86
-		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug|Any CPU.ActiveCfg = Debug|x86
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug|x64.ActiveCfg = Debug|x64
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug|x64.Build.0 = Debug|x64
 		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug|x86.ActiveCfg = Debug|x86
 		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Debug|x86.Build.0 = Debug|x86
-		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release (Non Win)|Any CPU.ActiveCfg = Release (Non Win)|x86
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release (Non Win)|Any CPU.ActiveCfg = Release (Non Win)|Any CPU
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release (Non Win)|Any CPU.Build.0 = Release (Non Win)|Any CPU
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release (Non Win)|x64.ActiveCfg = Release (Non Win)|x64
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release (Non Win)|x64.Build.0 = Release (Non Win)|x64
 		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release (Non Win)|x86.ActiveCfg = Release (Non Win)|x86
 		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release (Non Win)|x86.Build.0 = Release (Non Win)|x86
-		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release|Any CPU.ActiveCfg = Release|x86
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release|Any CPU.Build.0 = Release|Any CPU
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release|x64.ActiveCfg = Release|x64
+		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release|x64.Build.0 = Release|x64
 		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release|x86.ActiveCfg = Release|x86
 		{00A6EBE1-1A2D-4B94-BA2F-0AA82F45F7DD}.Release|x86.Build.0 = Release|x86
 		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug (Non Win)|Any CPU.ActiveCfg = Debug|Any CPU
 		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug (Non Win)|Any CPU.Build.0 = Debug|Any CPU
-		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug (Non Win)|x86.ActiveCfg = Debug|Any CPU
-		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug (Non Win)|x86.Build.0 = Debug|Any CPU
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug (Non Win)|x64.ActiveCfg = Debug|x64
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug (Non Win)|x64.Build.0 = Debug|x64
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug (Non Win)|x86.ActiveCfg = Debug|x86
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug (Non Win)|x86.Build.0 = Debug|x86
 		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug|x86.Build.0 = Debug|Any CPU
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug|x64.ActiveCfg = Debug|x64
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug|x64.Build.0 = Debug|x64
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug|x86.ActiveCfg = Debug|x86
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Debug|x86.Build.0 = Debug|x86
 		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release (Non Win)|Any CPU.ActiveCfg = Release|Any CPU
 		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release (Non Win)|Any CPU.Build.0 = Release|Any CPU
-		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release (Non Win)|x86.ActiveCfg = Release|Any CPU
-		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release (Non Win)|x86.Build.0 = Release|Any CPU
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release (Non Win)|x64.ActiveCfg = Release|x64
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release (Non Win)|x64.Build.0 = Release|x64
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release (Non Win)|x86.ActiveCfg = Release|x86
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release (Non Win)|x86.Build.0 = Release|x86
 		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release|Any CPU.Build.0 = Release|Any CPU
-		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release|x86.ActiveCfg = Release|Any CPU
-		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release|x86.Build.0 = Release|Any CPU
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release|x64.ActiveCfg = Release|x64
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release|x64.Build.0 = Release|x64
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release|x86.ActiveCfg = Release|x86
+		{6A4C074D-6B16-410A-963C-A42F1E01D5DB}.Release|x86.Build.0 = Release|x86
 		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug (Non Win)|Any CPU.ActiveCfg = Debug|Any CPU
 		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug (Non Win)|Any CPU.Build.0 = Debug|Any CPU
-		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug (Non Win)|x86.ActiveCfg = Debug|Any CPU
-		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug (Non Win)|x86.Build.0 = Debug|Any CPU
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug (Non Win)|x64.ActiveCfg = Debug|x64
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug (Non Win)|x64.Build.0 = Debug|x64
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug (Non Win)|x86.ActiveCfg = Debug|x86
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug (Non Win)|x86.Build.0 = Debug|x86
 		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug|x86.Build.0 = Debug|Any CPU
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug|x64.ActiveCfg = Debug|x64
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug|x64.Build.0 = Debug|x64
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug|x86.ActiveCfg = Debug|x86
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Debug|x86.Build.0 = Debug|x86
 		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release (Non Win)|Any CPU.ActiveCfg = Release|Any CPU
 		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release (Non Win)|Any CPU.Build.0 = Release|Any CPU
-		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release (Non Win)|x86.ActiveCfg = Release|Any CPU
-		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release (Non Win)|x86.Build.0 = Release|Any CPU
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release (Non Win)|x64.ActiveCfg = Release|x64
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release (Non Win)|x64.Build.0 = Release|x64
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release (Non Win)|x86.ActiveCfg = Release|x86
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release (Non Win)|x86.Build.0 = Release|x86
 		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release|Any CPU.Build.0 = Release|Any CPU
-		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release|x86.ActiveCfg = Release|Any CPU
-		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release|x86.Build.0 = Release|Any CPU
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release|x64.ActiveCfg = Release|x64
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release|x64.Build.0 = Release|x64
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release|x86.ActiveCfg = Release|x86
+		{A515C87D-A1D1-4C0B-B726-3D2C78588585}.Release|x86.Build.0 = Release|x86
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -105,4 +161,60 @@ Global
 	GlobalSection(ExtensibilityGlobals) = postSolution
 		SolutionGuid = {47FEC97B-DF82-4572-8242-79AF34F1CEAE}
 	EndGlobalSection
+	GlobalSection(AutomaticVersions) = postSolution
+		UpdateAssemblyVersion.Debug (Non Win)|Any CPU = True
+		UpdateAssemblyFileVersion.Debug (Non Win)|Any CPU = True
+		UpdateAssemblyInfoVersion.Debug (Non Win)|Any CPU = True
+		AssemblyVersionSettings.Debug (Non Win)|Any CPU = None.None.None.None
+		AssemblyFileVersionSettings.Debug (Non Win)|Any CPU = None.None.None.None
+		AssemblyInfoVersionSettings.Debug (Non Win)|Any CPU = None.None.None.None
+		UpdatePackageVersion.Debug (Non Win)|Any CPU = False
+		AssemblyInfoVersionType.Debug (Non Win)|Any CPU = SettingsVersion
+		InheritWinAppVersionFrom.Debug (Non Win)|Any CPU = None
+		UpdateAssemblyVersion.Debug (Non Win)|x64 = True
+		UpdateAssemblyFileVersion.Debug (Non Win)|x64 = True
+		UpdateAssemblyInfoVersion.Debug (Non Win)|x64 = True
+		AssemblyVersionSettings.Debug (Non Win)|x64 = None.None.None.None
+		AssemblyFileVersionSettings.Debug (Non Win)|x64 = None.None.None.None
+		AssemblyInfoVersionSettings.Debug (Non Win)|x64 = None.None.None.None
+		UpdatePackageVersion.Debug (Non Win)|x64 = False
+		AssemblyInfoVersionType.Debug (Non Win)|x64 = SettingsVersion
+		InheritWinAppVersionFrom.Debug (Non Win)|x64 = None
+		UpdateAssemblyVersion.Debug (Non Win)|x86 = True
+		UpdateAssemblyFileVersion.Debug (Non Win)|x86 = True
+		UpdateAssemblyInfoVersion.Debug (Non Win)|x86 = True
+		AssemblyVersionSettings.Debug (Non Win)|x86 = None.None.None.None
+		AssemblyFileVersionSettings.Debug (Non Win)|x86 = None.None.None.None
+		AssemblyInfoVersionSettings.Debug (Non Win)|x86 = None.None.None.None
+		UpdatePackageVersion.Debug (Non Win)|x86 = False
+		AssemblyInfoVersionType.Debug (Non Win)|x86 = SettingsVersion
+		InheritWinAppVersionFrom.Debug (Non Win)|x86 = None
+		UpdateAssemblyVersion.Debug|Any CPU = True
+		UpdateAssemblyFileVersion.Debug|Any CPU = True
+		UpdateAssemblyInfoVersion.Debug|Any CPU = True
+		AssemblyVersionSettings.Debug|Any CPU = None.None.None.None
+		AssemblyFileVersionSettings.Debug|Any CPU = None.None.None.None
+		AssemblyInfoVersionSettings.Debug|Any CPU = None.None.None.None
+		UpdatePackageVersion.Debug|Any CPU = False
+		AssemblyInfoVersionType.Debug|Any CPU = SettingsVersion
+		InheritWinAppVersionFrom.Debug|Any CPU = None
+		UpdateAssemblyVersion.Debug|x64 = True
+		UpdateAssemblyFileVersion.Debug|x64 = True
+		UpdateAssemblyInfoVersion.Debug|x64 = True
+		AssemblyVersionSettings.Debug|x64 = None.None.None.None
+		AssemblyFileVersionSettings.Debug|x64 = None.None.None.None
+		AssemblyInfoVersionSettings.Debug|x64 = None.None.None.None
+		UpdatePackageVersion.Debug|x64 = False
+		AssemblyInfoVersionType.Debug|x64 = SettingsVersion
+		InheritWinAppVersionFrom.Debug|x64 = None
+		UpdateAssemblyVersion.Debug|x86 = True
+		UpdateAssemblyFileVersion.Debug|x86 = True
+		UpdateAssemblyInfoVersion.Debug|x86 = True
+		AssemblyVersionSettings.Debug|x86 = None.None.None.None
+		AssemblyFileVersionSettings.Debug|x86 = None.None.None.None
+		AssemblyInfoVersionSettings.Debug|x86 = None.None.None.None
+		UpdatePackageVersion.Debug|x86 = False
+		AssemblyInfoVersionType.Debug|x86 = SettingsVersion
+		InheritWinAppVersionFrom.Debug|x86 = None
+	EndGlobalSection
 EndGlobal
diff --git a/x8086NetEmu/Adapters/Adapter.vb b/x8086NetEmu/Adapters/Adapter.vb
index e0854db..b559c21 100644
--- a/x8086NetEmu/Adapters/Adapter.vb
+++ b/x8086NetEmu/Adapters/Adapter.vb
@@ -23,7 +23,7 @@
         End Get
         Set(value As X8086)
             mCPU = value
-            InitiAdapter()
+            Threading.Tasks.Task.Run(AddressOf InitiAdapter)
         End Set
     End Property
 
@@ -47,7 +47,7 @@
     End Property
 
     Public MustOverride Overrides ReadOnly Property Description As String
-    Public MustOverride Overrides Function [In](port As UInt32) As UInt32
-    Public MustOverride Overrides Sub Out(port As UInt32, value As UInt32)
+    Public MustOverride Overrides Function [In](port As UInt32) As UInt16
+    Public MustOverride Overrides Sub Out(port As UInt32, value As UInt16)
     Public MustOverride Overrides ReadOnly Property Name As String
 End Class
diff --git a/x8086NetEmu/Adapters/Audio/AdlibAdapter.vb b/x8086NetEmu/Adapters/Audio/AdlibAdapter.vb
index 6e08e6a..8519461 100644
--- a/x8086NetEmu/Adapters/Audio/AdlibAdapter.vb
+++ b/x8086NetEmu/Adapters/Audio/AdlibAdapter.vb
@@ -1,11 +1,12 @@
-ï»¿Imports System.Threading
+ï»¿#If Win32 Then
+Imports System.Threading
 Imports NAudio.Wave
 
 Public Class AdlibAdapter ' Based on fake86's implementation
     Inherits Adapter
 
     Private waveOut As WaveOut
-    Private audioProvider As CustomBufferProvider
+    Private audioProvider As SpeakerAdpater.CustomBufferProvider
     Private ReadOnly mAudioBuffer() As Byte
 
     Private ReadOnly mCPU As X8086
@@ -56,46 +57,42 @@ Public Class AdlibAdapter ' Based on fake86's implementation
     }
     }
 
-    Private oplStep() As Byte = {0, 0, 0, 0, 0, 0, 0, 0, 0}
+    Private ReadOnly oplStep() As Byte = {0, 0, 0, 0, 0, 0, 0, 0, 0}
 
-    Private Structure AdlibOpStruct
+    Private Structure OplStruct
         Public wave As Byte
     End Structure
-    Private adlibOp(9 - 1)() As AdlibOpStruct
+    Private Opl(9 - 1)() As OplStruct
 
-    Private Structure AdlibChanStruct
+    Private Structure ChanStruct
         Public Frequency As UInt16
         Public ConvFreq As Double
         Public KeyOn As Boolean
         Public Octave As UInt16
         Public WaveformSelect As Byte
     End Structure
-    Private ReadOnly adlibChan(9 - 1) As AdlibChanStruct
+    Private ReadOnly channel(9 - 1) As ChanStruct
 
     Private ReadOnly attackTable() As Double = {1.0003, 1.00025, 1.0002, 1.00015, 1.0001, 1.00009, 1.00008, 1.00007, 1.00006, 1.00005, 1.00004, 1.00003, 1.00002, 1.00001, 1.000005}
     Private ReadOnly decayTable() As Double = {0.99999, 0.999985, 0.99998, 0.999975, 0.99997, 0.999965, 0.99996, 0.999955, 0.99995, 0.999945, 0.99994, 0.999935, 0.99994, 0.999925, 0.99992, 0.99991}
-    Private ReadOnly opTable() As Byte = {0, 0, 0, 1, 1, 1, 255, 255, 0, 0, 0, 1, 1, 1, 255, 255, 0, 0, 0, 1, 1, 1}
+    Private ReadOnly oplTable() As Byte = {0, 0, 0, 1, 1, 1, 255, 255, 0, 0, 0, 1, 1, 1, 255, 255, 0, 0, 0, 1, 1, 1}
 
-    Private ReadOnly adlibEnv(9 - 1) As Double
-    Private ReadOnly adlibDecay(9 - 1) As Double
-    Private ReadOnly adlibAttack(9 - 1) As Double
+    Private ReadOnly envelope(9 - 1) As Double
+    Private ReadOnly decay(9 - 1) As Double
+    Private ReadOnly attack(9 - 1) As Double
+    Private ReadOnly attack2(9 - 1) As Boolean
 
-    Private Const SampleRate As UInt32 = 44100
-
-    Private ReadOnly adlibRegMem(&HFF - 1) As UInt16
-    Private adlibAddr As UInt16 = 0
-    Private adlibPrecussion As Boolean = False
-    Private adlibStatus As Byte = 0
-    Private ReadOnly adlibStep(9 - 1) As Double
-
-    'Private adlibTicks As Long
-    'Private lastAdlibTicks As Long
+    Private ReadOnly regMem(&HFF - 1) As UInt16
+    Private address As UInt16 = 0
+    Private precussion As Boolean = False
+    Private status As Byte = 0
+    Private ReadOnly oplSstep(9 - 1) As Double
 
     Public Sub New(cpu As X8086)
         mCPU = cpu
 
-        For i As Integer = 0 To adlibOp.Length - 1
-            ReDim adlibOp(i)(2 - 1)
+        For i As Integer = 0 To Opl.Length - 1
+            ReDim Opl(i)(2 - 1)
         Next
 
         ValidPortAddress.Add(&H388)
@@ -103,7 +100,7 @@ Public Class AdlibAdapter ' Based on fake86's implementation
 
         ReDim Preserve attackTable(16 - 1)
         ReDim Preserve decayTable(16 - 1)
-        ReDim Preserve opTable(16 - 1)
+        ReDim Preserve oplTable(16 - 1)
     End Sub
 
     Public Property Volume As Double
@@ -128,90 +125,93 @@ Public Class AdlibAdapter ' Based on fake86's implementation
 
     Public Overrides Sub InitiAdapter()
         waveOut = New WaveOut() With {
-            .NumberOfBuffers = 4,
+            .NumberOfBuffers = 32,
             .DesiredLatency = 200
         }
-        audioProvider = New CustomBufferProvider(AddressOf FillAudioBuffer, SampleRate, 8, 1)
+        audioProvider = New SpeakerAdpater.CustomBufferProvider(AddressOf FillAudioBuffer, SpeakerAdpater.SampleRate, 8, 1)
         waveOut.Init(audioProvider)
-
-        'adlibTicks = (Scheduler.BASECLOCK / SampleRate) * waveOut.NumberOfBuffers  ' FIXME: I don't think this is 100% correct
-        'adlibTicks = (Scheduler.BASECLOCK / SampleRate)
-        'lastAdlibTicks = Long.MaxValue
-
         waveOut.Play()
     End Sub
 
-    Public Sub FillAudioBuffer(buffer() As Byte)
-        'Dim t As Long = Now.Ticks
-        'If t >= (lastAdlibTicks + adlibTicks) Then
+    Private tickCount As Integer
+    Private Sub FillAudioBuffer(buffer() As Byte)
+        tickCount += 1
+        If tickCount >= SpeakerAdpater.SampleRate * (X8086.BASECLOCK / mCPU.Clock) Then
+            tickCount = 0
+
+            SyncLock channel
+                For currentChannel As Byte = 0 To 9 - 1
+                    If Frequency(currentChannel) <> 0 Then
+                        If attack2(currentChannel) Then
+                            envelope(currentChannel) *= decay(currentChannel)
+                        Else
+                            envelope(currentChannel) *= attack(currentChannel)
+                            If envelope(currentChannel) >= 1.0 Then attack2(currentChannel) = True
+                        End If
+                    End If
+                Next
+            End SyncLock
+        End If
+
         For i As Integer = 0 To buffer.Length - 1
-            buffer(i) = AdlibGenerateSample() + 128
+            buffer(i) = GenerateSample() + 128
         Next
-
-        'lastAdlibTicks = t - (t - (lastAdlibTicks + adlibTicks))
-        'End If
-
-        'If (lastAdlibTicks Mod adlibTicks) = 8 Then AdlibTick()
     End Sub
 
-    Public Overrides Function [In](port As UInt32) As UInt32
-        If adlibRegMem(4) = 0 Then
-            adlibStatus = 0
-        Else
-            adlibStatus = &H80
-        End If
-        adlibStatus += (adlibRegMem(4) And 1) * &H40 + (adlibRegMem(4) And 2) * &H10
-        Return adlibStatus
+    Public Overrides Function [In](port As UInt32) As UInt16
+        status = If(regMem(4) = 0, 0, &H80)
+        status += (regMem(4) And 1) * &H40 + (regMem(4) And 2) * &H10
+        Return status
     End Function
 
-    Public Overrides Sub Out(port As UInt32, value As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
         If port = &H388 Then
-            adlibAddr = value
+            address = value
             Exit Sub
         End If
 
-        port = adlibAddr
-        adlibRegMem(port) = value
+        port = address
+        regMem(port) = value
 
         Select Case port
             Case 4 ' Timer Control
                 If (value And &H80) <> 0 Then
-                    adlibStatus = 0
-                    adlibRegMem(4) = 0
+                    status = 0
+                    regMem(4) = 0
                 End If
             Case &HBD
-                adlibPrecussion = (value And &H10) <> 0
+                precussion = (value And &H10) <> 0
         End Select
 
         If port >= &H60 AndAlso port <= &H75 Then ' Attack / Decay
             port = (port And 15) Mod 9
-            adlibAttack(port) = attackTable(15 - (value >> 4)) * 1.006
-            adlibDecay(port) = decayTable(value And 15)
+            attack(port) = attackTable(15 - (value >> 4)) * 1.006
+            decay(port) = decayTable(value And 15)
         ElseIf port >= &HA0 AndAlso port <= &HB8 Then ' Octave / Frequency / Key On
-            port = (port And 15)
-            If Not adlibChan(port Mod 9).KeyOn AndAlso ((adlibRegMem(&HB0 + port) >> 5) And 1) = 1 Then
-                adlibAttack(port Mod 9) = 0
-                adlibEnv(port Mod 9) = 0.0025
+            port = port And 15
+            If Not channel(port Mod 9).KeyOn AndAlso ((regMem(&HB0 + port) >> 5) And 1) = 1 Then
+                attack2(port Mod 9) = False
+                envelope(port Mod 9) = 0.0025
             End If
 
-            SyncLock adlibChan
-                adlibChan(port Mod 9).Frequency = adlibRegMem(&HA0 + port) Or ((adlibRegMem(&HB0 + port) And 3) << 8)
-                adlibChan(port Mod 9).ConvFreq = adlibChan(port Mod 9).Frequency * 0.7626459
-                adlibChan(port Mod 9).KeyOn = ((adlibRegMem(&HB0 + port) >> 5) And 1) = 1
-                adlibChan(port Mod 9).Octave = (adlibRegMem(&HB0 + port) >> 2) And 7
+            SyncLock channel
+                channel(port Mod 9).Frequency = regMem(&HA0 + port) Or ((regMem(&HB0 + port) And 3) << 8)
+                channel(port Mod 9).ConvFreq = channel(port Mod 9).Frequency * 0.7626459
+                channel(port Mod 9).KeyOn = ((regMem(&HB0 + port) >> 5) And 1) = 1
+                channel(port Mod 9).Octave = (regMem(&HB0 + port) >> 2) And 7
             End SyncLock
         ElseIf port >= &HE0 And port <= &HF5 Then ' Waveform select
-            adlibChan((port And 15) Mod 9).WaveformSelect = value And 3
+            channel((port And 15) Mod 9).WaveformSelect = value And 3
         End If
     End Sub
 
-    Private Function AdlibFrequency(channel As Byte) As UInt16
+    Private Function Frequency(channel As Byte) As UInt16
         Dim tmpFrequency As UInt16
 
-        If Not adlibChan(channel).KeyOn Then Return 0
-        tmpFrequency = adlibChan(channel).ConvFreq
+        If Not Me.channel(channel).KeyOn Then Return 0
+        tmpFrequency = Me.channel(channel).ConvFreq
 
-        Select Case adlibChan(channel).Octave
+        Select Case Me.channel(channel).Octave
             Case 0 : tmpFrequency = tmpFrequency >> 4
             Case 1 : tmpFrequency = tmpFrequency >> 3
             Case 2 : tmpFrequency = tmpFrequency >> 2
@@ -224,58 +224,45 @@ Public Class AdlibAdapter ' Based on fake86's implementation
         Return tmpFrequency
     End Function
 
-    Private Function AdlibSample(channel As Byte) As Int32
-        If adlibPrecussion AndAlso channel >= 6 AndAlso channel <= 8 Then Return 0
+    Private Function Sample(channel As Byte) As Int32
+        If precussion AndAlso channel >= 6 AndAlso channel <= 8 Then Return 0
 
-        Dim fullStep As UInt32 = SampleRate \ AdlibFrequency(channel)
-        Dim idx As Byte = (adlibStep(channel) / (fullStep / 256.0)) Mod 255
-        Dim tmpSample As Int32 = oplWave(adlibChan(channel).WaveformSelect)(idx)
-        Dim tmpStep As Double = adlibEnv(channel)
+        Dim fullStep As UInt32 = SpeakerAdpater.SampleRate \ Frequency(channel)
+        Dim idx As Byte = (oplSstep(channel) / (fullStep / 256.0)) Mod 255
+        Dim tmpSample As Integer = oplWave(Me.channel(channel).WaveformSelect)(idx)
+        Dim tmpStep As Double = envelope(channel)
         If tmpStep > 1.0 Then tmpStep = 1.0
-        tmpSample = CDbl(tmpSample) * tmpStep * 3.0
+        tmpSample = CDbl(tmpSample) * tmpStep * 8.0
 
-        adlibStep(channel) += 1
-        If adlibStep(channel) > fullStep Then adlibStep(channel) = 0
+        oplSstep(channel) += 1
+        If oplSstep(channel) > fullStep Then oplSstep(channel) = 0
         Return tmpSample
     End Function
 
-    Private Function AdlibGenerateSample() As Int16
-        Dim adlibAccumulator As Int16 = 0
-        SyncLock adlibChan
+    Private Function GenerateSample() As Int16
+        Dim accumulator As Int16 = 0
+        SyncLock channel
             For currentChannel As Byte = 0 To 9 - 1
-                If AdlibFrequency(currentChannel) <> 0 Then adlibAccumulator += AdlibSample(currentChannel)
+                If Frequency(currentChannel) <> 0 Then accumulator += Sample(currentChannel)
             Next
         End SyncLock
-        Return adlibAccumulator
+        Return accumulator
     End Function
 
-    'Private Sub AdlibTick()
-    '    For currentChannel As Byte = 0 To 9 - 1
-    '        If AdlibFrequency(currentChannel) <> 0 Then
-    '            If adlibAttack(currentChannel) <> 0 Then
-    '                adlibEnv(currentChannel) *= adlibDecay(currentChannel)
-    '            Else
-    '                adlibEnv(currentChannel) *= adlibAttack(currentChannel)
-    '                If adlibEnv(currentChannel) >= 1 Then adlibAttack(currentChannel) = 1
-    '            End If
-    '        End If
-    '    Next
-    'End Sub
-
     Public Overrides ReadOnly Property Name As String
         Get
-            Return "Adlib OPL2"
+            Return "Adlib OPL2" ' FM OPerator Type-L
         End Get
     End Property
 
     Public Overrides ReadOnly Property Description As String
         Get
-            Return "Adlib OPL2"
+            Return "Yamaha YM3526"
         End Get
     End Property
 
     Public Overrides Sub Run()
-        X8086.Notify("Adlib Running", X8086.NotificationReasons.Info)
+        X8086.Notify($"{Name} Running", X8086.NotificationReasons.Info)
     End Sub
 
     Public Overrides ReadOnly Property Type As Adapter.AdapterType
@@ -286,7 +273,7 @@ Public Class AdlibAdapter ' Based on fake86's implementation
 
     Public Overrides ReadOnly Property Vendor As String
         Get
-            Return "xFX JumpStart"
+            Return "Ad Lib, Inc."
         End Get
     End Property
 
@@ -304,7 +291,8 @@ Public Class AdlibAdapter ' Based on fake86's implementation
 
     Public Overrides ReadOnly Property VersionRevision As Integer
         Get
-            Return 1
+            Return 23
         End Get
     End Property
-End Class
\ No newline at end of file
+End Class
+#End If
\ No newline at end of file
diff --git a/x8086NetEmu/Adapters/Audio/SoundBlaster.vb b/x8086NetEmu/Adapters/Audio/SoundBlaster.vb
new file mode 100644
index 0000000..8dd80c1
--- /dev/null
+++ b/x8086NetEmu/Adapters/Audio/SoundBlaster.vb
@@ -0,0 +1,339 @@
+ï»¿Imports NAudio.Wave
+
+Public Class SoundBlaster ' Based on fake86's implementation
+    Inherits Adapter
+    Implements IDMADevice
+
+    Private waveOut As WaveOut
+    Private audioProvider As SpeakerAdpater.CustomBufferProvider
+
+    Private ReadOnly mCPU As X8086
+
+    Private Structure BlasterData
+        Public Mem() As Byte
+        Public MemPtr As UInt16
+        Public SampleRate As UInt16
+        Public DspMaj As Byte
+        Public DspMin As Byte
+        Public SpeakerEnabled As Boolean
+        Public LastResetVal As Byte
+        Public LastCmdVal As Byte
+        Public LastTestVal As Byte
+        Public WaitForArg As Byte
+        Public Paused8 As Boolean
+        Public Paused16 As Boolean
+        Public Sample As Byte
+        Public Irq As InterruptRequest
+        Public Dma As Byte
+        Public UsingDma As Boolean
+        Public MaskDma As Byte
+        Public UseAutoInit As Boolean
+        Public BlockSize As UInt32
+        Public BlockStep As UInt32
+        Public SampleTicks As UInt64
+
+        Public Structure Mixer
+            Public Index As Byte
+            Public Reg() As Byte
+        End Structure
+        Dim MixerData As Mixer
+    End Structure
+    Private blaster As BlasterData
+
+    Private mixer(256 - 1) As Byte
+    Private mixerIndex As Byte
+
+    Private dma As DMAI8237.Channel
+
+    Private adLib As AdlibAdapter
+
+    Public Sub New(cpu As X8086, adlib As AdlibAdapter, Optional port As UInt16 = &H220, Optional irq As Byte = 5, Optional dmaChannel As Byte = 1)
+        mCPU = cpu
+        Me.adLib = adlib
+
+        ReDim blaster.Mem(1024 - 1)
+        ReDim blaster.MixerData.Reg(256 - 1)
+
+        blaster.Irq = mCPU.PIC.GetIrqLine(irq)
+        blaster.Dma = dmaChannel
+
+        For i As UInt32 = port To port + &HE
+            ValidPortAddress.Add(i)
+        Next
+    End Sub
+
+    Private Sub SetSampleTicks()
+        If blaster.SampleRate = 0 Then
+            blaster.SampleTicks = 0
+        Else
+            blaster.SampleTicks = mCPU.Clock / blaster.SampleRate
+        End If
+    End Sub
+
+    Private Sub CmdBlaster(value As Byte)
+        Dim recognized As Byte = 1
+        If blaster.WaitForArg <> 0 Then
+            Select Case blaster.LastCmdVal
+                Case &H10 ' direct 8-bit sample output
+                    blaster.Sample = value
+                Case &H14, &H24, &H91 ' 8-bit single block DMA output
+                    If blaster.WaitForArg = 2 Then
+                        blaster.BlockSize = (blaster.BlockSize And &HFF00) Or value
+                        blaster.WaitForArg = 3
+                        Exit Sub
+                    Else
+                        blaster.BlockSize = (blaster.BlockSize And &HFF) Or (CUInt(value) << 8)
+
+                        blaster.UsingDma = True
+                        blaster.BlockStep = 0
+                        blaster.UseAutoInit = False
+                        blaster.Paused8 = False
+                        blaster.SpeakerEnabled = True
+                    End If
+                Case &H40 ' set time constant
+                    blaster.SampleRate = (mCPU.Clock / (256 - value))
+                    SetSampleTicks()
+                Case &H48 ' set DSP block transfer size
+                    If blaster.WaitForArg = 2 Then
+                        blaster.BlockSize = (blaster.BlockSize And &HFF00) Or value
+                        blaster.WaitForArg = 3
+                        Exit Sub
+                    Else
+                        blaster.BlockSize = (blaster.BlockSize And &HFF) Or (CUInt(value) << 8)
+                        blaster.BlockStep = 0
+                    End If
+                Case &HE0 ' DSP identification for Sound Blaster 2.0 and newer (invert each bit and put in read buffer)
+                    BufNewData(Not value)
+                Case &HE4 ' DSP write test, put data value into read buffer
+                    BufNewData(value)
+                    blaster.LastTestVal = value
+                Case Else
+                    recognized = 0
+            End Select
+            If recognized Then Exit Sub
+        End If
+
+        Select Case value
+            Case &H10, &H40, &HE0, &HE4
+                blaster.WaitForArg = 1
+            Case &H14, &H24, &H48, &H91 ' 8-bit single block DMA output
+                blaster.WaitForArg = 2
+            Case &H1C, &H2C ' 8-bit auto-init DMA output
+                blaster.UsingDma = True
+                blaster.BlockStep = 0
+                blaster.UseAutoInit = True
+                blaster.Paused8 = False
+                blaster.SpeakerEnabled = True
+            Case &HD0 ' pause 8-bit DMA I/O
+                blaster.Paused8 = True
+            Case &HD1 ' speaker output on
+                blaster.SpeakerEnabled = True
+            Case &HD3 ' speaker output off
+                blaster.SpeakerEnabled = True
+            Case &HD4 ' continue 8-bit DMA I/O
+                blaster.Paused8 = False
+            Case &HD8 ' get speaker status
+                If blaster.SpeakerEnabled Then
+                    BufNewData(&HFF)
+                Else
+                    BufNewData(&H0)
+                End If
+            Case &HDA ' exit 8-bit auto-init DMA I/O mode
+                blaster.UsingDma = False
+            Case &HE1   ' get DSP version info
+                blaster.MemPtr = 0
+                BufNewData(blaster.DspMaj)
+                BufNewData(blaster.DspMin)
+            Case &HE8 ' DSP read test
+                blaster.MemPtr = 0
+                BufNewData(blaster.LastTestVal)
+            Case &HF2 ' force 8-bit IRQ
+                blaster.Irq.Raise(True)
+            Case &HF8 ' undocumented command, clears in-buffer And inserts a null byte
+                blaster.MemPtr = 0
+                BufNewData(0)
+        End Select
+    End Sub
+
+    Public Overrides Sub InitiAdapter()
+        blaster.DspMaj = 2 ' emulate a Sound Blaster 2.0
+        blaster.DspMin = 0
+        MixerReset()
+
+        dma = mCPU.DMA.GetChannel(blaster.Dma)
+        mCPU.DMA.BindChannel(blaster.Dma, Me)
+
+        waveOut = New WaveOut() With {
+            .NumberOfBuffers = 4,
+            .DesiredLatency = 200
+        }
+        audioProvider = New SpeakerAdpater.CustomBufferProvider(AddressOf FillAudioBuffer, SpeakerAdpater.SampleRate, 8, 1)
+        waveOut.Init(audioProvider)
+        waveOut.Play()
+    End Sub
+
+    Public Overrides Sub CloseAdapter()
+        waveOut.Stop()
+        waveOut.Dispose()
+    End Sub
+
+    Private Function GetBlasterSample() As UInt16
+        TickBlaster()
+        If Not blaster.SpeakerEnabled Then Return 0
+        Return blaster.Sample '- 128
+    End Function
+
+    Private Sub MixerReset()
+        Dim v As Byte = (4 << 5) Or (4 << 1)
+
+        Array.Clear(blaster.MixerData.Reg, 0, blaster.MixerData.Reg.Length)
+
+        blaster.MixerData.Reg(&H4) = v
+        blaster.MixerData.Reg(&H22) = v
+        blaster.MixerData.Reg(&H26) = v
+    End Sub
+
+    Private Sub FillAudioBuffer(buffer() As Byte)
+        For i As Integer = 0 To buffer.Length - 1
+            buffer(i) = GetBlasterSample()
+        Next
+    End Sub
+
+    Private Sub BufNewData(value As Byte)
+        If blaster.MemPtr < blaster.Mem.Length Then
+            blaster.Mem(blaster.MemPtr) = value
+            blaster.MemPtr += 1
+        End If
+    End Sub
+
+    Public Overrides Sub Out(port As UInteger, value As UShort)
+        Select Case port And &HF
+            Case &H0, &H8 : adLib.Out(&H388, value)
+            Case &H1, &H9 : adLib.Out(&H389, value)
+            Case &H4 : mixerIndex = value
+            Case &H5 : mixer(mixerIndex) = value
+            Case &H6 ' reset port
+                If (value = &H0) And (blaster.LastResetVal = &H1) Then
+                    blaster.SpeakerEnabled = False
+                    blaster.Sample = 128
+                    blaster.WaitForArg = 0
+                    blaster.MemPtr = 0
+                    blaster.UsingDma = False
+                    blaster.BlockSize = 65535
+                    blaster.BlockStep = 0
+                    BufNewData(&HAA)
+                    For i As Integer = 0 To mixer.Length - 1 : mixer(i) = &HEE : Next
+                End If
+                blaster.LastResetVal = value
+            Case &HC ' write command/data
+                CmdBlaster(value)
+                If (blaster.WaitForArg <> 3) Then blaster.LastCmdVal = value
+        End Select
+    End Sub
+
+    Public Overrides Function [In](port As UInteger) As UShort
+        Select Case port And &HF
+            Case &H0, &H8 : Return adLib.In(&H388)
+            Case &H1, &H9 : Return adLib.In(&H389)
+            Case &H5 : Return mixer(mixerIndex)
+            Case &HA ' read data
+                If blaster.MemPtr = 0 Then
+                    Return 0
+                Else
+                    Dim r As Byte = blaster.Mem(0)
+                    Array.Copy(blaster.Mem, 0, blaster.Mem, 1, blaster.Mem.Length - 1)
+                    blaster.MemPtr -= 1
+                    Return r
+                End If
+            Case &HE ' read-buffer status
+                If blaster.MemPtr > 0 Then
+                    Return &H80
+                Else
+                    Return &H0
+                End If
+            Case Else : Return &H0
+        End Select
+    End Function
+
+    Private Sub TickBlaster()
+        If Not blaster.UsingDma Then Exit Sub
+        dma.DMARequest(True)
+
+        blaster.BlockStep += 1
+        If blaster.BlockStep > blaster.BlockSize Then
+            blaster.Irq.Raise(True)
+            If blaster.UseAutoInit Then
+                blaster.BlockStep = 0
+            Else
+                blaster.UsingDma = False
+            End If
+        End If
+    End Sub
+
+    Public Sub DMARead(v As Byte) Implements IDMADevice.DMARead
+        If dma.Masked <> 0 Then blaster.Sample = 128
+        If dma.AutoInit <> 0 AndAlso dma.CurrentCount > dma.BaseCount Then dma.CurrentCount = 0
+        If dma.CurrentCount > dma.BaseCount Then blaster.Sample = 128
+
+        If dma.Direction = 0 Then
+            blaster.Sample = mCPU.Memory((dma.Page << 16) + dma.CurrentAddress + dma.CurrentCount)
+        Else
+            blaster.Sample = mCPU.Memory((dma.Page << 16) + dma.CurrentAddress - dma.CurrentCount)
+        End If
+        dma.CurrentCount += 1
+    End Sub
+
+    Public Function DMAWrite() As Byte Implements IDMADevice.DMAWrite
+        Return blaster.Mem(blaster.MemPtr)
+    End Function
+
+    Public Sub DMAEOP() Implements IDMADevice.DMAEOP
+        dma.DMARequest(False)
+    End Sub
+
+    Public Overrides ReadOnly Property Type As AdapterType
+        Get
+            Return AdapterType.AudioDevice
+        End Get
+    End Property
+
+    Public Overrides Sub Run()
+        X8086.Notify($"{Name} Running", X8086.NotificationReasons.Info)
+    End Sub
+
+    Public Overrides ReadOnly Property Vendor As String
+        Get
+            Return "Creative Technology Pte Ltd"
+        End Get
+    End Property
+
+    Public Overrides ReadOnly Property VersionMajor As Integer
+        Get
+            Return 0
+        End Get
+    End Property
+
+    Public Overrides ReadOnly Property VersionMinor As Integer
+        Get
+            Return 0
+        End Get
+    End Property
+
+    Public Overrides ReadOnly Property VersionRevision As Integer
+        Get
+            Return 1
+        End Get
+    End Property
+
+    Public Overrides ReadOnly Property Description As String
+        Get
+            Return "Sound Blaster Pro 2.0"
+        End Get
+    End Property
+
+    Public Overrides ReadOnly Property Name As String
+        Get
+            Return "Sound Blaster Pro 2.0"
+        End Get
+    End Property
+End Class
diff --git a/x8086NetEmu/Adapters/Audio/SpeakerAdapter.vb b/x8086NetEmu/Adapters/Audio/SpeakerAdapter.vb
index adf458c..5e281d4 100644
--- a/x8086NetEmu/Adapters/Audio/SpeakerAdapter.vb
+++ b/x8086NetEmu/Adapters/Audio/SpeakerAdapter.vb
@@ -1,28 +1,27 @@
 ï»¿#If Win32 Then
-Imports System.Runtime.InteropServices
 Imports NAudio.Wave
 
-Public Class CustomBufferProvider
-    Implements IWaveProvider
+Public Class SpeakerAdpater
+    Inherits Adapter
 
-    Public Delegate Sub FillBuffer(buffer() As Byte)
+    Public Class CustomBufferProvider
+        Implements IWaveProvider
 
-    Public ReadOnly Property WaveFormat As WaveFormat Implements IWaveProvider.WaveFormat
-    Private fb As FillBuffer
+        Public Delegate Sub FillBuffer(buffer() As Byte)
 
-    Public Sub New(bufferFiller As FillBuffer, sampleRate As Integer, bitDepth As Integer, channels As Integer)
-        WaveFormat = New WaveFormat(sampleRate, bitDepth, channels)
-        fb = bufferFiller
-    End Sub
+        Public ReadOnly Property WaveFormat As WaveFormat Implements IWaveProvider.WaveFormat
+        Private fb As FillBuffer
 
-    Public Function Read(buffer() As Byte, offset As Integer, count As Integer) As Integer Implements IWaveProvider.Read
-        fb.Invoke(buffer)
-        Return count
-    End Function
-End Class
+        Public Sub New(bufferFiller As FillBuffer, sampleRate As Integer, bitDepth As Integer, channels As Integer)
+            WaveFormat = New WaveFormat(sampleRate, bitDepth, channels)
+            fb = bufferFiller
+        End Sub
 
-Public Class SpeakerAdpater
-    Inherits Adapter
+        Public Function Read(buffer() As Byte, offset As Integer, count As Integer) As Integer Implements IWaveProvider.Read
+            fb.Invoke(buffer)
+            Return count
+        End Function
+    End Class
 
     Private Enum WaveForms
         Squared
@@ -60,8 +59,10 @@ Public Class SpeakerAdpater
             Return mFrequency
         End Get
         Set(value As Double)
-            mFrequency = value
-            UpdateWaveformParameters()
+            If mFrequency <> value Then
+                mFrequency = value
+                UpdateWaveformParameters()
+            End If
         End Set
     End Property
 
@@ -102,7 +103,7 @@ Public Class SpeakerAdpater
                     End If
                 Case WaveForms.Sinusoidal
                     If mEnabled AndAlso waveLength > 0 Then
-                        v = Math.Floor(Math.Sin((currentStep / waveLength) * (mFrequency / 2) * ToRad) * 128)
+                        v = Math.Floor(Math.Sin(currentStep / waveLength * (mFrequency / 2) * ToRad) * 128)
                     Else
                         v = 0
                     End If
@@ -145,11 +146,11 @@ Public Class SpeakerAdpater
         waveOut.Play()
     End Sub
 
-    Public Overrides Function [In](port As UInt32) As UInt32
+    Public Overrides Function [In](port As UInt32) As UInt16
         Return &HFF ' Avoid warning BC42353
     End Function
 
-    Public Overrides Sub Out(port As UInt32, value As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
 
     End Sub
 
@@ -211,11 +212,11 @@ Public Class SpeakerAdpater
         End Get
     End Property
 
-    Public Overrides Function [In](port As UInt32) As UInt32
+    Public Overrides Function [In](port As UInt32) As UInt16
         Return 0
     End Function
 
-    Public Overrides Sub Out(port As UInt32, value As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
 
     End Sub
 
@@ -235,7 +236,7 @@ Public Class SpeakerAdpater
 
     Public Overrides ReadOnly Property Type As Adapter.AdapterType
         Get
-            Return AdapterType.Speaker
+            Return AdapterType.AudioDevice
         End Get
     End Property
 
diff --git a/x8086NetEmu/Adapters/Disk/DiskImage.vb b/x8086NetEmu/Adapters/Disk/DiskImage.vb
index 8079833..72fd228 100644
--- a/x8086NetEmu/Adapters/Disk/DiskImage.vb
+++ b/x8086NetEmu/Adapters/Disk/DiskImage.vb
@@ -37,7 +37,7 @@ Public Class DiskImage
     Protected Friend mSectorSize As UInt16
     Protected Friend mReadOnly As Boolean
     Protected Friend mStatus As ImageStatus = ImageStatus.NoDisk
-    Protected Friend mFileLength As Long
+    Protected Friend mFileLength As ULong
     Protected Friend mIsHardDisk As Boolean
     Protected Friend mFileName As String
     Protected Friend mDriveType As DriveTypes
@@ -247,15 +247,15 @@ Public Class DiskImage
         Return True
     End Function
 
-    Public Function LBA(cylinder As UInt16, head As UInt16, sector As UInt16) As Long
+    Public Function LBA(cylinder As UInt16, head As UInt16, sector As UInt16) As ULong
         If mStatus <> ImageStatus.DiskLoaded Then Return -1
 
         cylinder = cylinder Or ((sector And &HC0) << 2)
         sector = sector And &H3F
 
-        If cylinder >= mCylinders OrElse sector < 1 OrElse sector > mSectors OrElse head > mHeads Then Return -1
+        If cylinder >= mCylinders OrElse sector = 0 OrElse sector > mSectors OrElse head >= mHeads Then Return -1
 
-        Return (((cylinder * mHeads) + head) * mSectors + sector - 1) * mSectorSize
+        Return (((CUInt(cylinder) * mHeads) + head) * mSectors + sector - 1) * mSectorSize
     End Function
 
     Public Sub Close()
@@ -267,13 +267,13 @@ Public Class DiskImage
         End Try
     End Sub
 
-    Public ReadOnly Property FileLength() As Long
+    Public ReadOnly Property FileLength() As ULong
         Get
             Return mFileLength
         End Get
     End Property
 
-    Public Overridable Function Read(offset As Long, data() As Byte) As Integer
+    Public Overridable Function Read(offset As ULong, data() As Byte) As Integer
         If mStatus <> ImageStatus.DiskLoaded Then Return -1
 
         If offset < 0 OrElse offset + data.Length > mFileLength Then Return EOF
@@ -288,7 +288,7 @@ Public Class DiskImage
         End Try
     End Function
 
-    Public Overridable Function Write(offset As Long, data() As Byte) As Integer
+    Public Overridable Function Write(offset As ULong, data() As Byte) As Integer
         If mStatus <> ImageStatus.DiskLoaded Then Return -1
 
         If offset < 0 OrElse offset + data.Length > mFileLength Then Return EOF
diff --git a/x8086NetEmu/Adapters/Disk/FileSystem/FAT12_16.vb b/x8086NetEmu/Adapters/Disk/FileSystem/FAT12_16.vb
deleted file mode 100644
index c46c369..0000000
--- a/x8086NetEmu/Adapters/Disk/FileSystem/FAT12_16.vb
+++ /dev/null
@@ -1,160 +0,0 @@
-ï»¿Imports System.Runtime.InteropServices
-
-Public Class FAT12_16
-    Public Enum EntryAttributes As Byte
-        [ReadOnly] = CInt(2 ^ 0)
-        Hidden = CInt(2 ^ 1)
-        System = CInt(2 ^ 2)
-        VolumeName = CInt(2 ^ 3)
-        Directory = CInt(2 ^ 4)
-        ArchiveFlag = CInt(2 ^ 5)
-    End Enum
-
-    <StructLayout(LayoutKind.Sequential, Pack:=1)>
-    Public Structure ParameterBlock
-        Public BytesPerSector As UInt16
-        Public SectorsPerCluster As Byte
-        Public ReservedSectors As UInt16
-        Public NumberOfFATCopies As Byte
-        Public RootEntries As UInt16
-        Public TotalSectors As UInt16
-        Public MediaDescriptor As Byte
-        Public SectorsPerFAT As UInt16
-        Public SectorsPerTrack As UInt16
-        Public HeadsPerCylinder As UInt16
-        Public HiddenSectors As UInt32
-        Public TotalSectorsBig As UInt32
-    End Structure
-
-    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
-    Public Structure ExtendedParameterBlock
-        Public ExtendedBootSignature As Byte
-        Public SerialNumber As UInt32
-        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=11)> Private VolumeLabelChars() As Byte
-        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Private FileSystemTypeChars() As Byte
-
-        Public ReadOnly Property VolumeLabel As String
-            Get
-                Return Text.Encoding.ASCII.GetString(VolumeLabelChars).TrimEnd()
-            End Get
-        End Property
-
-        Public ReadOnly Property FileSystemType As String
-            Get
-                Return Text.Encoding.ASCII.GetString(FileSystemTypeChars).TrimEnd()
-            End Get
-        End Property
-    End Structure
-
-    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
-    Public Structure DirectoryEntry
-        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Public FileNameChars() As Byte
-        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=3)> Private FileExtensionChars() As Byte
-        Public Attribute As EntryAttributes
-        Public ReservedNT As Byte
-        Public Creation As Byte
-        Public CreationTime As UInt16
-        Public CreationDate As UInt16
-        Public LastAccessDate As UInt16
-        Public ReservedFAT32 As UInt16
-        Public LastWriteTime As UInt16
-        Public LastWriteDate As UInt16
-        Public StartingCluster As UInt16
-        Public FileSize As UInt32
-
-        Public ReadOnly Property FileName As String
-            Get
-                Return Text.Encoding.ASCII.GetString(FileNameChars).TrimEnd()
-            End Get
-        End Property
-
-        Public ReadOnly Property FileExtension As String
-            Get
-                Return Text.Encoding.ASCII.GetString(FileExtensionChars).TrimEnd()
-            End Get
-        End Property
-
-        Public ReadOnly Property FullFileName As String
-            Get
-                Dim fn As String = FileName.TrimEnd()
-                Dim fe As String = FileExtension.TrimEnd()
-                If fe <> "" Then fe = "." + fe
-
-                Return fn + fe
-            End Get
-        End Property
-
-        Public ReadOnly Property CreationDateTime As DateTime
-            Get
-                Dim t() As Integer = FSTimeToNative(CreationTime)
-                Dim d() As Integer = FSDateToNative(CreationTime)
-                Return New DateTime(d(2), d(1), d(0), t(2), t(1), t(0))
-            End Get
-        End Property
-
-        Public ReadOnly Property WriteDateTime As DateTime
-            Get
-                Dim t() As Integer = FSTimeToNative(LastWriteTime)
-                Dim d() As Integer = FSDateToNative(LastWriteDate)
-                Try
-                    Return New DateTime(d(0), d(1), d(2), t(0), t(1), t(2))
-                Catch
-                    Return New DateTime(1980, 1, 1, 0, 0, 0)
-                End Try
-            End Get
-        End Property
-
-        Private Function FSTimeToNative(v As UInt16) As Integer()
-            Dim s As Integer = (v And &H1F) * 2
-            Dim m As Integer = (v And &H3E0) >> 5
-            Dim h As Integer = (v And &HF800) >> 11
-            Return {h, m, s}
-        End Function
-
-        Private Function FSDateToNative(v As UInt16) As Integer()
-            Dim d As Integer = (v And &H1F)
-            Dim m As Integer = (v And &H1E0) >> 5
-            Dim y As Integer = ((v And &HFE00) >> 9) + 1980
-            Return {y, m, d}
-        End Function
-
-        Public Shadows Function ToString() As String
-            Dim attrs() As String = [Enum].GetNames(GetType(EntryAttributes))
-            Dim attr As String = ""
-            For i As Integer = 0 To attrs.Length - 1
-                If ((2 ^ i) And Attribute) <> 0 Then
-                    attr += attrs(i) + " "
-                End If
-            Next
-            attr = attr.TrimEnd()
-
-            Return $"{FullFileName} [{attr}]"
-        End Function
-
-        Public Shared Operator =(d1 As DirectoryEntry, d2 As DirectoryEntry) As Boolean
-            Return d1.Attribute = d2.Attribute AndAlso d1.StartingCluster = d2.StartingCluster
-        End Operator
-
-        Public Shared Operator <>(d1 As DirectoryEntry, d2 As DirectoryEntry) As Boolean
-            Return Not (d1 = d2)
-        End Operator
-    End Structure
-
-    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
-    Public Structure BootSector
-        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=3)> Public JumpCode() As Byte
-        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Private OemIdChars() As Byte
-        <MarshalAs(UnmanagedType.Struct)> Public BIOSParameterBlock As ParameterBlock
-        Public DriveNumber As Byte
-        Public Reserved As Byte
-        <MarshalAs(UnmanagedType.Struct)> Public ExtendedBIOSParameterBlock As ExtendedParameterBlock
-        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=448)> Public BootStrapCode() As Byte
-        Public Signature As UInt16
-
-        Public ReadOnly Property OemId As String
-            Get
-                Return Text.Encoding.ASCII.GetString(OemIdChars).TrimEnd()
-            End Get
-        End Property
-    End Structure
-End Class
diff --git a/x8086NetEmu/Adapters/Disk/FileSystem/FileSystemStructs.vb b/x8086NetEmu/Adapters/Disk/FileSystem/FileSystemStructs.vb
new file mode 100644
index 0000000..f1c2c82
--- /dev/null
+++ b/x8086NetEmu/Adapters/Disk/FileSystem/FileSystemStructs.vb
@@ -0,0 +1,484 @@
+ï»¿Imports System.Runtime.InteropServices
+
+Public Structure FAT12
+    Public Enum EntryAttributes As Byte
+        [ReadOnly] = 2 ^ 0
+        Hidden = 2 ^ 1
+        System = 2 ^ 2
+        VolumeName = 2 ^ 3
+        Directory = 2 ^ 4
+        ArchiveFlag = 2 ^ 5
+    End Enum
+
+    <StructLayout(LayoutKind.Sequential, Pack:=1)>
+    Public Structure ParameterBlock
+        Public BytesPerSector As UInt16
+        Public SectorsPerCluster As Byte
+        Public ReservedSectors As UInt16
+        Public NumberOfFATCopies As Byte
+        Public RootEntries As UInt16
+        Public TotalSectors As UInt16
+        Public MediaDescriptor As Byte
+        Public SectorsPerFAT As UInt16
+        Public SectorsPerTrack As UInt16
+        Public HeadsPerCylinder As UInt16
+        Public HiddenSectors As UInt32
+        Public TotalSectorsBig As UInt32
+    End Structure
+
+    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
+    Public Structure ExtendedParameterBlock
+        Public DriveNumber As Byte
+        Public Reserved As Byte
+        Public ExtendedBootSignature As Byte
+        Public SerialNumber As UInt32
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=11)> Private ReadOnly VolumeLabelChars() As Byte
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Private ReadOnly FileSystemTypeChars() As Byte
+
+        Public ReadOnly Property VolumeLabel As String
+            Get
+                Return Text.Encoding.ASCII.GetString(VolumeLabelChars).TrimEnd()
+            End Get
+        End Property
+
+        Public ReadOnly Property FileSystemType As String
+            Get
+                Return Text.Encoding.ASCII.GetString(FileSystemTypeChars).TrimEnd()
+            End Get
+        End Property
+    End Structure
+
+    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
+    Public Structure DirectoryEntry
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Public FileNameChars() As Byte
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=3)> Private ReadOnly FileExtensionChars() As Byte
+        Public Attribute As EntryAttributes
+        Public ReservedNT As Byte
+        Public Creation As Byte
+        Public CreationTime As UInt16
+        Public CreationDate As UInt16
+        Public LastAccessDate As UInt16
+        Public ReservedFAT32 As UInt16
+        Public LastWriteTime As UInt16
+        Public LastWriteDate As UInt16
+        Public StartingCluster As UInt16
+        Public FileSize As UInt32
+
+        Public ReadOnly Property FileName As String
+            Get
+                Return Text.Encoding.ASCII.GetString(FileNameChars).TrimEnd()
+            End Get
+        End Property
+
+        Public ReadOnly Property FileExtension As String
+            Get
+                Return Text.Encoding.ASCII.GetString(FileExtensionChars).TrimEnd()
+            End Get
+        End Property
+
+        Public ReadOnly Property FullFileName As String
+            Get
+                Dim fn As String = FileName.TrimEnd()
+                Dim fe As String = FileExtension.TrimEnd()
+                If fe <> "" Then fe = "." + fe
+
+                Return fn + fe
+            End Get
+        End Property
+
+        Public ReadOnly Property CreationDateTime As DateTime
+            Get
+                Dim t() As Integer = FSTimeToNative(CreationTime)
+                Dim d() As Integer = FSDateToNative(CreationTime)
+                Return New DateTime(d(2), d(1), d(0), t(2), t(1), t(0))
+            End Get
+        End Property
+
+        Public ReadOnly Property WriteDateTime As DateTime
+            Get
+                Dim t() As Integer = FSTimeToNative(LastWriteTime)
+                Dim d() As Integer = FSDateToNative(LastWriteDate)
+                Try
+                    Return New DateTime(d(0), d(1), d(2), t(0), t(1), t(2))
+                Catch
+                    Return New DateTime(1980, 1, 1, 0, 0, 0)
+                End Try
+            End Get
+        End Property
+
+        Private Function FSTimeToNative(v As UInt16) As Integer()
+            Dim s As Integer = (v And &H1F) * 2
+            Dim m As Integer = (v And &H3E0) >> 5
+            Dim h As Integer = (v And &HF800) >> 11
+            Return {h, m, s}
+        End Function
+
+        Private Function FSDateToNative(v As UInt16) As Integer()
+            Dim d As Integer = v And &H1F
+            Dim m As Integer = (v And &H1E0) >> 5
+            Dim y As Integer = ((v And &HFE00) >> 9) + 1980
+            Return {y, m, d}
+        End Function
+
+        Public Shadows Function ToString() As String
+            Dim attrs() As String = [Enum].GetNames(GetType(EntryAttributes))
+            Dim attr As String = ""
+            For i As Integer = 0 To attrs.Length - 1
+                If ((2 ^ i) And Attribute) <> 0 Then
+                    attr += attrs(i) + " "
+                End If
+            Next
+            attr = attr.TrimEnd()
+
+            Return $"{FullFileName} [{attr}]"
+        End Function
+
+        Public Shared Operator =(d1 As DirectoryEntry, d2 As DirectoryEntry) As Boolean
+            Return d1.Attribute = d2.Attribute AndAlso d1.StartingCluster = d2.StartingCluster
+        End Operator
+
+        Public Shared Operator <>(d1 As DirectoryEntry, d2 As DirectoryEntry) As Boolean
+            Return Not d1 = d2
+        End Operator
+    End Structure
+
+    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
+    Public Structure BootSector
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=3)> Public JumpCode() As Byte
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Private ReadOnly OemIdChars() As Byte
+        <MarshalAs(UnmanagedType.Struct)> Public BIOSParameterBlock As ParameterBlock
+        <MarshalAs(UnmanagedType.Struct)> Public ExtendedBIOSParameterBlock As ExtendedParameterBlock
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=448)> Public BootStrapCode() As Byte
+        Public Signature As UInt16
+
+        Public ReadOnly Property OemId As String
+            Get
+                Return Text.Encoding.ASCII.GetString(OemIdChars).TrimEnd()
+            End Get
+        End Property
+    End Structure
+End Structure
+
+Public Structure FAT16
+    Public Enum EntryAttributes As Byte
+        [ReadOnly] = 2 ^ 0
+        Hidden = 2 ^ 1
+        System = 2 ^ 2
+        VolumeName = 2 ^ 3
+        Directory = 2 ^ 4
+        ArchiveFlag = 2 ^ 5
+    End Enum
+
+    <StructLayout(LayoutKind.Sequential, Pack:=1)>
+    Public Structure ParameterBlock
+        Public BytesPerSector As UInt16
+        Public SectorsPerCluster As Byte
+        Public ReservedSectors As UInt16
+        Public NumberOfFATCopies As Byte
+        Public RootEntries As UInt16
+        Public TotalSectors As UInt16
+        Public MediaDescriptor As Byte
+        Public SectorsPerFAT As UInt16
+        Public SectorsPerTrack As UInt16
+        Public HeadsPerCylinder As UInt16
+        Public HiddenSectors As UInt32
+        Public TotalSectorsBig As UInt32
+    End Structure
+
+    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
+    Public Structure ExtendedParameterBlock
+        Public DriveNumber As Byte
+        Public Reserved As Byte
+        Public ExtendedBootSignature As Byte
+        Public SerialNumber As UInt32
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=11)> Private ReadOnly VolumeLabelChars() As Byte
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Private ReadOnly FileSystemTypeChars() As Byte
+
+        Public ReadOnly Property VolumeLabel As String
+            Get
+                Return Text.Encoding.ASCII.GetString(VolumeLabelChars).TrimEnd()
+            End Get
+        End Property
+
+        Public ReadOnly Property FileSystemType As String
+            Get
+                Return Text.Encoding.ASCII.GetString(FileSystemTypeChars).TrimEnd()
+            End Get
+        End Property
+    End Structure
+
+    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
+    Public Structure DirectoryEntry
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Public FileNameChars() As Byte
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=3)> Private ReadOnly FileExtensionChars() As Byte
+        Public Attribute As EntryAttributes
+        Public ReservedNT As Byte
+        Public Creation As Byte
+        Public CreationTime As UInt16
+        Public CreationDate As UInt16
+        Public LastAccessDate As UInt16
+        Public ReservedFAT32 As UInt16
+        Public LastWriteTime As UInt16
+        Public LastWriteDate As UInt16
+        Public StartingCluster As UInt16
+        Public FileSize As UInt32
+
+        Public ReadOnly Property FileName As String
+            Get
+                Return Text.Encoding.ASCII.GetString(FileNameChars).TrimEnd()
+            End Get
+        End Property
+
+        Public ReadOnly Property FileExtension As String
+            Get
+                Return Text.Encoding.ASCII.GetString(FileExtensionChars).TrimEnd()
+            End Get
+        End Property
+
+        Public ReadOnly Property FullFileName As String
+            Get
+                Dim fn As String = FileName.TrimEnd()
+                Dim fe As String = FileExtension.TrimEnd()
+                If fe <> "" Then fe = "." + fe
+
+                Return fn + fe
+            End Get
+        End Property
+
+        Public ReadOnly Property CreationDateTime As DateTime
+            Get
+                Dim t() As Integer = FSTimeToNative(CreationTime)
+                Dim d() As Integer = FSDateToNative(CreationTime)
+                Return New DateTime(d(2), d(1), d(0), t(2), t(1), t(0))
+            End Get
+        End Property
+
+        Public ReadOnly Property WriteDateTime As DateTime
+            Get
+                Dim t() As Integer = FSTimeToNative(LastWriteTime)
+                Dim d() As Integer = FSDateToNative(LastWriteDate)
+                Try
+                    Return New DateTime(d(0), d(1), d(2), t(0), t(1), t(2))
+                Catch
+                    Return New DateTime(1980, 1, 1, 0, 0, 0)
+                End Try
+            End Get
+        End Property
+
+        Private Function FSTimeToNative(v As UInt16) As Integer()
+            Dim s As Integer = (v And &H1F) * 2
+            Dim m As Integer = (v And &H3E0) >> 5
+            Dim h As Integer = (v And &HF800) >> 11
+            Return {h, m, s}
+        End Function
+
+        Private Function FSDateToNative(v As UInt16) As Integer()
+            Dim d As Integer = v And &H1F
+            Dim m As Integer = (v And &H1E0) >> 5
+            Dim y As Integer = ((v And &HFE00) >> 9) + 1980
+            Return {y, m, d}
+        End Function
+
+        Public Shadows Function ToString() As String
+            Dim attrs() As String = [Enum].GetNames(GetType(EntryAttributes))
+            Dim attr As String = ""
+            For i As Integer = 0 To attrs.Length - 1
+                If ((2 ^ i) And Attribute) <> 0 Then
+                    attr += attrs(i) + " "
+                End If
+            Next
+            attr = attr.TrimEnd()
+
+            Return $"{FullFileName} [{attr}]"
+        End Function
+
+        Public Shared Operator =(d1 As DirectoryEntry, d2 As DirectoryEntry) As Boolean
+            Return d1.Attribute = d2.Attribute AndAlso d1.StartingCluster = d2.StartingCluster
+        End Operator
+
+        Public Shared Operator <>(d1 As DirectoryEntry, d2 As DirectoryEntry) As Boolean
+            Return Not d1 = d2
+        End Operator
+    End Structure
+
+    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
+    Public Structure BootSector
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=3)> Public JumpCode() As Byte
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Private ReadOnly OemIdChars() As Byte
+        <MarshalAs(UnmanagedType.Struct)> Public BIOSParameterBlock As ParameterBlock
+        <MarshalAs(UnmanagedType.Struct)> Public ExtendedBIOSParameterBlock As ExtendedParameterBlock
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=448)> Public BootStrapCode() As Byte
+        Public Signature As UInt16
+
+        Public ReadOnly Property OemId As String
+            Get
+                Return Text.Encoding.ASCII.GetString(OemIdChars).TrimEnd()
+            End Get
+        End Property
+    End Structure
+End Structure
+
+Public Structure FAT32
+    Public Enum EntryAttributes As Byte
+        [ReadOnly] = 2 ^ 0
+        Hidden = 2 ^ 1
+        System = 2 ^ 2
+        VolumeName = 2 ^ 3
+        Directory = 2 ^ 4
+        ArchiveFlag = 2 ^ 5
+    End Enum
+
+    <StructLayout(LayoutKind.Sequential, Pack:=1)>
+    Public Structure ParameterBlock
+        Public BytesPerSector As UInt16
+        Public SectorsPerCluster As Byte
+        Public ReservedSectors As UInt16
+        Public NumberOfFATCopies As Byte
+        Public RootEntries As UInt16
+        Public TotalSectors As UInt16
+        Public MediaDescriptor As Byte
+        Public NotUsed As UInt16
+        Public SectorsPerTrack As UInt16
+        Public HeadsPerCylinder As UInt16
+        Public HiddenSectors As UInt32
+        Public TotalSectorsBig As UInt32
+        Public SectorsPerFAT As UInt32
+        Public FATHandlingFlags As UInt16
+        Public DriveVersion As UInt16
+        Public ClusterFSIS As UInt32
+        Public SectorBBS As UInt16
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=12)> Private Reserved() As Byte
+    End Structure
+
+    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
+    Public Structure ExtendedParameterBlock
+        Public DriveNumber As Byte
+        Public CurrentHead As Byte
+        Public ExtendedBootSignature As Byte
+        Public SerialNumber As UInt32
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=11)> Private ReadOnly VolumeLabelChars() As Byte
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Private ReadOnly FileSystemTypeChars() As Byte
+
+        Public ReadOnly Property VolumeLabel As String
+            Get
+                Return Text.Encoding.ASCII.GetString(VolumeLabelChars).TrimEnd()
+            End Get
+        End Property
+
+        Public ReadOnly Property FileSystemType As String
+            Get
+                Return Text.Encoding.ASCII.GetString(FileSystemTypeChars).TrimEnd()
+            End Get
+        End Property
+    End Structure
+
+    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
+    Public Structure DirectoryEntry
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Public FileNameChars() As Byte
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=3)> Private ReadOnly FileExtensionChars() As Byte
+        Public Attribute As EntryAttributes
+        Public ReservedNT As Byte
+        Public Creation As Byte
+        Public CreationTime As UInt16
+        Public CreationDate As UInt16
+        Public LastAccessDate As UInt16
+        Public ReservedFAT32 As UInt16
+        Public LastWriteTime As UInt16
+        Public LastWriteDate As UInt16
+        Public StartingCluster As UInt16
+        Public FileSize As UInt32
+
+        Public ReadOnly Property FileName As String
+            Get
+                Return Text.Encoding.ASCII.GetString(FileNameChars).TrimEnd()
+            End Get
+        End Property
+
+        Public ReadOnly Property FileExtension As String
+            Get
+                Return Text.Encoding.ASCII.GetString(FileExtensionChars).TrimEnd()
+            End Get
+        End Property
+
+        Public ReadOnly Property FullFileName As String
+            Get
+                Dim fn As String = FileName.TrimEnd()
+                Dim fe As String = FileExtension.TrimEnd()
+                If fe <> "" Then fe = "." + fe
+
+                Return fn + fe
+            End Get
+        End Property
+
+        Public ReadOnly Property CreationDateTime As DateTime
+            Get
+                Dim t() As Integer = FSTimeToNative(CreationTime)
+                Dim d() As Integer = FSDateToNative(CreationTime)
+                Return New DateTime(d(2), d(1), d(0), t(2), t(1), t(0))
+            End Get
+        End Property
+
+        Public ReadOnly Property WriteDateTime As DateTime
+            Get
+                Dim t() As Integer = FSTimeToNative(LastWriteTime)
+                Dim d() As Integer = FSDateToNative(LastWriteDate)
+                Try
+                    Return New DateTime(d(0), d(1), d(2), t(0), t(1), t(2))
+                Catch
+                    Return New DateTime(1980, 1, 1, 0, 0, 0)
+                End Try
+            End Get
+        End Property
+
+        Private Function FSTimeToNative(v As UInt16) As Integer()
+            Dim s As Integer = (v And &H1F) * 2
+            Dim m As Integer = (v And &H3E0) >> 5
+            Dim h As Integer = (v And &HF800) >> 11
+            Return {h, m, s}
+        End Function
+
+        Private Function FSDateToNative(v As UInt16) As Integer()
+            Dim d As Integer = v And &H1F
+            Dim m As Integer = (v And &H1E0) >> 5
+            Dim y As Integer = ((v And &HFE00) >> 9) + 1980
+            Return {y, m, d}
+        End Function
+
+        Public Shadows Function ToString() As String
+            Dim attrs() As String = [Enum].GetNames(GetType(EntryAttributes))
+            Dim attr As String = ""
+            For i As Integer = 0 To attrs.Length - 1
+                If ((2 ^ i) And Attribute) <> 0 Then
+                    attr += attrs(i) + " "
+                End If
+            Next
+            attr = attr.TrimEnd()
+
+            Return $"{FullFileName} [{attr}]"
+        End Function
+
+        Public Shared Operator =(d1 As DirectoryEntry, d2 As DirectoryEntry) As Boolean
+            Return d1.Attribute = d2.Attribute AndAlso d1.StartingCluster = d2.StartingCluster
+        End Operator
+
+        Public Shared Operator <>(d1 As DirectoryEntry, d2 As DirectoryEntry) As Boolean
+            Return Not d1 = d2
+        End Operator
+    End Structure
+
+    <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Ansi, Pack:=1)>
+    Public Structure BootSector
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=3)> Public JumpCode() As Byte
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=8)> Private ReadOnly OemIdChars() As Byte
+        <MarshalAs(UnmanagedType.Struct)> Public BIOSParameterBlock As ParameterBlock
+        <MarshalAs(UnmanagedType.Struct)> Public ExtendedBIOSParameterBlock As ExtendedParameterBlock
+        <MarshalAs(UnmanagedType.ByValArray, SizeConst:=448)> Public BootStrapCode() As Byte
+        Public Signature As UInt16
+
+        Public ReadOnly Property OemId As String
+            Get
+                Return Text.Encoding.ASCII.GetString(OemIdChars).TrimEnd()
+            End Get
+        End Property
+    End Structure
+End Structure
\ No newline at end of file
diff --git a/x8086NetEmu/Adapters/Disk/FileSystem/HostFolderAsDisk.vb b/x8086NetEmu/Adapters/Disk/FileSystem/HostFolderAsDisk.vb
index cbcc9eb..22be463 100644
--- a/x8086NetEmu/Adapters/Disk/FileSystem/HostFolderAsDisk.vb
+++ b/x8086NetEmu/Adapters/Disk/FileSystem/HostFolderAsDisk.vb
@@ -31,7 +31,7 @@ Public Class HostFolderAsDisk
         X8086.Notify("DiskImage '{0}': {1}", X8086.NotificationReasons.Info, mFileName, mStatus.ToString())
     End Sub
 
-    Public Overrides Function Read(offset As Long, data() As Byte) As Integer
+    Public Overrides Function Read(offset As ULong, data() As Byte) As Integer
         If mStatus <> ImageStatus.DiskLoaded Then Return -1
 
         If offset < 0 OrElse offset + data.Length > mFileLength Then Return EOF
@@ -46,7 +46,7 @@ Public Class HostFolderAsDisk
         End Try
     End Function
 
-    Public Overrides Function Write(offset As Long, data() As Byte) As Integer
+    Public Overrides Function Write(offset As ULong, data() As Byte) As Integer
         'If mStatus <> ImageStatus.DiskLoaded Then Return -1
 
         'If offset < 0 OrElse offset + data.Length > mFileLength Then Return EOF
diff --git a/x8086NetEmu/Adapters/Disk/FileSystem/StandardDiskFormat.vb b/x8086NetEmu/Adapters/Disk/FileSystem/StandardDiskFormat.vb
index e5bbbfb..bb235d6 100644
--- a/x8086NetEmu/Adapters/Disk/FileSystem/StandardDiskFormat.vb
+++ b/x8086NetEmu/Adapters/Disk/FileSystem/StandardDiskFormat.vb
@@ -2,6 +2,7 @@
 
 ' http://www.maverick-os.dk/Mainmenu_NoFrames.html
 ' http://www.patersontech.com/dos/byte%E2%80%93inside-look.aspx
+' https://506889e3-a-62cb3a1a-s-sites.googlegroups.com/site/pcdosretro/fatgen.pdf?attachauth=ANoY7cr_oPcwxUv1I3jB9eaDf2z368nLQUQBc6_zKTfZw8FAs47xAK7Mf3btR_bQEpE5UwDLFgDJrTMovoZOrlC4Eg2qMn935KsT6IAvl5GxhoO_fqmzH7lcAY-7u9y-pbrUKVweCor3XkJPcSg1p-c7COBrRPjHhCgmAIJz1KCZ0iDBzxeE-pGWJ7gbj9-51DovkOLBzmYEcdJVH8xGIwGR_qufNhUuvQ%3D%3D&attredirects=0
 
 Public Class StandardDiskFormat
     Private geometryTable(,) As Integer = {
@@ -88,16 +89,22 @@ Public Class StandardDiskFormat
     Public Structure MBR
         <MarshalAs(UnmanagedType.ByValArray, SizeConst:=446)> Public BootCode() As Byte
         <MarshalAs(UnmanagedType.ByValArray, ArraySubType:=UnmanagedType.Struct, SizeConst:=4)> Public Partitions() As Partition
-        Public Signature As UInt16 ' AA55 = bootable
+        Public Signature As UInt16
+
+        Public ReadOnly Property IsBootable As Boolean
+            Get
+                Return Signature = &HAA55
+            End Get
+        End Property
     End Structure
 
     Private mMasterBootRecord As MBR
-    Private mBootSectors(4 - 1) As FAT12_16.BootSector ' FIXME: In case we wanted to support additional file systems we should use an inheritable class instead of hard coding it to FAT12/16
-    Private mFATDataPointers(4 - 1)() As UInt16
-    Private mRootDirectoryEntries(4 - 1)() As FAT12_16.DirectoryEntry
+    Private ReadOnly mBootSectors(4 - 1) As FAT12.BootSector
+    Private ReadOnly mFATDataPointers(4 - 1)() As UInt16
+    Private ReadOnly mRootDirectoryEntries(4 - 1)() As FAT12.DirectoryEntry
 
     Private strm As IO.Stream
-    Private fatRegionStart(4 - 1) As Long
+    Private ReadOnly fatRegionStart(4 - 1) As Long
 
     Public Sub New(s As IO.Stream)
         Dim pb As GCHandle
@@ -106,12 +113,12 @@ Public Class StandardDiskFormat
         strm = s
 
         ' Assume Floppy Image (No partitions)
-        ' FIXME: There has to be a better way to know is the image is a floppy or a hard disk
+        ' FIXME: There has to be a better way to know if the image is a floppy or a hard disk
         '        Perhaps some better way to detect if the image has a master boot record or something...
         strm.Position = 0
         strm.Read(b, 0, b.Length)
         pb = GCHandle.Alloc(b, GCHandleType.Pinned)
-        Dim bs As FAT12_16.BootSector = Marshal.PtrToStructure(pb.AddrOfPinnedObject(), GetType(FAT12_16.BootSector))
+        Dim bs As FAT12.BootSector = Marshal.PtrToStructure(pb.AddrOfPinnedObject(), GetType(FAT12.BootSector))
         pb.Free()
         If bs.BIOSParameterBlock.BytesPerSector = 512 Then
             LoadAsFloppyImage()
@@ -127,21 +134,23 @@ Public Class StandardDiskFormat
         strm.Position = 0
 
         ReDim mMasterBootRecord.Partitions(0)
-        mMasterBootRecord.Partitions(0) = New Partition()
-        mMasterBootRecord.Partitions(0).BootIndicator = BootIndicators.SystemPartition
+        mMasterBootRecord.Partitions(0) = New Partition With {.BootIndicator = BootIndicators.SystemPartition}
 
         For i As Integer = 0 To geometryTable.Length / 4 - 1
             If strm.Length = geometryTable(i, 3) Then
-                mMasterBootRecord.Partitions(0).EndingSectorCylinder = ((geometryTable(i, 0) And &H3FC) << 8) Or ((geometryTable(i, 0) And &H3) << 6) Or
+                mMasterBootRecord.Partitions(0).EndingSectorCylinder = ((geometryTable(i, 0) And &H3FC) << 8) Or
+                                                                       ((geometryTable(i, 0) And &H3) << 6) Or
                                                                         geometryTable(i, 2)
                 mMasterBootRecord.Partitions(0).EndingHead = geometryTable(i, 1)
+                Exit For
             End If
         Next
 
         strm.Position = 0
         strm.Read(b, 0, b.Length)
+
         pb = GCHandle.Alloc(b, GCHandleType.Pinned)
-        mBootSectors(0) = Marshal.PtrToStructure(pb.AddrOfPinnedObject(), GetType(FAT12_16.BootSector))
+        mBootSectors(0) = Marshal.PtrToStructure(pb.AddrOfPinnedObject(), GetType(FAT12.BootSector))
         pb.Free()
 
         Select Case mBootSectors(0).ExtendedBIOSParameterBlock.FileSystemType
@@ -166,22 +175,23 @@ Public Class StandardDiskFormat
         pb.Free()
 
         For partitionNumber As Integer = 0 To 4 - 1
-            If mMasterBootRecord.Partitions(partitionNumber).SystemId = StandardDiskFormat.SystemIds.FAT_12 OrElse mMasterBootRecord.Partitions(partitionNumber).SystemId = StandardDiskFormat.SystemIds.FAT_16 Then
-                strm.Position = mMasterBootRecord.Partitions(partitionNumber).RelativeSector * 512
-                strm.Read(b, 0, b.Length)
-                pb = GCHandle.Alloc(b, GCHandleType.Pinned)
-                mBootSectors(partitionNumber) = Marshal.PtrToStructure(pb.AddrOfPinnedObject(), GetType(FAT12_16.BootSector))
-                pb.Free()
-
-                ReadFAT(partitionNumber)
-            End If
+            Select Case mMasterBootRecord.Partitions(partitionNumber).SystemId
+                Case StandardDiskFormat.SystemIds.FAT_12, StandardDiskFormat.SystemIds.FAT_16, StandardDiskFormat.SystemIds.FAT_BIGDOS
+                    strm.Position = mMasterBootRecord.Partitions(partitionNumber).RelativeSector * 512
+                    strm.Read(b, 0, b.Length)
+                    pb = GCHandle.Alloc(b, GCHandleType.Pinned)
+                    mBootSectors(partitionNumber) = Marshal.PtrToStructure(pb.AddrOfPinnedObject(), GetType(FAT12.BootSector))
+                    pb.Free()
+
+                    ReadFAT(partitionNumber)
+            End Select
         Next
     End Sub
 
     Private Sub ReadFAT(partitionNumber As Integer)
         fatRegionStart(partitionNumber) = strm.Position
 
-        ReDim mFATDataPointers(partitionNumber)(mBootSectors(partitionNumber).BIOSParameterBlock.SectorsPerFAT * mBootSectors(partitionNumber).BIOSParameterBlock.BytesPerSector / 2 - 1)
+        ReDim mFATDataPointers(partitionNumber)(CInt(mBootSectors(partitionNumber).BIOSParameterBlock.SectorsPerFAT) * mBootSectors(partitionNumber).BIOSParameterBlock.BytesPerSector / 2 - 1)
         For j As Integer = 0 To mFATDataPointers(partitionNumber).Length - 1
             Select Case mBootSectors(partitionNumber).ExtendedBIOSParameterBlock.FileSystemType
                 Case "FAT12" ' FIXME: FAT cluster chain is not correctly built when the file system if FAT12
@@ -198,14 +208,14 @@ Public Class StandardDiskFormat
         End If
     End Sub
 
-    Public Function GetDirectoryEntries(partitionNumber As Integer, Optional clusterIndex As Integer = -1) As FAT12_16.DirectoryEntry()
+    Public Function GetDirectoryEntries(partitionNumber As Integer, Optional clusterIndex As Integer = -1) As FAT12.DirectoryEntry()
         Dim bytesInCluster As UInt16 = mBootSectors(partitionNumber).BIOSParameterBlock.SectorsPerCluster * mBootSectors(partitionNumber).BIOSParameterBlock.BytesPerSector
         Dim pb As GCHandle
-        Dim des() As FAT12_16.DirectoryEntry = Nothing
+        Dim des() As FAT12.DirectoryEntry = Nothing
         Dim b(32 - 1) As Byte
         Dim bytesRead As UInt32
         Dim dirEntryCount As Integer = -1
-        Dim de As FAT12_16.DirectoryEntry
+        Dim de As FAT12.DirectoryEntry
 
         While clusterIndex < &HFFF8
             If clusterIndex = -1 Then
@@ -217,11 +227,11 @@ Public Class StandardDiskFormat
             Do
                 strm.Read(b, 0, b.Length)
                 Select Case b(0) ' First char of FileName
-                    Case 0 : Exit Do
+                    Case 0 : clusterIndex = -1 : Exit Do
                     Case 5 : b(0) = &HE5
                 End Select
                 pb = GCHandle.Alloc(b, GCHandleType.Pinned)
-                de = Marshal.PtrToStructure(pb.AddrOfPinnedObject(), GetType(FAT12_16.DirectoryEntry))
+                de = Marshal.PtrToStructure(pb.AddrOfPinnedObject(), GetType(FAT12.DirectoryEntry))
                 pb.Free()
 
                 If de.StartingCluster > 0 Then
@@ -246,13 +256,13 @@ Public Class StandardDiskFormat
     End Function
 
     Private Function ClusterToSector(partitionNumber As Integer, clusterIndex As Integer) As Long
-        Dim bs As FAT12_16.BootSector = mBootSectors(partitionNumber)
+        Dim bs As FAT12.BootSector = mBootSectors(partitionNumber)
         Dim rootDirectoryRegionStart As Long = fatRegionStart(partitionNumber) + bs.BIOSParameterBlock.NumberOfFATCopies * bs.BIOSParameterBlock.SectorsPerFAT * bs.BIOSParameterBlock.BytesPerSector
         Dim dataRegionStart As Long = rootDirectoryRegionStart + bs.BIOSParameterBlock.RootEntries * 32
         Return dataRegionStart + (clusterIndex - 2) * bs.BIOSParameterBlock.SectorsPerCluster * bs.BIOSParameterBlock.BytesPerSector
     End Function
 
-    Public Function ReadFile(partitionNumber As Integer, de As FAT12_16.DirectoryEntry) As Byte()
+    Public Function ReadFile(partitionNumber As Integer, de As FAT12.DirectoryEntry) As Byte()
         Dim bytesInCluster As UInt32 = mBootSectors(partitionNumber).BIOSParameterBlock.SectorsPerCluster * mBootSectors(partitionNumber).BIOSParameterBlock.BytesPerSector
         Dim clustersInFile As UInt32 = Math.Ceiling(de.FileSize / bytesInCluster)
         Dim b(clustersInFile * bytesInCluster - 1) As Byte
@@ -266,7 +276,7 @@ Public Class StandardDiskFormat
                 b(bytesRead) = strm.ReadByte()
                 bytesRead += 1
 
-                If (bytesRead Mod bytesInCluster) = 0 Then
+                If bytesRead >= de.FileSize AndAlso (bytesRead Mod bytesInCluster) = 0 Then
                     clusterIndex = mFATDataPointers(partitionNumber)(clusterIndex)
                     Exit Do
                 End If
@@ -283,7 +293,7 @@ Public Class StandardDiskFormat
         End Get
     End Property
 
-    Public ReadOnly Property BootSector(partitionIndex As Integer) As FAT12_16.BootSector
+    Public ReadOnly Property BootSector(partitionIndex As Integer) As FAT12.BootSector
         Get
             Return mBootSectors(partitionIndex)
         End Get
@@ -308,7 +318,7 @@ Public Class StandardDiskFormat
         End Get
     End Property
 
-    Public ReadOnly Property RootDirectoryEntries(partitionIndex As Integer) As FAT12_16.DirectoryEntry()
+    Public ReadOnly Property RootDirectoryEntries(partitionIndex As Integer) As FAT12.DirectoryEntry()
         Get
             Return mRootDirectoryEntries(partitionIndex)
         End Get
diff --git a/x8086NetEmu/Adapters/Disk/FloppyController.vb b/x8086NetEmu/Adapters/Disk/FloppyController.vb
index bf128f4..208e4bd 100644
--- a/x8086NetEmu/Adapters/Disk/FloppyController.vb
+++ b/x8086NetEmu/Adapters/Disk/FloppyController.vb
@@ -231,7 +231,7 @@ Public Class FloppyControllerAdapter
                  Commands.SCAN_GE
                 cmdHead = commandbuf(3)
             Case Else
-                cmdHead = CByte((commandbuf(1) >> 2) And 1)
+                cmdHead = (commandbuf(1) >> 2) And 1
         End Select
 
         ' Start execution
@@ -262,7 +262,7 @@ Public Class FloppyControllerAdapter
 
             Case Commands.CALIBRATE ' CALIBRATE: go to EXECUTE state
                 cmdCylinder = 0
-                driveSeeking = driveSeeking Or CByte(1 << cmdDrive)
+                driveSeeking = driveSeeking Or (1 << cmdDrive)
                 state = States.EXECUTE
                 sched.RunTaskAfter(task, COMMANDDELAY)
 
@@ -272,9 +272,9 @@ Public Class FloppyControllerAdapter
                 ' Respond to a completed seek command.
                 For i As Integer = 0 To 4 - 1
                     If (driveSeeking And (1 << i)) <> 0 Then
-                        driveSeeking = driveSeeking And CByte(((Not (1 << i)) And &HFF))
-                        pendingReadyChange = pendingReadyChange And CByte(((Not (1 << i)) And &HFF))
-                        CommandEndSense(CByte(&H20 Or i), curCylinder(i))
+                        driveSeeking = driveSeeking And CByte((Not 1 << i) And &HFF)
+                        pendingReadyChange = pendingReadyChange And CByte((Not 1 << i) And &HFF)
+                        CommandEndSense(&H20 Or i, curCylinder(i))
                         Exit Sub
                     End If
                 Next
@@ -282,24 +282,24 @@ Public Class FloppyControllerAdapter
                 ' Respond to a disk-ready change.
                 For i As Integer = 0 To 4 - 1
                     If (pendingReadyChange And (1 << i)) <> 0 Then
-                        pendingReadyChange = pendingReadyChange And CByte(((Not (1 << i)) And &HFF))
-                        CommandEndSense(CByte(&HC0 Or i), curCylinder(i))
+                        pendingReadyChange = pendingReadyChange And CByte((Not 1 << i) And &HFF)
+                        CommandEndSense(&HC0 Or i, curCylinder(i))
                         Exit Sub
                     End If
                 Next
 
                 ' No pending interrupt condition respond with invalid command.
-                CommandEndSense(CByte(&H80))
+                CommandEndSense(&H80)
 
             Case Commands.SPECIFY ' SPECIFY: no response
-                ctlStepRateTime = CByte((commandbuf(1) >> 4) And &HF)
-                ctlHeadUnloadTime = CByte(commandbuf(1) And &HF)
-                ctlHeadLoadTime = CByte((commandbuf(2) >> 1) And &H7F)
-                ctlNonDma = ((commandbuf(2) And 1) = 1)
+                ctlStepRateTime = (commandbuf(1) >> 4) And &HF
+                ctlHeadUnloadTime = commandbuf(1) And &HF
+                ctlHeadLoadTime = (commandbuf(2) >> 1) And &H7F
+                ctlNonDma = (commandbuf(2) And 1) = 1
                 CommandEndVoid()
 
             Case Commands.SENSE_DRIVE ' SENSE DRIVE: respond immediately
-                Dim st3 As Byte = CByte(commandbuf(1) And &H7)
+                Dim st3 As Byte = commandbuf(1) And &H7
                 If curCylinder(cmdDrive) = 0 Then st3 = st3 Or &H10 ' track 0
                 st3 = st3 Or &H20            ' ready line is tied to true
                 If diskimg(cmdDrive) IsNot Nothing Then
@@ -595,7 +595,7 @@ Public Class FloppyControllerAdapter
         state = States.RESULT
 
         'For i As Integer = 0 To 7 - 1
-        '    cpu.RAM8(&H40, &H42 + i) = resultbuf(i)
+        '    mCPU.Memory(X8086.SegmentOffetToAbsolute(&H40, &H42 + i)) = resultbuf(i)
         'Next
 
         If irq IsNot Nothing Then irq.Raise(True)
@@ -666,7 +666,7 @@ Public Class FloppyControllerAdapter
         End Select
 
         stmain = stmain Or driveSeeking ' bit mask of seeking drives
-        'cpu.RAM8(&H40, &H3E) = stmain
+        'mCPU.Memory(X8086.SegmentOffetToAbsolute(&H40, &H3E)) = stmain
 
         Return stmain
     End Function
@@ -681,7 +681,7 @@ Public Class FloppyControllerAdapter
         End Get
     End Property
 
-    Public Overrides Function [In](port As UInt32) As UInt32
+    Public Overrides Function [In](port As UInt32) As UInt16
         If (port And 3) = 0 Then
             ' main status register
             Return GetMainStatus()
@@ -715,10 +715,10 @@ Public Class FloppyControllerAdapter
         Return &HFF
     End Function
 
-    Public Overrides Sub Out(port As UInt32, v As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
         If (port And 3) = 2 Then
             ' write to digital output register
-            If (v And &H4) = 0 Then
+            If (value And &H4) = 0 Then
                 ' reset controller
                 Reset()
             ElseIf (regDOR And &H4) = 0 Then
@@ -726,25 +726,25 @@ Public Class FloppyControllerAdapter
                 If irq IsNot Nothing Then irq.Raise(True)
                 pendingReadyChange = &HF
             End If
-            regDOR = v And &HFF
+            regDOR = value And &HFF
 
         ElseIf (port And 3) = 1 Then
             ' write to data register
             If state = States.IDLE Then
                 ' CPU writes first command byte
                 state = States.COMMAND
-                cmdCmd = (v And &H1F)
+                cmdCmd = value And &H1F
                 commandlen = CommandLength()
             End If
 
             If state = States.COMMAND Then
                 ' CPU writes a command byte
-                commandbuf(commandptr) = v
+                commandbuf(commandptr) = value
                 commandptr += 1
                 If commandptr = commandlen Then CommandStart()
             ElseIf state = States.TRANSFER_IN AndAlso ctlNonDma Then
                 ' CPU writes data byte
-                databuf(dataptr) = v
+                databuf(dataptr) = value
                 dataptr += 1
                 state = States.TRANSWAIT_IN
                 If irq IsNot Nothing Then irq.Raise(False)
diff --git a/x8086NetEmu/Adapters/Keyboard/KeyMap.vb b/x8086NetEmu/Adapters/Keyboard/KeyMap.vb
index 69f47df..2f088bf 100644
--- a/x8086NetEmu/Adapters/Keyboard/KeyMap.vb
+++ b/x8086NetEmu/Adapters/Keyboard/KeyMap.vb
@@ -49,6 +49,7 @@
         virtualShiftState = False
         isSysRq = False
         stateKeyMask = 0
+
         ReDim keytbl(256 - 1)
         keytbl(Keys.Escape) = 1
         keytbl(Keys.D1) = 2
@@ -149,149 +150,6 @@
     End Sub
 
     Public Function GetScanCode(keyValue As Integer) As Integer
-        'x8086.Notify(keytbl(keyValue))
         Return keytbl(keyValue And &HFF)
     End Function
-
-    'Private Sub HandleInput(e As KeyEventArgs, released As Boolean)
-    '    Dim scan() As Byte
-
-    '    If e.KeyCode = Keys.Pause And Not released Then
-    '        '  Pause has special behaviour:
-    '        '  Acts as extended ScrollLock if Ctrl is down (Break),
-    '        '  other wise acts as extended Ctrl-NumLock.
-    '        '  e.KeyCode down and e.KeyCode release scan codes are always sent together.
-    '        If (stateKeyMask And (MASK_LCTRL Or MASK_RCTRL)) <> 0 Then
-    '            scan = New Byte() {&HE0, &H46,
-    '                                &HE0, &HC6}
-    '        Else
-    '            scan = New Byte() {&HE1, &H1D, &H45,
-    '                                &HE1, &H9D, &HC5}
-    '        End If
-    '        If controller IsNot Nothing Then
-    '            controller.PutKeyData(scan)
-    '            Exit Sub
-    '        End If
-    '    End If
-
-    '    ' Lookup e.KeyCode in table
-    '    Dim keyinfo As Integer = 0
-    '    If e.KeyCode < keytbl.Length Then keyinfo = keytbl(e.KeyCode)
-    '    If keyinfo = 0 Then Exit Sub ' ignore unknown e.KeyCode
-
-    '    ' Detect state keys (shift, ctrl, alt)
-    '    Dim statebit As Integer = 0
-    '    If keyinfo = SCAN_LSHIFT Then statebit = MASK_LSHIFT
-    '    If keyinfo = SCAN_CTRL Then statebit = MASK_LCTRL
-    '    If keyinfo = SCAN_ALT Then statebit = MASK_LALT
-
-    '    ' Distinguish left/right and numpad/editpad
-    '    Dim extend As Boolean = (keyinfo And KEY_EXTEND) <> 0
-    '    If statebit <> 0 AndAlso kevt.keyLocation = KeyEvent.KEY_LOCATION_RIGHT Then
-    '        If keyinfo = SCAN_LSHIFT Then
-    '            keyinfo = SCAN_RSHIFT ' right shift
-    '        Else
-    '            extend = True ' right ctrl or alt
-    '            statebit <<= 1
-    '        End If
-    '    if keyinfo And KEY_EDIT) <> 0 andalso            kevt.keyLocation = KeyEvent.KEY_LOCATION_STANDARD then
-    '            extend = True ' edit pad
-    '            keyinfo = keyinfo Or KEY_NONUM
-    '        End If
-    '        If e.KeyCode = KeyEvent.VK_ENTER AndAlso kevt.keyLocation = KeyEvent.KEY_LOCATION_NUMPAD Then
-    '            extend = True ' numpad Enter
-
-    '    if (released) {
-
-    '                ' Undo shift state virtualization that we (may) have
-    '                ' started when this e.KeyCode was pressed.
-    '        boolean undoVirtual = useVirtualShift AndAlso virtualShiftState &&
-    '                              ((keyinfo And (KEY_NOSHIFT Or KEY_NONUM)) <> 0)
-
-    '        if (e.KeyCode = KeyEvent.VK_PRINTSCREEN) {
-    '                    ' PrintScreen has special behaviour
-    '            if (!isSysRq) {
-    '                        keyinfo = 55
-    '                        extend = True
-    '                        undoVirtual = useVirtualShift AndAlso virtualShiftState
-    '            }
-    '                        isSysRq = False
-    '        }
-
-    '                        ' Construct e.KeyCode release scan code sequence
-    '        scan = new byte(((extend) ? 2 : 1) + ((undoVirtual) ? 2 : 0))
-    '                        Int(i = 0)
-    '                        If (extend) Then
-    '            scan(i++) = (byte)&he0
-    '        scan(i++) = (byte)(keyinfo Or &h80)
-    '        if (undoVirtual) {
-    '            scan(i++) = (byte)&he0
-    '            scan(i++) = ((stateKeyMask And MASK_LSHIFT) <> 0) ? SCAN_LSHIFT :
-    '                        ((stateKeyMask And MASK_RSHIFT) <> 0) ? SCAN_RSHIFT :
-    '                        (byte)(&h80 Or SCAN_LSHIFT)
-    '                                virtualShiftState = False
-    '        }
-
-    '                                ' Update the state e.KeyCode mask
-    '        stateKeyMask &= ~statebit
-    '                                If (e.KeyCode = KeyEvent.VK_NUM_LOCK) Then
-    '                                    stateKeyMask ^= MASK_NUMLOCK ' flip numlock state
-
-    '    } else {
-
-    '                                    ' Figure out how to manipulate the virtual shift state
-    '        boolean flipVirtual = false
-    '        if ((keyinfo And (KEY_NOSHIFT Or KEY_NONUM)) <> 0) {
-    '                                        ' e.KeyCode requires a particular shift state
-    '            boolean realShiftState =
-    '              ((stateKeyMask And (MASK_LSHIFT|MASK_RSHIFT)) <> 0)
-    '            boolean needShiftState =
-    '              ((keyinfo And KEY_NOSHIFT) = 0) &&
-    '              ((stateKeyMask And MASK_NUMLOCK) <> 0)
-    '            flipVirtual = useVirtualShift &&
-    '              (virtualShiftState = (realShiftState = needShiftState))
-    '        } else {
-    '                                        ' Modifier or "regular" e.KeyCode release shift virtualization.
-    '                                        flipVirtual = useVirtualShift AndAlso virtualShiftState
-    '        }
-
-    '        if (e.KeyCode = KeyEvent.VK_PRINTSCREEN) {
-    '                                            ' PrintScreen has special behaviour:
-    '                                            ' Acts as SysRq if Alt e.KeyCode is down, otherwise acts as
-    '                                            ' extended Asterisk with forced Shift unless Ctrl is down.
-    '            isSysRq = ((stateKeyMask And (MASK_LALT|MASK_RALT)) <> 0)
-    '            if (!isSysRq) {
-    '                                                keyinfo = 55
-    '                                                extend = True
-    '                boolean needVirtualShift = ((stateKeyMask &
-    '                  (MASK_LSHIFT|MASK_RSHIFT|MASK_LCTRL|MASK_RCTRL)) = 0)
-    '                flipVirtual = useVirtualShift &&
-    '                  (virtualShiftState <> needVirtualShift)
-    '            }
-    '        }
-
-    '                                                ' Construct e.KeyCode down scan code sequence
-    '        scan = new byte(((extend) ? 2 : 1) + ((flipVirtual) ? 2 : 0))
-    '                                                Int(i = 0)
-    '        if (flipVirtual) {
-    '            scan(i++) = (byte)&he0
-    '            scan(i++) = (byte)(
-    '              ( (virtualShiftState) ? &h00 : &h80 ) ^
-    '              ( ((stateKeyMask And MASK_LSHIFT) <> 0) ? SCAN_LSHIFT :
-    '                ((stateKeyMask And MASK_RSHIFT) <> 0) ? SCAN_RSHIFT :
-    '                (&h80 Or SCAN_LSHIFT) ) )
-    '                                                    virtualShiftState = !virtualShiftState
-    '        }
-    '                                                    If (extend) Then
-    '            scan(i++) = (byte)&he0
-    '        scan(i++) = (byte)keyinfo
-
-    '                                                        ' Update the state e.KeyCode mask
-    '        stateKeyMask |= statebit
-
-    '    }
-
-    '                                                        If (keyboardController <> null) Then
-    '                                                            keyboardController.putKeyData(scan)
-    'End Sub
 End Class
diff --git a/x8086NetEmu/Adapters/Keyboard/Keyboard.vb b/x8086NetEmu/Adapters/Keyboard/Keyboard.vb
index 6ab84e8..2da1665 100644
--- a/x8086NetEmu/Adapters/Keyboard/Keyboard.vb
+++ b/x8086NetEmu/Adapters/Keyboard/Keyboard.vb
@@ -1,7 +1,4 @@
-ï»¿Imports System.Threading
-Imports System.Runtime.InteropServices
-
-Public Class KeyboardAdapter
+ï»¿Public Class KeyboardAdapter
     Inherits Adapter
     Implements IExternalInputHandler
 
@@ -53,7 +50,7 @@ Public Class KeyboardAdapter
     Public Overrides Sub CloseAdapter()
     End Sub
 
-    Public Overrides Function [In](port As UInt32) As UInt32
+    Public Overrides Function [In](port As UInt32) As UInt16
         Return &HFF
     End Function
 
@@ -205,7 +202,7 @@ Public Class KeyboardAdapter
         End Get
     End Property
 
-    Public Overrides Sub Out(port As UInt32, value As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
     End Sub
 
     Public Overrides Sub Run()
diff --git a/x8086NetEmu/Adapters/Serial/MouseAdapter.vb b/x8086NetEmu/Adapters/Serial/MouseAdapter.vb
index 7adea29..1434d29 100644
--- a/x8086NetEmu/Adapters/Serial/MouseAdapter.vb
+++ b/x8086NetEmu/Adapters/Serial/MouseAdapter.vb
@@ -12,8 +12,8 @@
     Private sm As New SerialMouse()
     Private irq As PIC8259.IRQLine
 
-    Private lastX As Integer = Integer.MinValue
-    Private lastY As Integer = Integer.MinValue
+    Public Property MidPoint As Point
+    Public Property IsCaptured As Boolean
 
     Private Const M As Integer = Asc("M")
 
@@ -26,7 +26,7 @@
         Next
     End Sub
 
-    Public Overrides Function [In](port As UInt32) As UInt32
+    Public Overrides Function [In](port As UInt32) As UInt16
         Dim tmp As Integer
 
         Select Case port
@@ -50,15 +50,15 @@
                     tmp = 0
                 End If
 
-                'Return tmp
+                Return tmp
                 'Return &H60 Or tmp
-                Return &H1
+                'Return &H1
         End Select
 
         Return sm.reg(port And 7)
     End Function
 
-    Public Overrides Sub Out(port As UInt32, value As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
         Dim oldReg As Integer = sm.reg(port And 7)
         sm.reg(port And 7) = value
 
@@ -89,50 +89,21 @@
     Public Sub HandleInput(e As ExternalInputEvent) Implements IExternalInputHandler.HandleInput
         Dim m As MouseEventArgs = CType(e.TheEvent, MouseEventArgs)
 
-        ' TODO: The scaling code needs to be adjusted so that the size of the screen is properly mapped to the emulator window
-
-        If lastX = Integer.MinValue Then lastX = m.X
-        If lastY = Integer.MinValue Then lastY = m.Y
-
-        Dim va As VideoAdapter = mCPU.VideoAdapter
-        Dim rc As Control
-
-        If TypeOf va Is CGAWinForms Then
-            rc = CType(va, CGAWinForms).RenderControl
-        Else
-            rc = CType(va, VGAWinForms).RenderControl
-        End If
-
-        Dim rw As Double = rc.Width / If(va.MainMode = VideoAdapter.MainModes.Text, rc.Width, va.GraphicsResolution.Width)
-        Dim rh As Double = rc.Height / If(va.MainMode = VideoAdapter.MainModes.Text, rc.Height, va.GraphicsResolution.Height)
-
-        Dim rX As Integer = 1
-        Dim ry As Integer = 1
-
-        Dim p As New Point(m.X / va.Zoom, m.Y / va.Zoom / (rh / rw))
+        Dim p As New Point(m.X - MidPoint.X, m.Y - MidPoint.Y)
+        If p.X >= 3 Then p.X *= 0.4
+        If p.Y >= 3 Then p.Y *= 0.4
 
-        Dim sX As Integer = Math.Sign(p.X - lastX)
-        Dim sy As Integer = Math.Sign(p.Y - lastY)
+        Dim highbits As Byte = 0
+        If p.X < 0 Then highbits = 3
+        If p.Y < 0 Then highbits = highbits Or &HC
 
-        Do
-            rX = If(p.X = lastX, 0, sX)
-            ry = If(p.Y = lastY, 0, sy)
+        Dim btns As Byte = 0
+        If (m.Button And MouseButtons.Left) = MouseButtons.Left Then btns = btns Or 2
+        If (m.Button And MouseButtons.Right) = MouseButtons.Right Then btns = btns Or 1
 
-            Dim highbits As Integer = 0
-            If rX < 0 Then highbits = 3
-            If ry < 0 Then highbits = highbits Or &HC
-
-            Dim btns As Integer = 0
-            If (m.Button And MouseButtons.Left) = MouseButtons.Left Then btns = btns Or 2
-            If (m.Button And MouseButtons.Right) = MouseButtons.Right Then btns = btns Or 1
-
-            BufSerMouseData(&H40 Or (btns << 4) Or highbits)
-            BufSerMouseData(rX And &H3F)
-            BufSerMouseData(ry And &H3F)
-
-            lastX += rX
-            lastY += ry
-        Loop Until p.X = lastX AndAlso p.Y = lastY
+        BufSerMouseData(&H40 Or (btns << 4) Or highbits)
+        BufSerMouseData(p.X And &H3F)
+        BufSerMouseData(p.Y And &H3F)
     End Sub
 
     Public Overrides Sub CloseAdapter()
@@ -173,7 +144,7 @@
 
     Public Overrides ReadOnly Property VersionMajor As Integer
         Get
-            Return 0
+            Return 1
         End Get
     End Property
 
@@ -185,7 +156,7 @@
 
     Public Overrides ReadOnly Property VersionRevision As Integer
         Get
-            Return 1
+            Return 0
         End Get
     End Property
 End Class
diff --git a/x8086NetEmu/Adapters/Video/CGA/CGAAdapter.vb b/x8086NetEmu/Adapters/Video/CGA/CGAAdapter.vb
index 71a5a81..ec7c33b 100644
--- a/x8086NetEmu/Adapters/Video/CGA/CGAAdapter.vb
+++ b/x8086NetEmu/Adapters/Video/CGA/CGAAdapter.vb
@@ -6,8 +6,8 @@ Public MustInherit Class CGAAdapter
     Public Const VERTSYNC As Double = 60.0
     Public Const HORIZSYNC As Double = VERTSYNC * 262.5
 
-    Protected ht As Long = Scheduler.BASECLOCK \ HORIZSYNC
-    Protected vt As Long = (Scheduler.BASECLOCK \ HORIZSYNC) * (HORIZSYNC \ VERTSYNC)
+    Protected Const ht As Long = Scheduler.BASECLOCK \ HORIZSYNC
+    Protected Const vt As Long = (Scheduler.BASECLOCK \ HORIZSYNC) * (HORIZSYNC \ VERTSYNC)
 
     Public Enum VideoModes
         Mode0_Text_BW_40x25 = &H4
@@ -20,6 +20,8 @@ Public MustInherit Class CGAAdapter
         Mode6_Graphic_Color_640x200 = &H16
         Mode6_Graphic_Color_640x200_Alt = &H12
 
+        Mode7_Text_BW_80x25 = &H7F
+
         Undefined = &HFF
     End Enum
 
@@ -82,6 +84,11 @@ Public MustInherit Class CGAAdapter
         blue_border_in_40x25_or_blue_background_in_320x200_or_blue_foreground_in_640x200 = 0
     End Enum
 
+    Private ReadOnly CtrlMask() As Byte = {
+        &HFF, &HFF, &HFF, &HFF, &H7F, &H1F, &H7F, &H7F, &HF3, &H1F, &H7F, &H1F, &H3F, &HFF, &H3F, &HFF,
+        &HFF, &HFF, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0
+    }
+
     Protected Friend CRT6845IndexRegister As Byte = 0
     Protected Friend CRT6845DataRegister(256 - 1) As Byte
 
@@ -107,31 +114,38 @@ Public MustInherit Class CGAAdapter
     Private mZoom As Double = 1.0
 
     Protected videoBMP As DirectBitmap = New DirectBitmap(1, 1)
-    Private loopThread As Thread
     Private waiter As AutoResetEvent
     Protected cancelAllThreads As Boolean
-    Private useInternalTimer As Boolean
+    Private ReadOnly useInternalTimer As Boolean
 
     'Public Event VideoRefreshed(sender As Object)
 
     Protected chars(256 - 1) As Char
 
     Private mCPU As X8086
-
-    Private Const vidModeChangeFlag As Integer = &B1000
+    Protected vidModeChangeFlag As Integer = &B1000
 
     Public MustOverride Overrides Sub AutoSize()
     Protected MustOverride Sub Render()
 
-    Public Sub New(cpu As X8086, Optional useInternalTimer As Boolean = True)
+    Protected wui As WebUI
+
+    Public Sub New(cpu As X8086, Optional useInternalTimer As Boolean = True, Optional enableWebUI As Boolean = False)
         MyBase.New(cpu)
         mCPU = cpu
         Me.useInternalTimer = useInternalTimer
 
-        For i As UInt32 = &H3D0 To &H3DF
+        If enableWebUI Then wui = New WebUI(cpu, videoBMP, chars)
+
+        For i As UInt32 = &H3D0 To &H3DF ' CGA
             ValidPortAddress.Add(i)
         Next
 
+        ' This breaks ARKANOID ][
+        'For i As UInt32 = &H3B0 To &H3BB ' Hercules
+        '    ValidPortAddress.Add(i)
+        'Next
+
         For i As Integer = 0 To 255
             If i >= 32 AndAlso i < 255 Then
                 chars(i) = Convert.ToChar(i)
@@ -142,22 +156,28 @@ Public MustInherit Class CGAAdapter
 
         waiter = New AutoResetEvent(False)
         Reset()
+
+        'VideoMode = VideoModes.Mode7_Text_BW_80x25
     End Sub
 
     Public Sub HandleKeyDown(sender As Object, e As KeyEventArgs)
-        MyBase.OnKeyDown(Me, e)
-        If e.Handled Then Exit Sub
-        'Debug.WriteLine("KEY DOWN: " + e.KeyCode.ToString() + " | " + e.Modifiers.ToString())
-        If mCPU.Keyboard IsNot Nothing Then mCPU.Sched.HandleInput(New ExternalInputEvent(mCPU.Keyboard, e, False))
+        If keyMap.GetScanCode(e.KeyValue) <> 0 Then
+            MyBase.OnKeyDown(Me, e)
+            If e.Handled Then Exit Sub
+            'Debug.WriteLine($"KEY DOWN: {e.KeyCode} | {e.Modifiers} | {e.KeyValue}")
+            If mCPU.Keyboard IsNot Nothing Then mCPU.Sched.HandleInput(New ExternalInputEvent(mCPU.Keyboard, e, False))
+        End If
         e.Handled = True
         e.SuppressKeyPress = True
     End Sub
 
     Public Sub HandleKeyUp(sender As Object, e As KeyEventArgs)
-        MyBase.OnKeyUp(Me, e)
-        If e.Handled Then Exit Sub
-        'Debug.WriteLine("KEY UP:   " + e.KeyCode.ToString() + " | " + e.Modifiers.ToString())
-        If mCPU.Keyboard IsNot Nothing Then mCPU.Sched.HandleInput(New ExternalInputEvent(mCPU.Keyboard, e, True))
+        If keyMap.GetScanCode(e.KeyValue) <> 0 Then
+            MyBase.OnKeyUp(Me, e)
+            If e.Handled Then Exit Sub
+            'Debug.WriteLine($"KEY UP: {e.KeyCode} | {e.Modifiers} | {e.KeyValue}")
+            If mCPU.Keyboard IsNot Nothing Then mCPU.Sched.HandleInput(New ExternalInputEvent(mCPU.Keyboard, e, True))
+        End If
         e.Handled = True
     End Sub
 
@@ -264,13 +284,8 @@ Public MustInherit Class CGAAdapter
     End Property
 
     Public Overrides Sub InitiAdapter()
-        isInit = (mCPU IsNot Nothing)
-        If isInit Then
-            If useInternalTimer Then
-                loopThread = New Thread(AddressOf MainLoop)
-                loopThread.Start()
-            End If
-        End If
+        isInit = mCPU IsNot Nothing
+        If isInit AndAlso useInternalTimer Then Tasks.Task.Run(AddressOf MainLoop)
     End Sub
 
     Private Sub MainLoop()
@@ -323,7 +338,7 @@ Public MustInherit Class CGAAdapter
             Return mVideoMode
         End Get
         Set(value As UInt32)
-            mVideoMode = (value And (Not &H80))
+            mVideoMode = value And (Not &H80)
 
             mStartTextVideoAddress = &HB8000
             mStartGraphicsVideoAddress = &HB8000
@@ -364,6 +379,13 @@ Public MustInherit Class CGAAdapter
                     mVideoResolution = New Size(640, 200)
                     mMainMode = MainModes.Graphics
 
+                Case VideoModes.Mode7_Text_BW_80x25
+                    mStartTextVideoAddress = &HB0000
+                    mStartGraphicsVideoAddress = &HB0000
+                    mTextResolution = New Size(80, 25)
+                    mVideoResolution = New Size(720, 400)
+                    mMainMode = MainModes.Text
+
                 Case Else
                     mCPU.RaiseException("CGA: Unknown Video Mode " + CInt(value).ToString("X2"))
                     mVideoMode = VideoModes.Undefined
@@ -384,15 +406,16 @@ Public MustInherit Class CGAAdapter
         X8086.Notify("Set Video Mode: {0}", X8086.NotificationReasons.Info, mVideoMode)
 
         OnPaletteRegisterChanged()
+
         AutoSize()
     End Sub
 
-    Public Overrides Function [In](port As UInt32) As UInt32
+    Public Overrides Function [In](port As UInt32) As UInt16
         Select Case port
             Case &H3D0, &H3D2, &H3D4, &H3D6 ' CRT (6845) index register
                 Return CRT6845IndexRegister
 
-            Case &H3D1, &H3D3, &H3D5, &H3D7 ' CRT (6845) data register
+            Case &H3D1, &H3D3, &H3D5, &H3D7, &H3B5 ' CRT (6845) data register
                 Return CRT6845DataRegister(CRT6845IndexRegister)
 
             Case &H3D8 ' CGA mode control register  (except PCjr)
@@ -401,7 +424,7 @@ Public MustInherit Class CGAAdapter
             Case &H3D9 ' CGA palette register
                 Return X8086.BitsArrayToWord(CGAPaletteRegister)
 
-            Case &H3DA ' CGA status register
+            Case &H3DA, &H3BA ' CGA status register
                 UpdateStatusRegister()
                 Return X8086.BitsArrayToWord(CGAStatusRegister)
 
@@ -416,29 +439,29 @@ Public MustInherit Class CGAAdapter
         Return &HFF
     End Function
 
-    Private ctrlMask() As Byte = {
-        &HFF, &HFF, &HFF, &HFF, &H7F, &H1F, &H7F, &H7F, &HF3, &H1F, &H7F, &H1F, &H3F, &HFF, &H3F, &HFF,
-        &HFF, &HFF, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0
-    }
-
-    Public Overrides Sub Out(port As UInt32, value As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
         Select Case port
-            Case &H3D0, &H3D2, &H3D4, &H3D6 ' CRT (6845) index register
+            Case &H3B8
+                If (value And 2) = 2 Then VideoMode = VideoModes.Mode7_Text_BW_80x25
+
+            Case &H3D0, &H3D2, &H3D4, &H3D6,
+                 &H3B0, &H3B2, &H3B4 ' CRT (6845) index register
                 CRT6845IndexRegister = value And 31
 
-            Case &H3D1, &H3D3, &H3D5, &H3D7 ' CRT (6845) data register
-                CRT6845DataRegister(CRT6845IndexRegister) = value And ctrlMask(CRT6845IndexRegister)
+            Case &H3D1, &H3D3, &H3D5, &H3D7,
+                 &H3B1, &H3B3, &H3B5 ' CRT (6845) data register
+                CRT6845DataRegister(CRT6845IndexRegister) = value And CtrlMask(CRT6845IndexRegister)
                 OnDataRegisterChanged()
 
-            Case &H3D8 ' CGA mode control register  (except PCjr)
+            Case &H3D8, &H3B8 ' CGA mode control register  (except PCjr)
                 X8086.WordToBitsArray(value, CGAModeControlRegister)
                 OnModeControlRegisterChanged()
 
-            Case &H3D9 ' CGA palette register
+            Case &H3D9, &H3B9 ' CGA palette register
                 X8086.WordToBitsArray(value, CGAPaletteRegister)
                 OnPaletteRegisterChanged()
 
-            Case &H3DA ' CGA status register	EGA/VGA: input status 1 register / EGA/VGA feature control register
+            Case &H3DA, &H3BA ' CGA status register	EGA/VGA: input status 1 register / EGA/VGA feature control register
                 X8086.WordToBitsArray(value, CGAStatusRegister)
 
             Case &H3DB ' The trigger is cleared by writing any value to port 03DBh (undocumented)
@@ -446,45 +469,14 @@ Public MustInherit Class CGAAdapter
 
             Case &H3DF ' CRT/CPU page register  (PCjr only)
                 'Stop
+
             Case Else
                 mCPU.RaiseException("CGA: Unknown Out Port: " + port.ToString("X4"))
         End Select
     End Sub
 
-    'Public Overrides Sub Out(port As UInt32, value As UInt32)
-    '    Select Case port
-    '        Case &H3D0, &H3D2, &H3D4, &H3D6 ' CRT (6845) index register
-    '            CRT6845IndexRegister = value And &HFF
-
-    '        Case &H3D1, &H3D3, &H3D5, &H3D7 ' CRT (6845) data register
-    '            Dim old As Byte = CRT6845DataRegister(CRT6845IndexRegister)
-    '            CRT6845DataRegister(CRT6845IndexRegister) = value
-
-    '            OnDataRegisterChanged()
-
-    '        Case &H3D8 ' CGA mode control register  (except PCjr)
-    '            X8086.WordToBitsArray(value, CGAModeControlRegister)
-    '            OnModeControlRegisterChanged()
-
-    '        Case &H3D9 ' CGA palette register
-    '            X8086.WordToBitsArray(value, CGAPaletteRegister)
-    '            OnPaletteRegisterChanged()
-
-    '        Case &H3DA ' CGA status register	EGA/VGA: input status 1 register / EGA/VGA feature control register
-    '            X8086.WordToBitsArray(value, CGAStatusRegister)
-
-    '        Case &H3DB ' The trigger is cleared by writing any value to port 03DBh (undocumented)
-    '            CGAStatusRegister(CGAStatusRegisters.light_pen_trigger_set) = False
-
-    '        Case &H3DF ' CRT/CPU page register  (PCjr only)
-    '            'Stop
-    '        Case Else
-    '            mCPU.RaiseException("CGA: Unknown Out Port: " + port.ToString("X4"))
-    '    End Select
-    'End Sub
-
     Protected Overridable Sub OnDataRegisterChanged()
-        mCursorVisible = ((CRT6845DataRegister(&HA) And &H60) = 0)
+        mCursorVisible = (CRT6845DataRegister(&HA) And &H60) <> &H20
 
         If mCursorVisible Then
             Dim startOffset As Integer = ((CRT6845DataRegister(&HC) And &H3F) << 8) Or (CRT6845DataRegister(&HD) And &HFF)
@@ -512,7 +504,7 @@ Public MustInherit Class CGAAdapter
 
         If (v And vidModeChangeFlag) <> 0 AndAlso newMode <> mVideoMode Then VideoMode = newMode
 
-        mVideoEnabled = CGAModeControlRegister(CGAModeControlRegisters.video_enabled)
+        mVideoEnabled = CGAModeControlRegister(CGAModeControlRegisters.video_enabled) OrElse VideoMode = VideoModes.Mode7_Text_BW_80x25
     End Sub
 
     Protected Overridable Sub OnPaletteRegisterChanged()
@@ -526,8 +518,8 @@ Public MustInherit Class CGAAdapter
             Select Case VideoMode
                 Case VideoModes.Mode4_Graphic_Color_320x200
                     Dim intense As Integer = (cgaColorReg And &H10) >> 1
-                    Dim pal1 As Integer = (cgaColorReg >> 5) And (Not (cgaModeReg >> 2)) And 1
-                    Dim pal2 As Integer = ((Not cgaColorReg) >> 5) And (Not (cgaModeReg >> 2)) And 1
+                    Dim pal1 As Integer = (cgaColorReg >> 5) And (Not cgaModeReg >> 2) And 1
+                    Dim pal2 As Integer = ((Not cgaColorReg) >> 5) And (Not cgaModeReg >> 2) And 1
 
                     colors = New Color() {
                             CGABasePalette(cgaColorReg And &HF),
@@ -573,6 +565,7 @@ Public MustInherit Class CGAAdapter
     Public Overrides Sub CloseAdapter()
         isInit = False
         cancelAllThreads = True
+        wui?.Close()
 
         Application.DoEvents()
     End Sub
diff --git a/x8086NetEmu/Adapters/Video/CGA/CGAConsole.vb b/x8086NetEmu/Adapters/Video/CGA/CGAConsole.vb
index afff7cb..f24b0b8 100644
--- a/x8086NetEmu/Adapters/Video/CGA/CGAConsole.vb
+++ b/x8086NetEmu/Adapters/Video/CGA/CGAConsole.vb
@@ -15,7 +15,7 @@ Public Class CGAConsole
 
     Public Sub New(cpu As X8086)
         MyBase.New(cpu)
-        InitiAdapter()
+        'InitiAdapter()
         AutoSize()
 
         Console.TreatControlCAsInput = True
@@ -29,34 +29,23 @@ Public Class CGAConsole
             .ScanMode = Image2Ascii.ScanModes.Fast
         }
 
-        Dim tmp As New Thread(Sub()
-                                  Do
-                                      Thread.Sleep(1000 \ frameRate)
-
-                                      Try
-                                          If MainMode = MainModes.Graphics Then
-                                              i2a.ProcessImage(False)
-
-                                              For y As Integer = 0 To Console.WindowHeight - 1
-                                                  For x As Integer = 0 To Console.WindowWidth - 1
-                                                      ConsoleCrayon.WriteFast(i2a.Canvas(x)(y).Character, Image2Ascii.ToConsoleColor(i2a.Canvas(x)(y).Color), ConsoleColor.Black, x, y)
-                                                  Next
-                                              Next
-                                          End If
-                                      Catch : End Try
-                                  Loop Until MyBase.cancelAllThreads
-                              End Sub)
-        tmp.Start()
-    End Sub
-
-    Private Sub HandleModifier(v As ConsoleModifiers, t As ConsoleModifiers, k As Keys)
-        If HasModifier(v, t) AndAlso Not HasModifier(lastModifiers, t) Then
-            MyBase.HandleKeyDown(Me, New KeyEventArgs(k))
-            Thread.Sleep(100)
-        ElseIf Not HasModifier(v, t) AndAlso HasModifier(lastModifiers, t) Then
-            MyBase.HandleKeyUp(Me, New KeyEventArgs(k))
-            Thread.Sleep(100)
-        End If
+        Tasks.Task.Run(Sub()
+                           Do
+                               Thread.Sleep(1000 \ frameRate)
+
+                               Try
+                                   If MainMode = MainModes.Graphics Then
+                                       i2a.ProcessImage(False)
+
+                                       For y As Integer = 0 To Console.WindowHeight - 1
+                                           For x As Integer = 0 To Console.WindowWidth - 1
+                                               ConsoleCrayon.WriteFast(i2a.Canvas(x)(y).Character, Image2Ascii.ToConsoleColor(i2a.Canvas(x)(y).Color), ConsoleColor.Black, x, y)
+                                           Next
+                                       Next
+                                   End If
+                               Catch : End Try
+                           Loop Until MyBase.cancelAllThreads
+                       End Sub)
     End Sub
 
     Private Function HasModifier(v As ConsoleModifiers, t As ConsoleModifiers) As Boolean
@@ -64,11 +53,11 @@ Public Class CGAConsole
     End Function
 
     Public Overrides Sub AutoSize()
-        'Dim length = Console.WindowWidth * Console.WindowHeight * 2
-        Dim length = TextResolution.Width * TextResolution.Height * 2
-        If buffer Is Nothing OrElse buffer.Length <> length Then ReDim buffer(length - 1)
-
-        ResizeRenderControl()
+        Dim length As Integer = TextResolution.Width * TextResolution.Height * 2
+        If buffer Is Nothing OrElse buffer?.Length <> length Then
+            ReDim buffer(length - 1)
+            ResizeRenderControl()
+        End If
     End Sub
 
     Private Overloads Sub ResizeRenderControl()
@@ -84,6 +73,7 @@ Public Class CGAConsole
                 Console.SetWindowSize(i2a.CanvasSize.Width, i2a.CanvasSize.Height)
         End Select
         Console.SetBufferSize(Console.WindowWidth, Console.WindowHeight)
+        Array.Clear(buffer, 0, buffer.Length)
 #End If
     End Sub
 
@@ -111,7 +101,7 @@ Public Class CGAConsole
 
             HandleModifier(keyInfo.Modifiers, ConsoleModifiers.Shift, Keys.ShiftKey)
             HandleModifier(keyInfo.Modifiers, ConsoleModifiers.Control, Keys.ControlKey)
-            HandleModifier(keyInfo.Modifiers, ConsoleModifiers.Alt, Keys.Alt)
+            HandleModifier(keyInfo.Modifiers, ConsoleModifiers.Alt, Keys.Alt Or Keys.Menu)
             lastModifiers = keyInfo.Modifiers
 
             MyBase.HandleKeyDown(Me, keyEvent)
@@ -120,6 +110,16 @@ Public Class CGAConsole
         End If
     End Sub
 
+    Private Sub HandleModifier(v As ConsoleModifiers, t As ConsoleModifiers, k As Keys)
+        If HasModifier(v, t) AndAlso Not HasModifier(lastModifiers, t) Then
+            MyBase.HandleKeyDown(Me, New KeyEventArgs(k))
+            Thread.Sleep(100)
+        ElseIf Not HasModifier(v, t) AndAlso HasModifier(lastModifiers, t) Then
+            MyBase.HandleKeyUp(Me, New KeyEventArgs(k))
+            Thread.Sleep(100)
+        End If
+    End Sub
+
     Protected Overrides Sub Render()
         If isRendering OrElse CPU Is Nothing Then Exit Sub
         isRendering = True
@@ -145,7 +145,7 @@ Public Class CGAConsole
 
         For y As Integer = 0 To GraphicsResolution.Height - 1
             For x As Integer = 0 To GraphicsResolution.Width - 1
-                address = StartGraphicsVideoAddress + ((y >> 1) * 80) + ((y And 1) * &H2000) + (x >> xDiv)
+                address = mStartGraphicsVideoAddress + ((y >> 1) * 80) + ((y And 1) * &H2000) + (x >> xDiv)
                 b = CPU.Memory(address)
 
                 If PixelsPerByte = 4 Then
@@ -174,22 +174,37 @@ Public Class CGAConsole
 
         Dim cv As Boolean = False
 
-        ' The "-4" is to prevent the code from printing the last character and avoid scrolling.
-        ' Unfortunately, this causes the last char to not be printed
-        For address As Integer = StartTextVideoAddress To StartTextVideoAddress + buffer.Length - 4 Step 2
-            b0 = CPU.RAM(address)
-            b1 = CPU.RAM(address + 1)
+        Dim text As String = ""
+        Dim b1c As Byte = CPU.Memory(mStartTextVideoAddress + 1)
+        Dim c As Integer
+        Dim r As Integer
 
-            If (blinkCounter < BlinkRate) AndAlso BlinkCharOn AndAlso (b1 And &H80) Then b0 = 0
+        Console.CursorVisible = False
 
-            If buffer(bufIdx) <> b0 OrElse buffer(bufIdx + 1) <> b1 Then
-                ConsoleCrayon.WriteFast(chars(b0), b1.LowNib(), b1.HighNib(), col, row)
-                buffer(bufIdx) = b0
-                buffer(bufIdx + 1) = b1
+        ' The "-4" is to prevent the code from printing the last character and avoid scrolling.
+        ' Unfortunately, this causes the last char to not be printed
+        For address As Integer = mStartTextVideoAddress To mEndTextVideoAddress + buffer.Length - 4 Step 2
+            b0 = CPU.Memory(address)
+            b1 = CPU.Memory(address + 1)
+
+            If (blinkCounter < BlinkRate) AndAlso BlinkCharOn AndAlso (b1 And &H80) <> 0 Then b0 = 0
+
+            'If buffer(bufIdx) <> b0 OrElse buffer(bufIdx + 1) <> b1 Then
+            If b1c <> b1 Then
+                ConsoleCrayon.WriteFast(text, b1c.LowNib(), b1c.HighNib(), c, r)
+                text = ""
+                b1c = b1
+                c = col
+                r = row
             End If
+            text += chars(b0)
+            'ConsoleCrayon.WriteFast(chars(b0), b1.LowNib(), b1.HighNib(), col, row)
+            'buffer(bufIdx) = b0
+            'buffer(bufIdx + 1) = b1
+            'End If
 
             If CursorVisible AndAlso row = CursorRow AndAlso col = CursorCol Then
-                If blinkCounter < BlinkRate Then cv = True
+                cv = blinkCounter < BlinkRate
 
                 If blinkCounter >= 2 * BlinkRate Then
                     blinkCounter = 0
@@ -208,11 +223,11 @@ Public Class CGAConsole
             bufIdx += 2
         Next
 
+        If text <> "" Then ConsoleCrayon.WriteFast(text, b1c.LowNib(), b1c.HighNib(), c, r)
+
         If cv Then
             Console.SetCursorPosition(CursorCol, CursorRow)
             Console.CursorVisible = True
-        Else
-            Console.CursorVisible = False
         End If
     End Sub
 
diff --git a/x8086NetEmu/Adapters/Video/CGA/CGAWinForms.vb b/x8086NetEmu/Adapters/Video/CGA/CGAWinForms.vb
index ba96ce5..cad31f7 100644
--- a/x8086NetEmu/Adapters/Video/CGA/CGAWinForms.vb
+++ b/x8086NetEmu/Adapters/Video/CGA/CGAWinForms.vb
@@ -46,8 +46,8 @@ Public Class CGAWinForms
     End Class
     Private task As Scheduler.Task = New TaskSC(Me)
 
-    Public Sub New(cpu As X8086, renderControl As Control, Optional fontSource As FontSources = FontSources.BitmapFile, Optional bitmapFontFile As String = "")
-        MyBase.New(cpu)
+    Public Sub New(cpu As X8086, renderControl As Control, Optional fontSource As FontSources = FontSources.BitmapFile, Optional bitmapFontFile As String = "", Optional enableWebUI As Boolean = False)
+        MyBase.New(cpu,, enableWebUI)
         fontSourceMode = fontSource
         mCPU = cpu
         Me.RenderControl = renderControl
@@ -56,7 +56,12 @@ Public Class CGAWinForms
         AddHandler mRenderControl.KeyUp, Sub(sender As Object, e As KeyEventArgs) HandleKeyUp(Me, e)
 
         AddHandler mRenderControl.MouseDown, Sub(sender As Object, e As MouseEventArgs) OnMouseDown(Me, e)
-        AddHandler mRenderControl.MouseMove, Sub(sender As Object, e As MouseEventArgs) OnMouseMove(Me, e)
+        AddHandler mRenderControl.MouseMove, Sub(sender As Object, e As MouseEventArgs)
+                                                 If mCPU.Mouse?.IsCaptured Then
+                                                     OnMouseMove(Me, e)
+                                                     Cursor.Position = mRenderControl.PointToScreen(mCPU.Mouse.MidPoint)
+                                                 End If
+                                             End Sub
         AddHandler mRenderControl.MouseUp, Sub(sender As Object, e As MouseEventArgs) OnMouseUp(Me, e)
 
         Dim fontCGAPath As String = X8086.FixPath("roms\" + bitmapFontFile)
@@ -77,7 +82,7 @@ Public Class CGAWinForms
                     fontSourceMode = FontSources.TrueType
                 End If
             Case FontSources.ROM
-                VideoChar.BuildFontBitmapsFromROM(8, 8, 8, &HFE00 + &H1A6E, mCPU.Memory)
+                VideoChar.BuildFontBitmapsFromROM(8, 8, 4, &HFE000 + &H1A6E, mCPU.Memory)
                 mCellSize = New Size(8, 8)
         End Select
 
@@ -143,7 +148,7 @@ Public Class CGAWinForms
     Public Overrides Sub AutoSize()
         If mRenderControl IsNot Nothing Then
             If mRenderControl.InvokeRequired Then
-                mRenderControl.Invoke(New MethodInvoker(AddressOf ResizeRenderControl))
+                mRenderControl.Invoke(Sub() ResizeRenderControl())
             Else
                 ResizeRenderControl()
             End If
@@ -181,7 +186,9 @@ Public Class CGAWinForms
         OnPreRender(sender, e)
         g.CompositingMode = Drawing2D.CompositingMode.SourceCopy
 
-        g.DrawImageUnscaled(videoBMP, 0, 0)
+        SyncLock chars
+            g.DrawImageUnscaled(videoBMP, 0, 0)
+        End SyncLock
 
         g.CompositingMode = Drawing2D.CompositingMode.SourceOver
         OnPostRender(sender, e)
@@ -200,15 +207,14 @@ Public Class CGAWinForms
 
     Protected Overrides Sub Render()
         If VideoEnabled Then
-            SyncLock videoBMP
-                Select Case MainMode
-                    Case MainModes.Text
-                        Try ' FIXME: Fix the issues instead of ignoring them! (VideoChar.Paint generates an exception every time the resolution is changed)
-                            RenderText()
-                        Catch : End Try
-                    Case MainModes.Graphics : RenderGraphics()
-                End Select
-            End SyncLock
+            Try
+                SyncLock chars
+                    Select Case MainMode
+                        Case MainModes.Text : RenderText()
+                        Case MainModes.Graphics : RenderGraphics()
+                    End Select
+                End SyncLock
+            Catch : End Try
         End If
     End Sub
 
@@ -221,12 +227,14 @@ Public Class CGAWinForms
 
         Dim r As New Rectangle(Point.Empty, mCellSize)
 
-        For address As Integer = StartTextVideoAddress To EndTextVideoAddress Step 2
-            b0 = mCPU.Memory(address)
-            b1 = mCPU.Memory(address + 1)
+        If Not CursorVisible Then blinkCounter = 2 * BlinkRate
+
+        For address As Integer = mStartTextVideoAddress To mEndTextVideoAddress - 2 Step 2
+            b0 = CPU.Memory(address)
+            b1 = CPU.Memory(address + 1)
 
-            If BlinkCharOn AndAlso (b1 And &B1000_0000) Then
-                If (blinkCounter < BlinkRate) Then b0 = 0
+            If BlinkCharOn AndAlso (b1 And &B1000_0000) <> 0 Then
+                If blinkCounter < BlinkRate Then b0 = 0
                 'IsDirty(address) = True
             End If
 
@@ -239,7 +247,7 @@ Public Class CGAWinForms
                 If blinkCounter < BlinkRate Then
                     videoBMP.FillRectangle(brushCache(b1.LowNib()),
                                            r.X + 0, r.Y - 1 + mCellSize.Height - (MyBase.CursorEnd - MyBase.CursorStart) - 1,
-                                           mCellSize.Width, (MyBase.CursorEnd - MyBase.CursorStart) + 1)
+                                           mCellSize.Width, MyBase.CursorEnd - MyBase.CursorStart + 1)
                     cursorAddress.Add(address)
                 End If
 
@@ -263,16 +271,13 @@ Public Class CGAWinForms
         Next
     End Sub
 
-    ' FIXME: IsDirty is not working here. Also, scrolling games present a flickering issue
     Private Sub RenderGraphics()
         Dim b As Byte
-        Dim address As UInt32
         Dim xDiv As Integer = If(PixelsPerByte = 4, 2, 3)
 
         For y As Integer = 0 To GraphicsResolution.Height - 1
             For x As Integer = 0 To GraphicsResolution.Width - 1
-                address = StartGraphicsVideoAddress + ((y >> 1) * 80) + ((y And 1) * &H2000) + (x >> xDiv)
-                b = CPU.Memory(address)
+                b = CPU.Memory(mStartGraphicsVideoAddress + ((y >> 1) * 80) + ((y And 1) * &H2000) + (x >> xDiv))
 
                 If PixelsPerByte = 4 Then
                     Select Case x And 3
@@ -442,13 +447,16 @@ Public Class CGAWinForms
             mCellSize = charSizeCache(65)
         End If
 
-        If videoBMP IsNot Nothing Then videoBMP.Dispose()
-        Select Case MainMode
-            Case MainModes.Text
-                videoBMP = New DirectBitmap(640, 400)
-            Case MainModes.Graphics
-                videoBMP = New DirectBitmap(GraphicsResolution.Width, GraphicsResolution.Height)
-        End Select
+        SyncLock chars
+            If videoBMP IsNot Nothing Then videoBMP.Dispose()
+            Select Case MainMode
+                Case MainModes.Text
+                    videoBMP = New DirectBitmap(640, 400)
+                Case MainModes.Graphics
+                    videoBMP = New DirectBitmap(GraphicsResolution.Width, GraphicsResolution.Height)
+            End Select
+            If wui IsNot Nothing Then wui.Bitmap = videoBMP
+        End SyncLock
 
         If fontSourceMode = FontSources.TrueType Then
             If g IsNot Nothing Then g.Dispose()
diff --git a/x8086NetEmu/Adapters/Video/DirectBitmap.vb b/x8086NetEmu/Adapters/Video/DirectBitmap.vb
index 30b2a79..91382db 100644
--- a/x8086NetEmu/Adapters/Video/DirectBitmap.vb
+++ b/x8086NetEmu/Adapters/Video/DirectBitmap.vb
@@ -18,6 +18,9 @@ Public Class DirectBitmap
     Private w4 As Integer
     Private bufferSize As Integer
 
+    Private Shared imgConverter As New ImageConverter()
+    Private Shared imgFormat As Type = GetType(Byte())
+
     Public Sub New(w As Integer, h As Integer)
         Me.Width = w
         Me.Height = h
@@ -75,6 +78,10 @@ Public Class DirectBitmap
         Return dbmp.Bitmap
     End Operator
 
+    Public Shared Narrowing Operator CType(dbmp As DirectBitmap) As Byte()
+        Return imgConverter.ConvertTo(dbmp.Bitmap, imgFormat)
+    End Operator
+
     Public Property Pixel(p As Point) As Color
         Get
             Return Pixel(p.X, p.Y)
@@ -138,7 +145,7 @@ Public Class DirectBitmap
     End Function
 
     Private Function GetAlpha(a1p As Double, a2p As Double) As Double
-        Return (a1p + a2p * (1 - a1p))
+        Return a1p + a2p * (1 - a1p)
     End Function
 
 #Region "IDisposable Support"
diff --git a/x8086NetEmu/Adapters/Video/Image2Ascii.vb b/x8086NetEmu/Adapters/Video/Image2Ascii.vb
index c6e8166..d3e3bb0 100644
--- a/x8086NetEmu/Adapters/Video/Image2Ascii.vb
+++ b/x8086NetEmu/Adapters/Video/Image2Ascii.vb
@@ -3,6 +3,8 @@
         GrayScale
         FullGrayScale
         Color
+        DitheredGrayScale
+        DitheredColor
     End Enum
 
     Public Enum ScanModes
@@ -33,21 +35,24 @@
     Private mBitmap As DirectBitmap
     Private mSurface As Bitmap
 
-    Private mCanvasSize As Size = New Size(80, 25)
+    Private mCanvasSize As Size
     Private mCanvas()() As ASCIIChar
-    Private mColorMode As ColorModes = ColorModes.GrayScale
-    Private mScanMode As ScanModes = ScanModes.Fast
-    Private mCharset As Charsets = Charsets.Standard
-    Private mGrayScaleMode As GrayscaleModes = GrayscaleModes.Average
-    Private mBackColor As Color = Color.Black
+    Private mColorMode As ColorModes
+    Private mScanMode As ScanModes
+    Private mCharset As Charsets
+    Private mGrayScaleMode As GrayscaleModes
+    Private mBackColor As Color
 
-    Private mFont As New Font("Consolas", 12)
+    Private mDitherColors As Integer = 8
+
+    Private mFont As Font
 
     Private lastCanvasSize As Size = New Size(-1, -1)
     Private surfaceGraphics As Graphics
     Private charsetsChars() As String = {" Â·:+x#W@", " âââââââ"}
     Private activeChars As String = charsetsChars(0)
 
+    Private mChatOffset As Point
     Private mCharSize As Size
 
     Private Shared c2ccCache As New Dictionary(Of Color, ConsoleColor)
@@ -55,6 +60,13 @@
     Public Event ImageProcessed(sender As Object, e As EventArgs)
 
     Public Sub New()
+        mCanvasSize = New Size(80, 25)
+        mColorMode = ColorModes.GrayScale
+        mScanMode = ScanModes.Fast
+        mCharset = Charsets.Standard
+        mGrayScaleMode = GrayscaleModes.Average
+        mBackColor = Color.Black
+        mFont = New Font("Consolas", 12, GraphicsUnit.Pixel)
         SetCharSize()
     End Sub
 
@@ -154,12 +166,26 @@
             Return mFont
         End Get
         Set(value As Font)
-            mFont = Font
+            mFont = value
             SetCharSize()
             ProcessImage()
         End Set
     End Property
 
+    Public Property DitherColors As Integer
+        Get
+            Return mDitherColors
+        End Get
+        Set(value As Integer)
+            If value >= 2 Then
+                mDitherColors = value
+                ProcessImage()
+            Else
+                ' Throw New ArgumentOutOfRangeException($"{NameOf(DitherColors)} must be 2 or larger")
+            End If
+        End Set
+    End Property
+
     Public ReadOnly Property Canvas() As ASCIIChar()()
         Get
             Return mCanvas
@@ -167,9 +193,46 @@
     End Property
 
     Private Sub SetCharSize()
-        mCharSize = TextRenderer.MeasureText("X", mFont)
-        mCharSize.Width -= 8
-        mCharSize.Height -= 1
+        Dim IsBlack = Function(c As Color) As Boolean
+                          Return c.R = 0 AndAlso c.G = 0 AndAlso c.B = 0
+                      End Function
+
+        Using bmp As New DirectBitmap(100, 100)
+            Using g As Graphics = Graphics.FromImage(bmp)
+                g.InterpolationMode = Drawing2D.InterpolationMode.NearestNeighbor
+                g.PixelOffsetMode = Drawing2D.PixelOffsetMode.None
+                g.SmoothingMode = Drawing2D.SmoothingMode.None
+
+                g.Clear(Color.Black)
+                g.DrawString("â", mFont, Brushes.White, 0, 0)
+            End Using
+
+            Dim lt As Point
+            Dim rb As Point
+
+            For y As Integer = 0 To bmp.Height - 1
+                For x As Integer = 0 To bmp.Width - 1
+                    If Not IsBlack(bmp.Pixel(x, y)) Then
+                        lt = New Point(x, y)
+                        y = bmp.Height
+                        Exit For
+                    End If
+                Next
+            Next
+
+            For y As Integer = bmp.Height - 1 To 0 Step -1
+                For x As Integer = bmp.Width - 1 To 0 Step -1
+                    If Not IsBlack(bmp.Pixel(x, y)) Then
+                        rb = New Point(x, y)
+                        y = 0
+                        Exit For
+                    End If
+                Next
+            Next
+
+            mCharSize = New Size(rb.X - lt.X, rb.Y - lt.Y)
+            If mCharSize.Width > 1 Then mCharSize.Width -= 1
+        End Using
     End Sub
 
     Public Sub ProcessImage(Optional surfaceGraphics As Boolean = True)
@@ -178,11 +241,19 @@
         Dim sx As Integer
         Dim sy As Integer
 
-        Dim sizeChanged As Boolean = (lastCanvasSize <> mCanvasSize)
+        If lastCanvasSize <> mCanvasSize Then
+            lastCanvasSize = mCanvasSize
 
-        If sizeChanged Then
             If mSurface IsNot Nothing Then mSurface.Dispose()
             mSurface = New DirectBitmap(mCanvasSize.Width * CharSize.Width, mCanvasSize.Height * CharSize.Height)
+
+            ReDim mCanvas(mCanvasSize.Width - 1)
+            For x = 0 To mCanvasSize.Width - 1
+                ReDim mCanvas(x)(mCanvasSize.Height - 1)
+                For y = 0 To mCanvasSize.Height - 1
+                    mCanvas(x)(y) = New ASCIIChar(" ", Me.BackColor)
+                Next
+            Next
         End If
 
         If surfaceGraphics Then
@@ -195,18 +266,28 @@
         'scanStep.Height += mCanvasSize.Height Mod scanStep.Height
         Dim scanStepSize = scanStep.Width * scanStep.Height
 
-        If sizeChanged Then ReDim mCanvas(mCanvasSize.Width - 1)
-
-        For x = 0 To mCanvasSize.Width - 1
-            If sizeChanged Then ReDim mCanvas(x)(mCanvasSize.Height - 1)
-            For y = 0 To mCanvasSize.Height - 1
-                mCanvas(x)(y) = New ASCIIChar(" ", Me.BackColor)
-            Next
-        Next
-
+        ' Source color
         Dim r As Integer
         Dim g As Integer
         Dim b As Integer
+
+        ' Dithered Color
+        Dim dr As Integer
+        Dim dg As Integer
+        Dim db As Integer
+        Dim dColorFactor As Integer = mDitherColors - 1
+        Dim dFactor As Double = 255 / dColorFactor
+        Dim quantaError(3 - 1) As Double
+        Dim ApplyQuantaError = Sub(qx As Integer, qy As Integer, qr As Integer, qg As Integer, qb As Integer, w As Double)
+                                   If qx < 0 OrElse qx >= mCanvasSize.Width OrElse
+                                       qy < 0 OrElse qy >= mCanvasSize.Height Then Exit Sub
+                                   qr += quantaError(0) * w
+                                   qg += quantaError(1) * w
+                                   qb += quantaError(2) * w
+                                   mCanvas(qx)(qy) = New ASCIIChar(ColorToASCII(qr, qg, qb), Color.FromArgb(qr, qg, qb))
+                               End Sub
+
+        ' For gray scale modes
         Dim gray As Integer
 
         Dim offset As Integer
@@ -249,6 +330,27 @@
                         mCanvas(sx)(sy) = New ASCIIChar(ColorToASCII(r, g, b), Color.FromArgb(gray, gray, gray))
                     Case ColorModes.Color
                         mCanvas(sx)(sy) = New ASCIIChar(ColorToASCII(r, g, b), Color.FromArgb(r, g, b))
+                    Case ColorModes.DitheredGrayScale, ColorModes.DitheredColor
+                        ' https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering
+                        If mColorMode = ColorModes.DitheredGrayScale Then
+                            r = ToGrayScale(r, g, b)
+                            g = r
+                            b = r
+                        End If
+                        dr = Math.Round(dColorFactor * r / 255) * dFactor
+                        dg = Math.Round(dColorFactor * g / 255) * dFactor
+                        db = Math.Round(dColorFactor * b / 255) * dFactor
+
+                        mCanvas(sx)(sy) = New ASCIIChar(ColorToASCII(dr, dg, db), Color.FromArgb(dr, dg, db))
+
+                        quantaError = {Math.Max(0, r - dr),
+                                       Math.Max(0, g - dg),
+                                       Math.Max(0, b - db)}
+
+                        ApplyQuantaError(sx + 1, sy, dr, dg, db, 7 / 16)
+                        ApplyQuantaError(sx - 1, sy + 1, dr, dg, db, 3 / 16)
+                        ApplyQuantaError(sx, sy + 1, dr, dg, db, 5 / 16)
+                        ApplyQuantaError(sx + 1, sy + 1, dr, dg, db, 1 / 16)
                 End Select
 
                 If surfaceGraphics Then
@@ -260,8 +362,6 @@
         Next
         If surfaceGraphics Then Me.surfaceGraphics.Dispose()
 
-        lastCanvasSize = mCanvasSize
-
         RaiseEvent ImageProcessed(Me, New EventArgs())
     End Sub
 
@@ -269,21 +369,21 @@
         Return ColorToASCII(color.R, color.G, color.B)
     End Function
 
+    Private Function ColorToASCII(r As Integer, g As Integer, b As Integer) As Char
+        Return activeChars(Math.Floor(ToGrayScale(r, g, b) / (256 / activeChars.Length)))
+    End Function
+
     Private Function ToGrayScale(r As Integer, g As Integer, b As Integer) As Double
         Select Case mGrayScaleMode
             Case GrayscaleModes.Accuarte
                 Return r * 0.2126 + g * 0.7152 + b * 0.0722
             Case GrayscaleModes.Average
-                Return r * 1 / 3 + g * 1 / 3 + b * 1 / 3
+                Return r / 3 + g / 3 + b / 3
             Case Else
                 Return 0
         End Select
     End Function
 
-    Private Function ColorToASCII(r As Integer, g As Integer, b As Integer) As Char
-        Return activeChars(Math.Floor(ToGrayScale(r, g, b) / (256 / activeChars.Length)))
-    End Function
-
     Public Shared Function ToConsoleColor(c As Color) As ConsoleColor
         Dim d As Double
         Dim minD As Double = Double.MaxValue
diff --git a/x8086NetEmu/Adapters/Video/VGA/VGAAdapter.vb b/x8086NetEmu/Adapters/Video/VGA/VGAAdapter.vb
index eaeb57d..3b48350 100644
--- a/x8086NetEmu/Adapters/Video/VGA/VGAAdapter.vb
+++ b/x8086NetEmu/Adapters/Video/VGA/VGAAdapter.vb
@@ -1,4 +1,8 @@
-ï»¿Public MustInherit Class VGAAdapter
+ï»¿' http://www.osdever.net/FreeVGA/vga/vgatext.htm
+' https://pdos.csail.mit.edu/6.828/2007/readings/hardware/vgadoc/VGABIOS.TXT
+' http://stanislavs.org/helppc/ports.html
+
+Public MustInherit Class VGAAdapter
     Inherits CGAAdapter
 
     Private VGABasePalette() As Color = {
@@ -260,33 +264,29 @@
         Color.FromArgb(0, 0, 0)
     }
 
-    Private mVRAM(&H40000 - 1) As Byte
-    Public VGA_SC(&H100 - 1) As UInt16
-    Protected VGA_CRTC(&H100 - 1) As UInt16
-    Protected VGA_ATTR(&H100 - 1) As UInt16
-    Protected VGA_GC(&H100 - 1) As UInt16
+    Protected VGA_SC(&HFF - 1) As Byte
+    Protected VGA_ATTR(&HFF - 1) As Byte
+    Protected VGA_CRTC(&HFF - 1) As Byte
+    Private ReadOnly VGA_GC(&HFF - 1) As Byte
+    Private ReadOnly VGA_Latch(4 - 1) As Byte
 
     Private flip3C0 As Boolean = False
-    Private VGA_Latch(4 - 1) As Byte
     Private stateDAC As Byte
     Private latchReadRGB As Byte
     Private latchReadPal As Byte
     Private latchWriteRGB As Byte
     Private latchWritePal As Byte
-    Protected portRAM(&H10000 - 1) As Byte
-    Private tempRGB As UInt32
-    Private mVGAPalette(VGABasePalette.Length - 1) As Color
+
+    Protected portRAM(&HFFF - 1) As Byte
+    Protected vgaPalette(VGABasePalette.Length - 1) As Color
     Private mUseVRAM As Boolean
 
-    'Private port3DA As UInt32
-    Private Const planeSize As UInt32 = &H10000
-    Private lastScanLineTick As Long
-    Private ReadOnly scanLineTiming As Long = (Scheduler.BASECLOCK / X8086.KHz) / 31500
-    Private curScanLine As Long
-    Private cursorPosition As UInt32
-    Private blinkCounter As Integer
+    Protected Const MEMSIZE As UInt32 = &H100000UI
+    Protected vRAM(MEMSIZE - 1) As Byte
 
-    Private ReadOnly useROM As Boolean = True ' FIXME: Enabling ROM support breaks CGA compatibility
+    Private Const planeSize As UInt32 = &H10000
+    Private tempRGB As UInt32
+    Private tmpVal As Byte
 
     Private mCPU As X8086
 
@@ -294,87 +294,70 @@
     '              http://webpages.charter.net/danrollins/techhelp/0114.HTM
     ' Ports: http://stanislavs.org/helppc/ports.html
 
-    Public Sub New(cpu As X8086)
-        MyBase.New(cpu)
+    Public Sub New(cpu As X8086, Optional useInternalTimer As Boolean = True, Optional enableWebUI As Boolean = False)
+        MyBase.New(cpu, useInternalTimer, enableWebUI)
         mCPU = cpu
 
-        If useROM Then
-            'mCPU.LoadBIN("roms\ET4000(1-10-92).BIN", &HC000, &H0)
-            'mCPU.LoadBIN("..\..\Other Emulators & Resources\PCemV0.7\roms\TRIDENT.BIN", &HC000, &H0)
-            mCPU.LoadBIN("roms\ET4000(4-7-93).BIN", &HC000, &H0)
-        Else
-            'mCPU.RAM(&H410) = &H41
-            mCPU.TryAttachHook(New X8086.MemHandler(Function(address As UInt32, ByRef value As UInt16, mode As X8086.MemHookMode) As Boolean
-                                                        If mode = X8086.MemHookMode.Read AndAlso address = &H410 Then
-                                                            value = &H41
-                                                            Return True
-                                                        Else
+        MyBase.vidModeChangeFlag = 0 ' Prevent the CGA adapter from changing video modes
+
+        mCPU.TryAttachHook(New X8086.MemHandler(Function(address As UInt32, ByRef value As UInt16, mode As X8086.MemHookMode) As Boolean
+                                                    Select Case mMainMode
+                                                        Case MainModes.Text
+                                                            If address >= mStartTextVideoAddress AndAlso address < mEndTextVideoAddress Then
+                                                                Select Case mode
+                                                                    Case X8086.MemHookMode.Read
+                                                                        value = VideoRAM(address - mStartTextVideoAddress)
+                                                                    Case X8086.MemHookMode.Write
+                                                                        VideoRAM(address - mStartTextVideoAddress) = value
+                                                                End Select
+                                                                Return True
+                                                            End If
+                                                            Return False
+                                                        Case MainModes.Graphics
+                                                            If address >= mStartGraphicsVideoAddress AndAlso address < mEndGraphicsVideoAddress AndAlso (VGA_SC(4) And 6) <> 0 Then
+                                                                Select Case mode
+                                                                    Case X8086.MemHookMode.Read
+                                                                        value = VideoRAM(address - mStartGraphicsVideoAddress)
+                                                                    Case X8086.MemHookMode.Write
+                                                                        VideoRAM(address - mStartGraphicsVideoAddress) = value
+                                                                End Select
+                                                                Return True
+                                                            End If
                                                             Return False
-                                                        End If
-                                                    End Function))
-        End If
+                                                    End Select
+                                                    Return False
+                                                End Function))
+
+        'mCPU.LoadBIN("roms\ET4000(1-10-92).BIN", &HC000, &H0)
+        'mCPU.LoadBIN("..\..\Other Emulators & Resources\PCemV0.7\roms\TRIDENT.BIN", &HC000, &H0)
+        mCPU.LoadBIN("roms\ET4000(4-7-93).BIN", &HC000, &H0)
 
         ValidPortAddress.Clear()
-        ValidPortAddress.Add(&H3BA) ' Dummy port to speed ET4000 ROM initialization
-        ValidPortAddress.Add(&H3B8) ' Monochrome support
         For i As UInt32 = &H3C0 To &H3CF ' EGA/VGA
             ValidPortAddress.Add(i)
         Next
-        For i As UInt32 = &H3D0 To &H3DF ' CGA Adapter
-            ValidPortAddress.Add(i)
-        Next
+        ValidPortAddress.Add(&H3BA)
+        ValidPortAddress.Add(&H3B8)
+        'ValidPortAddress.Add(&H3D4)
+        'ValidPortAddress.Add(&H3D5)
+        ValidPortAddress.Add(&H3DA)
 
         For i As Integer = 0 To VGABasePalette.Length - 1
-            mVGAPalette(i) = VGABasePalette(i)
+            vgaPalette(i) = VGABasePalette(i)
         Next
 
         mCPU.TryAttachHook(&H10, New X8086.IntHandler(Function() As Boolean
                                                           If mCPU.Registers.AH = 0 OrElse mCPU.Registers.AH = &H10 Then
                                                               VideoMode = mCPU.Registers.AX
-                                                              'If mCPU.Registers.AH = &H10 Then Return False
+                                                              If mCPU.Registers.AH = &H10 Then Return False
                                                               Return True
                                                           ElseIf mCPU.Registers.AH = &H1A And mCPU.Registers.AL = 0 Then ' Get display combination code (ps, vga/mcga)
                                                               mCPU.Registers.AL = &H1A ' http://stanislavs.org/helppc/int_10-1a.html
                                                               mCPU.Registers.BL = &H8
                                                               Return True
                                                           End If
-
                                                           Return False
                                                       End Function))
-
-        mCPU.TryAttachHook(New X8086.MemHandler(Function(address As UInt32, ByRef value As UInt16, mode As X8086.MemHookMode) As Boolean
-                                                    If mUseVRAM AndAlso (address >= mStartGraphicsVideoAddress AndAlso address <= mStartGraphicsVideoAddress + &H1FFFF) Then
-                                                        If mVideoMode = &H13 AndAlso (VGA_SC(4) And 6) = 0 Then ' Mode 13h with plane mode
-                                                            Return False
-                                                        Else
-                                                            If mode = X8086.MemHookMode.Read Then
-                                                                value = Read(address - mStartGraphicsVideoAddress)
-                                                            Else
-                                                                Write(address - mStartGraphicsVideoAddress, value)
-                                                            End If
-                                                            Return True
-                                                        End If
-                                                    Else
-                                                        Return False
-                                                    End If
-                                                End Function))
-
-        'mCPU.TryAttachHook(&h1c, New X8086.IntHandler(Function()
-        '                                               Dim t As Long = mCPU.Sched.CurrentTime
-        '                                               If t >= (lastScanLineTick + scanLineTiming) Then
-        '                                                   curScanLine = (curScanLine + 1) Mod 525
-        '                                                   If curScanLine > 479 Then
-        '                                                       port3DA = 8
-        '                                                   ElseIf (curScanLine And 1) <> 0 Then
-        '                                                       port3DA = port3DA Or 1
-        '                                                   End If
-        '                                                   lastScanLineTick = t
-        '                                               End If
-
-        '                                               Return False
-        '                                           End Function))
-
-        lastScanLineTick = 0
     End Sub
 
     Public ReadOnly Property UseVRAM As Boolean
@@ -383,16 +366,21 @@
         End Get
     End Property
 
-    Public ReadOnly Property VGAPalette(index As Integer) As Color
-        Get
-            Return mVGAPalette(index)
-        End Get
-    End Property
-
-    Public ReadOnly Property VRAM(address As UInt32) As UInt32
+    Public Property VideoRAM(address As UInt16) As Byte
         Get
-            Return mVRAM(address)
+            If mUseVRAM Then
+                Return Read(address)
+            Else
+                Return mCPU.Memory(address + If(mMainMode = MainModes.Text, mStartTextVideoAddress, mStartGraphicsVideoAddress))
+            End If
         End Get
+        Set(value As Byte)
+            If mUseVRAM Then
+                Write(address, value)
+            Else
+                mCPU.Memory(address + If(mMainMode = MainModes.Text, mStartTextVideoAddress, mStartGraphicsVideoAddress)) = value
+            End If
+        End Set
     End Property
 
     Public Overrides Property VideoMode As UInt32
@@ -400,7 +388,7 @@
             Return mVideoMode
         End Get
         Set(value As UInt32)
-            Select Case value >> 8
+            Select Case value >> 8 ' Mode is in AH
                 Case 0 ' Set video mode
                     value = value And &H7F
                     mVideoMode = value And &H7F ' http://stanislavs.org/helppc/ports.html
@@ -427,6 +415,7 @@
                             mMainMode = MainModes.Text
                             mPixelsPerByte = 4
                             mUseVRAM = False
+                            portRAM(&H3D8) = portRAM(&H3D8) And &HFE
 
                         Case 2 ' 80x25 Mono Text
                             mStartTextVideoAddress = &HB8000
@@ -434,9 +423,10 @@
                             mTextResolution = New Size(80, 25)
                             mVideoResolution = New Size(720, 400)
                             mCellSize = New Size(9, 16)
-                            mMainMode = MainModes.Text
+                            mMainMode = MainModes.Graphics
                             mPixelsPerByte = 4
                             mUseVRAM = False
+                            portRAM(&H3D8) = portRAM(&H3D8) And &HFE
 
                         Case 3 ' 80x25 Color Text
                             mStartTextVideoAddress = &HB8000
@@ -447,6 +437,7 @@
                             mMainMode = MainModes.Text
                             mPixelsPerByte = 4
                             mUseVRAM = False
+                            portRAM(&H3D8) = portRAM(&H3D8) And &HFE
 
                         Case 4, 5 ' 320x200 4 Colors
                             mStartTextVideoAddress = &HB8000
@@ -457,11 +448,7 @@
                             mMainMode = MainModes.Graphics
                             mPixelsPerByte = 4
                             mUseVRAM = False
-                            If value And &HF = 4 Then
-                                portRAM(&H3D9) = 48
-                            Else
-                                portRAM(&H3D9) = 0
-                            End If
+                            portRAM(&H3D9) = If(value And &HF = 4, 48, 0)
 
                         Case 6 ' 640x200 2 Colors
                             mStartTextVideoAddress = &HB8000
@@ -472,6 +459,7 @@
                             mMainMode = MainModes.Graphics
                             mPixelsPerByte = 2
                             mUseVRAM = False
+                            portRAM(&H3D8) = portRAM(&H3D8) And &HFE
 
                         Case 7 ' 640x200 2 Colors
                             mStartTextVideoAddress = &HB0000
@@ -492,6 +480,7 @@
                             mMainMode = MainModes.Graphics
                             mPixelsPerByte = 4
                             mUseVRAM = False
+                            portRAM(&H3D8) = portRAM(&H3D8) And &HFE
 
                         Case &HD ' 320x200 16 Colors
                             mStartTextVideoAddress = &HA0000
@@ -502,6 +491,7 @@
                             mMainMode = MainModes.Graphics
                             mPixelsPerByte = 4
                             mUseVRAM = True
+                            portRAM(&H3D8) = portRAM(&H3D8) And &HFE
 
                         Case &HE ' 640x200 16 Colors
                             mStartTextVideoAddress = &HA0000
@@ -532,6 +522,7 @@
                             mMainMode = MainModes.Graphics
                             mPixelsPerByte = 4
                             mUseVRAM = True
+                            portRAM(&H3D8) = portRAM(&H3D8) And &HFE
 
                         Case &H13
                             mStartTextVideoAddress = &HA0000
@@ -542,6 +533,7 @@
                             mMainMode = MainModes.Graphics
                             mPixelsPerByte = 4
                             mUseVRAM = True
+                            portRAM(&H3D8) = portRAM(&H3D8) And &HFE
 
                         Case 127 ' 90x25 Mono Text
                             mStartTextVideoAddress = &HB0000
@@ -551,6 +543,7 @@
                             mCellSize = New Size(8, 16)
                             mMainMode = MainModes.Text
                             mPixelsPerByte = 1
+                            portRAM(&H3D8) = portRAM(&H3D8) And &HFE
 
                             'Case &H30 ' 800x600 Color Tseng ET3000/4000 chipset
                             '    mStartTextVideoAddress = &HA0000
@@ -563,219 +556,136 @@
                             '    portRAM(&H3D8) = portRAM(&H3D8) And &HFE
 
                         Case Else
-                            mStartTextVideoAddress = &HB0000
-                            mStartGraphicsVideoAddress = &HB0000
-                            mTextResolution = New Size(80, 25)
-                            mVideoResolution = New Size(640, 200)
-                            mCellSize = New Size(8, 8)
-                            mMainMode = MainModes.Text
-                            mPixelsPerByte = 1
-                            mUseVRAM = False
+                            'mStartTextVideoAddress = &HB0000
+                            'mStartGraphicsVideoAddress = &HB0000
+                            'mTextResolution = New Size(132, 25)
+                            'mVideoResolution = New Size(640, 200)
+                            'mCellSize = New Size(8, 8)
+                            'mMainMode = MainModes.Text
+                            'mPixelsPerByte = 1
+                            'mUseVRAM = False
 
                     End Select
 
                     mCellSize = New Size(8, 16) ' Temporary hack until we can stretch the fonts' bitmaps
-                    portRAM(&H3D8) = portRAM(&H3D8) And &HFE
-                    mCPU.RAM(&H449) = mVideoMode
-                    mCPU.RAM(&H44A) = mTextResolution.Width
-                    mCPU.RAM(&H44B) = 0
-                    mCPU.RAM(&H484) = mTextResolution.Height - 1
-                    mCPU.RAM16(&H40, &H63) = &H3D4 ' Without and without using a BIOS INT 10,8/9/10 fails to work
-                    mCursorCol = 0
-                    mCursorRow = 0
-                    cursorPosition = 0
-
-                    If (value And &H80) = 0 Then
-                        Array.Clear(mCPU.Memory, &HA0000, &H1FFFF)
-                        Array.Clear(mVRAM, 0, mVRAM.Length)
-                    End If
+                    mCPU.Memory(&H449) = mVideoMode
+                    mCPU.Memory(&H44A) = mTextResolution.Width
+                    mCPU.Memory(&H44B) = 0
+                    mCPU.Memory(&H484) = mTextResolution.Height - 1
+                    mCPU.Memory(&H463) = &H3D4 ' With and without a BIOS INT 10,8/9/10 fails to work
 
                     InitVideoMemory(False)
 
-                Case &H10 ' VGA DAC functions
-                    Select Case value And &HFF
-                        Case &H10 ' Set individual DAC register
-                            mVGAPalette(mCPU.Registers.BX) = Color.FromArgb(RGBToUInt((mCPU.Registers.DH And &H3F) << 2,
-                                                                                      (mCPU.Registers.CH And &H3F) << 2,
-                                                                                      (mCPU.Registers.CL And &H3F) << 2))
-                        Case &H12 ' Set block of DAC registers
-                            Dim addr As Integer = mCPU.Registers.ES * 16 + mCPU.Registers.DX
-                            For n As Integer = mCPU.Registers.BX To mCPU.Registers.BX + mCPU.Registers.CX - 1
-                                mVGAPalette(n) = Color.FromArgb(RGBToUInt(mCPU.RAM(addr + 0) << 2,
-                                                                          mCPU.RAM(addr + 1) << 2,
-                                                                          mCPU.RAM(addr + 2) << 2))
-                                addr += 3
-                            Next
-
-                    End Select
-
+                Case &H10 ' Set individual DAC register
+                    vgaPalette(mCPU.Registers.BX Mod 256) = Color.FromArgb(RGBToUInt(CUInt(mCPU.Registers.DH And &H3F) << 2,
+                                                                                     CUInt(mCPU.Registers.CH And &H3F) << 2,
+                                                                                     CUInt(mCPU.Registers.CL And &H3F) << 2))
+                Case &H12 ' Set block of DAC registers
+                    Dim addr As Integer = CUInt(mCPU.Registers.ES) * 16UI + mCPU.Registers.DX
+                    For n As Integer = mCPU.Registers.BX To mCPU.Registers.BX + mCPU.Registers.CX - 1
+                        vgaPalette(n) = Color.FromArgb(RGBToUInt(mCPU.Memory(addr + 0) << 2,
+                                                                 mCPU.Memory(addr + 1) << 2,
+                                                                 mCPU.Memory(addr + 2) << 2))
+                        addr += 3
+                    Next
             End Select
         End Set
     End Property
 
-    Private Function RGBToUInt(r As UInt32, g As UInt32, b As UInt32) As UInt32
+    Private Function RGBToUInt(r As UInt16, g As UInt16, b As UInt16) As UInt16
         Return r Or (g << 8) Or (b << 16)
     End Function
 
-    Public Overrides Function [In](port As UInt32) As UInt32
+    Public Overrides Function [In](port As UInt32) As UInt16
         Select Case port
-            Case &H3BA
-                Dim t As Long = mCPU.Sched.CurrentTime
-                Dim hRetrace As Boolean = (t Mod ht) <= (ht \ 10)
-                Dim vRetrace As Boolean = (t Mod vt) <= (vt \ 10)
-
-                Return If(hRetrace, 1, 0) Or If(vRetrace, 8, 0)
+            Case &H3C1 : Return VGA_ATTR(portRAM(&H3C0))
 
-            Case &H3C1
-                Return VGA_ATTR(portRAM(&H3C0))
+            Case &H3C5 : Return VGA_SC(portRAM(&H3C4))
 
-            Case &H3C5
-                Return VGA_SC(portRAM(&H3C4))
+            Case &H3D5 : Return VGA_CRTC(portRAM(&H3D4))
 
-            Case &H3D5
-                Return VGA_CRTC(portRAM(&H3D4)) And &H1F
+            Case &H3C7 : Return stateDAC
 
-            Case &H3C7
-                Return stateDAC
-
-            Case &H3C8
-                Return latchReadPal
+            Case &H3C8 : Return latchReadPal
 
             Case &H3C9
-                latchReadRGB += 1
-                Select Case (latchReadRGB - 1)
-                    Case 0 ' R
-                        Return (mVGAPalette(latchReadPal).ToArgb() >> 2) And &H3F
+                Select Case latchReadRGB
+                    Case 0 ' B
+                        tmpVal = (vgaPalette(latchReadPal).ToArgb() >> 2)
                     Case 1 ' G
-                        Return (mVGAPalette(latchReadPal).ToArgb() >> 10) And &H3F
-                    Case 2 ' B
-                        latchReadRGB = 0
+                        tmpVal = (vgaPalette(latchReadPal).ToArgb() >> 10)
+                    Case 2 ' R
+                        tmpVal = (vgaPalette(latchReadPal).ToArgb() >> 18)
                         latchReadPal += 1
-                        Return (mVGAPalette(latchReadPal - 1).ToArgb() >> 18) And &H3F
+                        latchReadRGB = -1
                 End Select
+                latchReadRGB = (latchReadRGB + 1) Mod 3
+                Return tmpVal And &H3F
 
-            Case &H3DA ' Using the CGA timing code appears to solve many problems
+            Case &H3DA
                 flip3C0 = True ' https://wiki.osdev.org/VGA_Hardware#Port_0x3C0
-
-                Dim t As Long = mCPU.Sched.CurrentTime
-                Dim hRetrace As Boolean = (t Mod ht) <= (ht \ 10)
-                Dim vRetrace As Boolean = (t Mod vt) <= (vt \ 10)
-
-                Return (If(hRetrace, 1, 0) Or If(vRetrace, 8, 0))
-                'Return port3DA
-
-                'Case >= &H3D0
-                '    Return MyBase.In(port)
+                Return MyBase.In(port)
 
         End Select
 
         Return portRAM(port)
     End Function
 
-    Public Overrides Sub Out(port As UInt32, value As UInt32)
-        value = value And &HFF
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
         Select Case port
-            Case &H3B8
-                If ((value And 2) = 2) AndAlso VideoMode <> 127 Then
-                    VideoMode = 127
-                End If
-
             Case &H3C0 ' https://wiki.osdev.org/VGA_Hardware#Port_0x3C0
                 If flip3C0 Then
-                    portRAM(&H3C0) = value
+                    portRAM(port) = value
                 Else
-                    VGA_ATTR(portRAM(&H3C0)) = value
-                    ' This doesn't work when using ROM
-                    'If portRAM(&H3C0) = &H10 Then mBlinkCharOn = (value And &B100) <> 0
+                    VGA_ATTR(portRAM(port)) = value
                 End If
                 flip3C0 = Not flip3C0
 
             Case &H3C4 ' Sequence controller index
-                portRAM(&H3C4) = value
-                ' This manually drives the VGA_SC sequence which allows Wolf8086 initial screen to show correctly
-                ' Which means that, for some reason, after setting the index, the data is not being written to the register (3D5)
-                'If value = 2 Then
-                '    If c > 2 Then
-                '        VGA_SC(portRAM(&H3C4)) = k(ki)
-                '        ki = (ki + 1) Mod k.Length
-                '    End If
-                '    c += 1
-                'End If
+                portRAM(port) = value
 
             Case &H3C5 ' Sequence controller data
                 VGA_SC(portRAM(&H3C4)) = value
-                ' This doesn't work when using ROM
-                'If portRAM(&H3C4) = &H1 Then mVideoEnabled = (value And &B100000) <> 0
 
             Case &H3C7 ' Color index register (read operations)
                 latchReadPal = value
                 latchReadRGB = 0
                 stateDAC = 0
-                'latchWritePal = (value + 1) And &HFF
 
             Case &H3C8 ' Color index register (write operations)
                 latchWritePal = value
                 latchWriteRGB = 0
-                tempRGB = 0
                 stateDAC = 3
-                'latchReadPal = (value - 1) And &HFF
 
             Case &H3C9 ' RGB data register
+                value = value And &H3F
                 Select Case latchWriteRGB
                     Case 0 ' R
-                        tempRGB = value << 2
+                        tempRGB = CUInt(value) << 18
                     Case 1 ' G
-                        tempRGB = tempRGB Or (value << 10)
+                        tempRGB = tempRGB Or (CUInt(value) << 10)
                     Case 2 ' B
-                        mVGAPalette(latchWritePal) = Color.FromArgb(tempRGB Or (value << 18))
+                        vgaPalette(latchWritePal) = Color.FromArgb(tempRGB Or (CUInt(value) << 2))
                         latchWritePal += 1
                 End Select
                 latchWriteRGB = (latchWriteRGB + 1) Mod 3
 
             Case &H3D4 ' 6845 index register
-                portRAM(&H3D4) = value
+                portRAM(port) = value
+                MyBase.Out(port, value)
 
             Case &H3D5 ' 6845 data register
-                VGA_CRTC(portRAM(&H3D4)) = value
-
-                Select Case portRAM(&H3D4) ' https://github.com/mamedev/mame/blob/989acfc3163009477a6c72587056f1d303e23bb9/src/devices/video/mc6845.cpp#L203
-                    Case &HA
-                        UpdateCursorState()
-                        mCursorStart = value And &H1F ' &H7F
-                    Case &HB
-                        mCursorEnd = value And &H1F
-                    Case &HE : cursorPosition = ((value And &H3F) << 8) Or (cursorPosition And &HFF)
-                    Case &HF : cursorPosition = ((value And &HFF) << 0) Or (cursorPosition And &HFF00)
-                End Select
-                cursorPosition = cursorPosition And &HFFFF
-                mCursorRow = cursorPosition / mTextResolution.Width
-                mCursorCol = cursorPosition Mod mTextResolution.Width
+                VGA_CRTC(portRAM(&H3D4)) = value And &H1F
+                MyBase.Out(port, value)
 
-            Case &H3CE
-                VGA_GC(portRAM(&H3CE)) = value And &HF
+            Case &H3CE ' VGA graphics index
+                portRAM(port) = value Mod &H8 ' FIXME: This is one fugly hack!
 
             Case &H3CF
                 VGA_GC(portRAM(&H3CE)) = value
 
-                'Case >= &H3D0
-                '    MyBase.Out(port, value)
-
             Case Else
                 portRAM(port) = value
-
-        End Select
-    End Sub
-
-    Protected Sub UpdateCursorState()
-        Dim lastBlinkCount As Integer = blinkCounter
-        blinkCounter += 1
-        blinkCounter = blinkCounter Mod &HFF
-
-        Select Case VGA_CRTC(portRAM(&H3D4)) And &H60
-            Case 0 : mCursorVisible = True
-            Case &H20 : mCursorVisible = False
-            Case &H40 : If (lastBlinkCount And &H10) <> (blinkCounter And &H10) Then mCursorVisible = Not mCursorVisible
-            Case &H60 : If (lastBlinkCount And &H20) <> (blinkCounter And &H20) Then mCursorVisible = Not mCursorVisible
         End Select
     End Sub
 
@@ -809,6 +719,11 @@
         End Get
     End Property
 
+    Public Overrides Sub Reset()
+        MyBase.Reset()
+        InitVideoMemory(False)
+    End Sub
+
     Protected Overrides Sub InitVideoMemory(clearScreen As Boolean)
         If Not isInit Then Exit Sub
 
@@ -821,75 +736,56 @@
 
     Public Overrides Sub Write(address As UInt32, value As UInt16)
         Dim curValue As Byte
-        value = ShiftVGA(value)
 
-        Select Case (VGA_GC(5) And 3)
+        Select Case VGA_GC(5) And 3
             Case 0
+                value = ShiftVGA(value)
+
                 If (VGA_SC(2) And 1) <> 0 Then
                     If (VGA_GC(1) And 1) <> 0 Then
-                        If (VGA_GC(0) And 1) <> 0 Then
-                            curValue = 255
-                        Else
-                            curValue = 0
-                        End If
+                        curValue = If((VGA_GC(0) And 1) <> 0, 255, 0)
                     Else
                         curValue = value
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(0))
-                    curValue = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(0))
-                    mVRAM(address + planeSize * 0) = curValue
+                    vRAM(address + planeSize * 0) = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(0))
                 End If
 
                 If (VGA_SC(2) And 2) <> 0 Then
                     If (VGA_GC(1) And 2) <> 0 Then
-                        If (VGA_GC(0) And 2) <> 0 Then
-                            curValue = 255
-                        Else
-                            curValue = 0
-                        End If
+                        curValue = If((VGA_GC(0) And 2) <> 0, 255, 0)
                     Else
                         curValue = value
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(1))
-                    curValue = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(1))
-                    mVRAM(address + planeSize * 1) = curValue
+                    vRAM(address + planeSize * 1) = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(1))
                 End If
 
                 If (VGA_SC(2) And 4) <> 0 Then
                     If (VGA_GC(1) And 4) <> 0 Then
-                        If (VGA_GC(0) And 4) <> 0 Then
-                            curValue = 255
-                        Else
-                            curValue = 0
-                        End If
+                        curValue = If((VGA_GC(0) And 4) <> 0, 255, 0)
                     Else
                         curValue = value
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(2))
-                    curValue = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(2))
-                    mVRAM(address + planeSize * 2) = curValue
+                    vRAM(address + planeSize * 2) = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(2))
                 End If
 
                 If (VGA_SC(2) And 8) <> 0 Then
                     If (VGA_GC(1) And 8) <> 0 Then
-                        If (VGA_GC(0) And 8) <> 0 Then
-                            curValue = 255
-                        Else
-                            curValue = 0
-                        End If
+                        curValue = If((VGA_GC(0) And 8) <> 0, 255, 0)
                     Else
                         curValue = value
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(3))
-                    curValue = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(3))
-                    mVRAM(address + planeSize * 3) = curValue
+                    vRAM(address + planeSize * 3) = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(3))
                 End If
 
             Case 1
-                If (VGA_SC(2) And 1) <> 0 Then mVRAM(address + planeSize * 0) = VGA_Latch(0)
-                If (VGA_SC(2) And 2) <> 0 Then mVRAM(address + planeSize * 1) = VGA_Latch(1)
-                If (VGA_SC(2) And 4) <> 0 Then mVRAM(address + planeSize * 2) = VGA_Latch(2)
-                If (VGA_SC(2) And 8) <> 0 Then mVRAM(address + planeSize * 3) = VGA_Latch(3)
+                If (VGA_SC(2) And 1) <> 0 Then vRAM(address + planeSize * 0) = VGA_Latch(0)
+                If (VGA_SC(2) And 2) <> 0 Then vRAM(address + planeSize * 1) = VGA_Latch(1)
+                If (VGA_SC(2) And 4) <> 0 Then vRAM(address + planeSize * 2) = VGA_Latch(2)
+                If (VGA_SC(2) And 8) <> 0 Then vRAM(address + planeSize * 3) = VGA_Latch(3)
 
             Case 2
                 If (VGA_SC(2) And 1) <> 0 Then
@@ -904,7 +800,7 @@
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(0))
                     curValue = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(0))
-                    mVRAM(address + planeSize * 0) = curValue
+                    vRAM(address + planeSize * 0) = curValue
                 End If
 
                 If (VGA_SC(2) And 2) <> 0 Then
@@ -919,7 +815,7 @@
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(1))
                     curValue = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(1))
-                    mVRAM(address + planeSize * 1) = curValue
+                    vRAM(address + planeSize * 1) = curValue
                 End If
 
                 If (VGA_SC(2) And 4) <> 0 Then
@@ -934,7 +830,7 @@
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(2))
                     curValue = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(2))
-                    mVRAM(address + planeSize * 2) = curValue
+                    vRAM(address + planeSize * 2) = curValue
                 End If
 
                 If (VGA_SC(2) And 8) <> 0 Then
@@ -949,11 +845,12 @@
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(3))
                     curValue = ((Not VGA_GC(8)) And curValue) Or (VGA_SC(8) And VGA_Latch(3))
-                    mVRAM(address + planeSize * 3) = curValue
+                    vRAM(address + planeSize * 3) = curValue
                 End If
 
             Case 3
-                Dim tmp As UInt32 = value And VGA_GC(8)
+                tmpVal = value And VGA_GC(8)
+                value = ShiftVGA(value)
 
                 If (VGA_SC(2) And 1) <> 0 Then
                     If (VGA_GC(0) And 1) <> 0 Then
@@ -964,8 +861,8 @@
                         End If
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(0))
-                    curValue = ((Not tmp) And curValue) Or (tmp And VGA_Latch(0))
-                    mVRAM(address + planeSize * 0) = curValue
+                    curValue = ((Not tmpVal) And curValue) Or (tmpVal And VGA_Latch(0))
+                    vRAM(address + planeSize * 0) = curValue
                 End If
 
                 If (VGA_SC(2) And 2) <> 0 Then
@@ -977,8 +874,8 @@
                         End If
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(1))
-                    curValue = ((Not tmp) And curValue) Or (tmp And VGA_Latch(1))
-                    mVRAM(address + planeSize * 1) = curValue
+                    curValue = ((Not tmpVal) And curValue) Or (tmpVal And VGA_Latch(1))
+                    vRAM(address + planeSize * 1) = curValue
                 End If
 
                 If (VGA_SC(2) And 4) <> 0 Then
@@ -990,8 +887,8 @@
                         End If
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(2))
-                    curValue = ((Not tmp) And curValue) Or (tmp And VGA_Latch(2))
-                    mVRAM(address + planeSize * 2) = curValue
+                    curValue = ((Not tmpVal) And curValue) Or (tmpVal And VGA_Latch(2))
+                    vRAM(address + planeSize * 2) = curValue
                 End If
 
                 If (VGA_SC(2) And 8) <> 0 Then
@@ -1003,27 +900,26 @@
                         End If
                     End If
                     curValue = LogicVGA(curValue, VGA_Latch(3))
-                    curValue = ((Not tmp) And curValue) Or (tmp And VGA_Latch(3))
-                    mVRAM(address + planeSize * 3) = curValue
+                    curValue = ((Not tmpVal) And curValue) Or (tmpVal And VGA_Latch(3))
+                    vRAM(address + planeSize * 3) = curValue
                 End If
         End Select
     End Sub
 
+#Disable Warning BC42353
     Public Overrides Function Read(address As UInt32) As UInt16
-        VGA_Latch(0) = mVRAM(address + planeSize * 0)
-        VGA_Latch(1) = mVRAM(address + planeSize * 1)
-        VGA_Latch(2) = mVRAM(address + planeSize * 2)
-        VGA_Latch(3) = mVRAM(address + planeSize * 3)
-
-        If (VGA_SC(2) And 1) <> 0 Then Return mVRAM(address + planeSize * 0)
-        If (VGA_SC(2) And 2) <> 0 Then Return mVRAM(address + planeSize * 1)
-        If (VGA_SC(2) And 4) <> 0 Then Return mVRAM(address + planeSize * 2)
-        If (VGA_SC(2) And 8) <> 0 Then Return mVRAM(address + planeSize * 3)
-
-        Return 0
+        VGA_Latch(0) = vRAM(address + planeSize * 0)
+        VGA_Latch(1) = vRAM(address + planeSize * 1)
+        VGA_Latch(2) = vRAM(address + planeSize * 2)
+        VGA_Latch(3) = vRAM(address + planeSize * 3)
+
+        If (VGA_SC(2) And 1) <> 0 Then Return vRAM(address + planeSize * 0)
+        If (VGA_SC(2) And 2) <> 0 Then Return vRAM(address + planeSize * 1)
+        If (VGA_SC(2) And 4) <> 0 Then Return vRAM(address + planeSize * 2)
+        If (VGA_SC(2) And 8) <> 0 Then Return vRAM(address + planeSize * 3)
     End Function
 
-    Private Function ShiftVGA(value As UInt16) As UInt16
+    Private Function ShiftVGA(value As Byte) As Byte
         For i As Integer = 0 To (VGA_GC(3) And 7) - 1
             value = (value >> 1) Or ((value And 1) << 7)
         Next
@@ -1032,10 +928,10 @@
 
     Private Function LogicVGA(curValue As Byte, latchValue As Byte) As Byte
         Select Case (VGA_GC(3) >> 3) And 3 ' Raster Op
-            Case 1 : curValue = curValue And latchValue
-            Case 2 : curValue = curValue Or latchValue
-            Case 3 : curValue = curValue Xor latchValue
+            Case 1 : Return curValue And latchValue
+            Case 2 : Return curValue Or latchValue
+            Case 3 : Return curValue Xor latchValue
+            Case Else : Return curValue
         End Select
-        Return curValue
     End Function
 End Class
diff --git a/x8086NetEmu/Adapters/Video/VGA/VGAWinForms.vb b/x8086NetEmu/Adapters/Video/VGA/VGAWinForms.vb
index b813845..11e5607 100644
--- a/x8086NetEmu/Adapters/Video/VGA/VGAWinForms.vb
+++ b/x8086NetEmu/Adapters/Video/VGA/VGAWinForms.vb
@@ -4,19 +4,20 @@
     Private charsCache As New List(Of VideoChar)
     Private charSizeCache As New Dictionary(Of Integer, Size)
 
+    Private blinkCounter As Integer
     Private cursorSize As Size
     Private frameRate As Integer = 30
     Private cursorAddress As New List(Of Integer)
 
-    Private preferredFont As String = "Perfect DOS VGA 437"
+    Private ReadOnly preferredFont As String = "Perfect DOS VGA 437"
     Private mFont As Font = New Font(preferredFont, 16, FontStyle.Regular, GraphicsUnit.Pixel)
     Private textFormat As StringFormat = New StringFormat(StringFormat.GenericTypographic)
 
-    Private brushCache(CGAPalette.Length - 1) As Color
+    Private ReadOnly brushCache(CGAPalette.Length - 1) As Color
     Private cursorBrush As Color = Color.FromArgb(128, Color.White)
     Private cursorYOffset As Integer
 
-    Private fontSourceMode As FontSources
+    Private ReadOnly fontSourceMode As FontSources
     Private g As Graphics
 
     Private scale As New SizeF(1, 1)
@@ -44,8 +45,8 @@
     End Class
     Private task As Scheduler.Task = New TaskSC(Me)
 
-    Public Sub New(cpu As X8086, renderControl As Control, Optional fontSource As FontSources = FontSources.BitmapFile, Optional bitmapFontFile As String = "")
-        MyBase.New(cpu)
+    Public Sub New(cpu As X8086, renderControl As Control, Optional fontSource As FontSources = FontSources.BitmapFile, Optional bitmapFontFile As String = "", Optional enableWebUI As Boolean = False)
+        MyBase.New(cpu, , enableWebUI)
         fontSourceMode = fontSource
         mCPU = cpu
         Me.RenderControl = renderControl
@@ -54,7 +55,12 @@
         AddHandler mRenderControl.KeyUp, Sub(sender As Object, e As KeyEventArgs) HandleKeyUp(Me, e)
 
         AddHandler mRenderControl.MouseDown, Sub(sender As Object, e As MouseEventArgs) OnMouseDown(Me, e)
-        AddHandler mRenderControl.MouseMove, Sub(sender As Object, e As MouseEventArgs) OnMouseMove(Me, e)
+        AddHandler mRenderControl.MouseMove, Sub(sender As Object, e As MouseEventArgs)
+                                                 If mCPU.Mouse?.IsCaptured Then
+                                                     OnMouseMove(Me, e)
+                                                     Cursor.Position = mRenderControl.PointToScreen(mCPU.Mouse.MidPoint)
+                                                 End If
+                                             End Sub
         AddHandler mRenderControl.MouseUp, Sub(sender As Object, e As MouseEventArgs) OnMouseUp(Me, e)
 
         Dim fontCGAPath As String = X8086.FixPath("roms\" + bitmapFontFile)
@@ -74,7 +80,7 @@
                     fontSourceMode = FontSources.TrueType
                 End If
             Case FontSources.ROM
-                VideoChar.BuildFontBitmapsFromROM(8, 16, 14, &HC0000 + &H32B4 - 6, mCPU.Memory)
+                VideoChar.BuildFontBitmapsFromROM(8, 16, 14, &HC0000 + &H3310, mCPU.Memory)
         End Select
 
         If fontSourceMode = FontSources.TrueType Then
@@ -104,6 +110,8 @@
                                             Loop Until cancelAllThreads
                                         End Sub)
         tmp.Start()
+
+        InitVideoMemory(False)
     End Sub
 
     Public Property RenderControl As Control
@@ -134,7 +142,7 @@
     Public Overrides Sub AutoSize()
         If mRenderControl IsNot Nothing Then
             If mRenderControl.InvokeRequired Then
-                mRenderControl.Invoke(New MethodInvoker(AddressOf ResizeRenderControl))
+                mRenderControl.Invoke(Sub() ResizeRenderControl())
             Else
                 ResizeRenderControl()
             End If
@@ -164,16 +172,14 @@
 
     Protected Overrides Sub Render()
         If VideoEnabled Then
-            SyncLock videoBMP
-                Select Case MainMode
-                    Case MainModes.Text
-                        Try ' FIXME: Fix the issues instead of ignoring them! (VideoChar.Paint generates an exception every time the resolution is changed)
-                            RenderText()
-                        Catch
-                        End Try
-                    Case MainModes.Graphics : RenderGraphics()
-                End Select
-            End SyncLock
+            Try
+                SyncLock chars
+                    Select Case MainMode
+                        Case MainModes.Text : RenderText()
+                        Case MainModes.Graphics : RenderGraphics()
+                    End Select
+                End SyncLock
+            Catch : End Try
         End If
     End Sub
 
@@ -189,7 +195,9 @@
         OnPreRender(sender, e)
         g.CompositingMode = Drawing2D.CompositingMode.SourceCopy
 
-        g.DrawImageUnscaled(videoBMP, 0, 0)
+        SyncLock chars
+            g.DrawImageUnscaled(videoBMP, 0, 0)
+        End SyncLock
 
         g.CompositingMode = Drawing2D.CompositingMode.SourceOver
         OnPostRender(sender, e)
@@ -203,9 +211,9 @@
         Dim usePal As Integer = (portRAM(&H3D9) >> 5) And 1
         Dim intensity As Integer = ((portRAM(&H3D9) >> 4) And 1) << 3
 
-        ' For mode &h12 and &h13
-        Dim planeMode As Boolean = (VGA_SC(4) And 6) <> 0
-        Dim vgaPage As UInt32 = (VGA_CRTC(&HC) << 8) + VGA_CRTC(&HD)
+        ' For modes &h12 and &h13
+        Dim planeMode As Boolean = If(mVideoMode = &H12 OrElse mVideoMode = &H13, (VGA_SC(4) And 6) <> 0, False)
+        Dim vgaPage As UInt32 = If(mVideoMode <= 7 OrElse mVideoMode = &H12 OrElse mVideoMode = &H13, (CUInt(VGA_CRTC(&HC)) << 8) + CUInt(VGA_CRTC(&HD)), 0)
 
         Dim address As UInt32
         Dim h1 As UInt32
@@ -214,8 +222,46 @@
         For y As Integer = 0 To GraphicsResolution.Height - 1
             For x As Integer = 0 To GraphicsResolution.Width - 1
                 Select Case mVideoMode
+                    Case 2
+                        h1 = If(mTextResolution.Width = 80, x / 8, x / 16)
+                        h2 = If(mTextResolution.Width = 80, 1, 2)
+                        Dim c As Color
+
+                        If portRAM(&H3D8) = 9 AndAlso portRAM(&H3D4) = 9 Then
+                            address = vgaPage + mStartGraphicsVideoAddress + (y / 4) * mTextResolution.Width * 2 + h1 * 2
+                            b = mCPU.Memory(address)
+                            b = VideoChar.FontBitmaps(b * 128 + (y Mod 4) * 8 + ((x / h2) Mod 8))
+                        Else
+                            address = mStartGraphicsVideoAddress + (y / 16) * mTextResolution.Width * 2 + h1 * 2
+                            b = mCPU.Memory(address)
+                            b = VideoChar.FontBitmaps(b * 128 + (y Mod 16) * 8 + ((x / h2) Mod 8))
+                        End If
+
+                        If (mVideoMode Mod 2) = 0 Then ' Color
+                            If b = 0 Then
+                                c = CGAPalette(mCPU.Memory(address + 1) / 16)
+                            Else
+                                c = CGAPalette(mCPU.Memory(address + 1) And 15)
+                            End If
+                        Else
+                            If (mCPU.Memory(address + 1) And &H70) <> 0 Then
+                                If b = 0 Then
+                                    c = CGAPalette(7)
+                                Else
+                                    c = CGAPalette(0)
+                                End If
+                            Else
+                                If b = 0 Then
+                                    c = CGAPalette(0)
+                                Else
+                                    c = CGAPalette(7)
+                                End If
+                            End If
+                        End If
+                        videoBMP.Pixel(x, y) = c
+
                     Case 4, 5
-                        b = mCPU.Memory(mStartGraphicsVideoAddress + ((y >> 1) * 80) + ((y And 1) * &H2000) + (x >> 2))
+                        b = mCPU.Memory(mStartGraphicsVideoAddress + ((y >> 1) * mTextResolution.Width) + ((y And 1) * &H2000) + (x >> 2))
                         Select Case x And 3
                             Case 3 : b = b And 3
                             Case 2 : b = (b >> 2) And 3
@@ -226,45 +272,44 @@
                             b = b * 2 + usePal + intensity
                             If b = (usePal + intensity) Then b = 0
                         Else
-                            b = b * 63
+                            b = b * &H3F
                             b = b Mod CGAPalette.Length
                         End If
                         videoBMP.Pixel(x, y) = CGAPalette(b)
 
                     Case 6
-                        b = mCPU.Memory(mStartGraphicsVideoAddress + ((y >> 1) * 80) + ((y And 1) * &H2000) + (x >> 3))
+                        b = mCPU.Memory(mStartGraphicsVideoAddress + ((y >> 1) * mTextResolution.Width) + ((y And 1) * &H2000) + (x >> 3))
                         b = (b >> (7 - (x And 7))) And 1
                         b *= 15
                         videoBMP.Pixel(x, y) = CGAPalette(b)
 
                     Case &HD, &HE
-                        h1 = x '>> 1
-                        h2 = y '>> 1
-                        address = h2 * 40 + (h1 >> 3)
+                        h1 = x >> 1
+                        h2 = y >> 1
+                        address = h2 * mTextResolution.Width + (h1 >> 3)
                         h1 = 7 - (h1 And 7)
-                        b = (VRAM(address) >> h1) And 1
-                        b = b + ((VRAM(address + &H10000) >> h1) And 1) << 1
-                        b = b + ((VRAM(address + &H20000) >> h1) And 1) << 2
-                        b = b + ((VRAM(address + &H30000) >> h1) And 1) << 3
-                        videoBMP.Pixel(x, y) = VGAPalette(b)
+                        b = (vRAM(address) >> h1) And 1
+                        b = b + ((vRAM(address + &H10000) >> h1) And 1) << 1
+                        b = b + ((vRAM(address + &H20000) >> h1) And 1) << 2
+                        b = b + ((vRAM(address + &H30000) >> h1) And 1) << 3
+                        videoBMP.Pixel(x, y) = vgaPalette(b)
 
                     Case &H10, &H12
-                        address = (y * 80) + (x >> 3)
+                        address = (y * mTextResolution.Width) + (x >> 3)
                         h1 = 7 - (x And 7)
-                        b = (VRAM(address) >> h1) And 1
-                        b = b Or ((VRAM(address + &H10000) >> h1) And 1) << 1
-                        b = b Or ((VRAM(address + &H20000) >> h1) And 1) << 2
-                        b = b Or ((VRAM(address + &H30000) >> h1) And 1) << 3
-                        videoBMP.Pixel(x, y) = VGAPalette(b)
+                        b = (vRAM(address) >> h1) And 1
+                        b = b Or ((vRAM(address + &H10000) >> h1) And 1) << 1
+                        b = b Or ((vRAM(address + &H20000) >> h1) And 1) << 2
+                        b = b Or ((vRAM(address + &H30000) >> h1) And 1) << 3
+                        videoBMP.Pixel(x, y) = vgaPalette(b)
 
                     Case &H13
                         If planeMode Then
-                            address = ((y * mVideoResolution.Width + x) >> 2) + (x And 3) * &H10000 + vgaPage - (VGA_ATTR(&H13) And 15)
-                            b = VRAM(address)
+                            b = vRAM(((y * mVideoResolution.Width + x) >> 2) + (x And 3) * &H10000 + vgaPage - (VGA_ATTR(&H13) And &HF))
                         Else
-                            b = mCPU.Memory(mStartGraphicsVideoAddress + y * mVideoResolution.Width + x)
+                            b = mCPU.Memory(mStartGraphicsVideoAddress + vgaPage + y * mVideoResolution.Width + x)
                         End If
-                        videoBMP.Pixel(x, y) = VGAPalette(b)
+                        videoBMP.Pixel(x, y) = vgaPalette(b)
 
                     Case 127
                         b = mCPU.Memory(mStartGraphicsVideoAddress + ((y And 3) << 13) + ((y >> 2) * 90) + (x >> 3))
@@ -272,7 +317,7 @@
                         videoBMP.Pixel(x, y) = CGAPalette(b)
 
                     Case Else
-                        b = mCPU.Memory(mStartGraphicsVideoAddress + ((y >> 1) * 80) + ((y And 1) * &H2000) + (x >> xDiv))
+                        b = mCPU.Memory(mStartGraphicsVideoAddress + ((y >> 1) * mTextResolution.Width) + ((y And 1) * &H2000) + (x >> xDiv))
                         If PixelsPerByte = 4 Then
                             Select Case x And 3
                                 Case 3 : b = b And 3
@@ -303,25 +348,20 @@
         Dim intensity As Boolean = (portRAM(&H3D8) And &H80) <> 0
         Dim mode As Boolean = (portRAM(&H3D8) = 9) AndAlso (portRAM(&H3D4) = 9)
 
-        UpdateCursorState()
+        ' FIXME: Dummy workaround to support the cursor; Haven't found a better way yet...
+        mCursorCol = mCPU.Memory(&H450)
+        mCursorRow = mCPU.Memory(&H451)
+        mCursorVisible = True
 
-        For address As Integer = StartTextVideoAddress To EndTextVideoAddress Step 2
-            b0 = mCPU.Memory(address)
-            b1 = mCPU.Memory(address + 1)
+        For address As Integer = 0 To MEMSIZE - 2 Step 2
+            b0 = VideoRAM(address)
+            b1 = VideoRAM(address + 1)
 
             If mVideoMode = 7 OrElse mVideoMode = 127 Then
                 If (b1 And &H70) <> 0 Then
-                    If b0 = 0 Then
-                        b1 = 7
-                    Else
-                        b1 = 0
-                    End If
+                    b1 = If(b0 = 0, 7, 0)
                 Else
-                    If b0 = 0 Then
-                        b1 = 0
-                    Else
-                        b1 = 7
-                    End If
+                    b1 = If(b0 = 0, 0, 7)
                 End If
             End If
 
@@ -331,10 +371,18 @@
             'End If
 
             If CursorVisible AndAlso row = CursorRow AndAlso col = CursorCol Then
-                videoBMP.FillRectangle(brushCache(b1.LowNib()),
+                If blinkCounter < BlinkRate Then
+                    videoBMP.FillRectangle(brushCache(b1.LowNib()),
                                            r.X + 0, r.Y - 1 + CellSize.Height - (CursorEnd - CursorStart) - 1,
-                                           CellSize.Width, (CursorEnd - CursorStart) + 1)
-                cursorAddress.Add(address)
+                                           CellSize.Width, CursorEnd - CursorStart + 1)
+                    cursorAddress.Add(address)
+                End If
+
+                If blinkCounter >= 2 * BlinkRate Then
+                    blinkCounter = 0
+                Else
+                    blinkCounter += 1
+                End If
             End If
 
             r.X += CellSize.Width
@@ -425,6 +473,17 @@
         MyBase.InitVideoMemory(clearScreen)
 
         If mRenderControl IsNot Nothing Then
+            SyncLock chars
+                If videoBMP IsNot Nothing Then videoBMP.Dispose()
+                If GraphicsResolution.Width = 0 Then
+                    VideoMode = 3
+                    Exit Sub
+                End If
+                videoBMP = New DirectBitmap(GraphicsResolution.Width, GraphicsResolution.Height)
+
+                If wui IsNot Nothing Then wui.Bitmap = videoBMP
+            End SyncLock
+
             If clearScreen OrElse charSizeCache.Count = 0 Then
                 charSizeCache.Clear()
                 Using g = mRenderControl.CreateGraphics()
@@ -436,13 +495,6 @@
 
             charsCache.Clear()
 
-            If videoBMP IsNot Nothing Then videoBMP.Dispose()
-            If GraphicsResolution.Width = 0 Then
-                videoBMP = New DirectBitmap(640, 480)
-            Else
-                videoBMP = New DirectBitmap(GraphicsResolution.Width, GraphicsResolution.Height)
-            End If
-
             If fontSourceMode = FontSources.TrueType Then
                 If g IsNot Nothing Then g.Dispose()
                 g = Graphics.FromImage(videoBMP)
diff --git a/x8086NetEmu/Adapters/Video/VideoAdapter.vb b/x8086NetEmu/Adapters/Video/VideoAdapter.vb
index d493583..6e9028f 100644
--- a/x8086NetEmu/Adapters/Video/VideoAdapter.vb
+++ b/x8086NetEmu/Adapters/Video/VideoAdapter.vb
@@ -36,15 +36,15 @@
 
     Public MustOverride Overrides Sub CloseAdapter()
     Public MustOverride Overrides Sub InitiAdapter()
-    Public MustOverride Overrides Sub Out(port As UInt32, value As UInt32)
-    Public MustOverride Overrides Function [In](port As UInt32) As UInt32
+    Public MustOverride Overrides Sub Out(port As UInt32, value As UInt16)
+    Public MustOverride Overrides Function [In](port As UInt32) As UInt16
     Public MustOverride Overrides Sub Run()
 
     Public MustOverride Sub Reset()
     Public MustOverride Sub AutoSize()
 
-    Protected mStartTextVideoAddress As Integer
-    Protected mEndTextVideoAddress As Integer
+    Protected mStartTextVideoAddress As Integer = &HB0000
+    Protected mEndTextVideoAddress As Integer = &HA0000
 
     Protected mStartGraphicsVideoAddress As Integer
     Protected mEndGraphicsVideoAddress As Integer
@@ -54,6 +54,8 @@
     Protected mVideoResolution As Size = New Size(0, 0)
     Protected mCellSize As Size
 
+    Protected keyMap As New KeyMap() ' Used to filter unsupported keystrokes
+
     'Private Memory(X8086.MemSize - 1) As Boolean
 
     Public Sub New(cpu As X8086)
@@ -148,6 +150,6 @@
     End Function
 
     Public Function ColRowToAddress(col As Integer, row As Integer) As Integer
-        Return StartTextVideoAddress + row * (TextResolution.Width * 2) + (col * 2)
+        Return StartTextVideoAddress + row * TextResolution.Width * 2 + (col * 2)
     End Function
 End Class
diff --git a/x8086NetEmu/Adapters/Video/VideoChar.vb b/x8086NetEmu/Adapters/Video/VideoChar.vb
index dda06ec..8c55a5c 100644
--- a/x8086NetEmu/Adapters/Video/VideoChar.vb
+++ b/x8086NetEmu/Adapters/Video/VideoChar.vb
@@ -1,35 +1,18 @@
 ï»¿Public Class VideoChar
-    Private mCGAChar As Integer
-    Private mForeColor As Color
-    Private mBackColor As Color
+    Public ReadOnly Property CGAChar As Integer
+    Public ReadOnly Property ForeColor As Color
+    Public ReadOnly Property BackColor As Color
+
     Private mBitmap As DirectBitmap
 
     Public Shared FontBitmaps() As Byte
 
     Public Sub New(c As Integer, fb As Color, bb As Color)
-        mCGAChar = c
-        mForeColor = fb
-        mBackColor = bb
+        CGAChar = c
+        ForeColor = fb
+        BackColor = bb
     End Sub
 
-    Public ReadOnly Property CGAChar As Integer
-        Get
-            Return mCGAChar
-        End Get
-    End Property
-
-    Public ReadOnly Property ForeColor As Color
-        Get
-            Return mForeColor
-        End Get
-    End Property
-
-    Public ReadOnly Property BackColor As Color
-        Get
-            Return mBackColor
-        End Get
-    End Property
-
     Private tmp As New Object()
 
     Public Sub Paint(dbmp As DirectBitmap, p As Point, scale As SizeF)
@@ -49,10 +32,10 @@
 
             For y As Integer = 0 To h - 1
                 For x As Integer = 0 To w - 1
-                    If FontBitmaps(mCGAChar * (w * h) + y * w + x) = 1 Then
-                        mBitmap.Pixel(x, y) = mForeColor
+                    If FontBitmaps(CGAChar * w * h + y * w + x) = 1 Then
+                        mBitmap.Pixel(x, y) = ForeColor
                     Else
-                        mBitmap.Pixel(x, y) = mBackColor
+                        mBitmap.Pixel(x, y) = BackColor
                     End If
                 Next
             Next
@@ -66,7 +49,7 @@
     End Operator
 
     Public Shared Operator <>(c1 As VideoChar, c2 As VideoChar) As Boolean
-        Return Not (c1 = c2)
+        Return Not c1 = c2
     End Operator
 
     Public Overrides Function Equals(obj As Object) As Boolean
@@ -75,13 +58,13 @@
 
     Public Overrides Function ToString() As String
         Return String.Format("{0:000} [{1:000}:{2:000}:{3:000}] [{4:000}:{5:000}:{6:000}]",
-                             mCGAChar,
-                             mForeColor.R,
-                             mForeColor.G,
-                             mForeColor.B,
-                             mBackColor.R,
-                             mBackColor.G,
-                             mBackColor.B)
+                             CGAChar,
+                             ForeColor.R,
+                             ForeColor.G,
+                             ForeColor.B,
+                             BackColor.R,
+                             BackColor.G,
+                             BackColor.B)
     End Function
 
     ' http://goughlui.com/2016/05/01/project-examining-vga-bios-from-old-graphic-cards/
@@ -104,13 +87,13 @@
         Dim y As Integer = 0
 
         For i As Integer = 0 To 512 - 1
-            While base < dataH
+            While base < fh
                 While tempCount < dataW
                     While mask <> 0
                         If (rom((base + (tempCount * dataH) + (row * dataW * dataH) + offset) Mod romSize) And mask) <> 0 Then
-                            VideoChar.FontBitmaps(i * (fw * fh) + y * fw + x) = 1
+                            VideoChar.FontBitmaps(i * fw * fh + y * fw + x) = 1
                         Else
-                            VideoChar.FontBitmaps(i * (fw * fh) + y * fw + x) = 0
+                            VideoChar.FontBitmaps(i * fw * fh + y * fw + x) = 0
                         End If
                         x += 1
                         mask = mask >> 1
diff --git a/x8086NetEmu/Adapters/WebUI.vb b/x8086NetEmu/Adapters/WebUI.vb
new file mode 100644
index 0000000..6a2eec8
--- /dev/null
+++ b/x8086NetEmu/Adapters/WebUI.vb
@@ -0,0 +1,233 @@
+ï»¿Imports System.Net
+Imports System.Threading
+Imports System.Web
+
+Public Class WebUI
+    Private client As Sockets.TcpListener
+
+    Private mBitmap As DirectBitmap
+    Private cpu As X8086
+    Private ReadOnly syncObj As Object
+
+    Private lastKeyDown As Keys
+    Private lastKeyDownTime As Long
+
+    Private lastKeyUp As Keys
+    Private lastKeyUpTime As Long
+
+    Public Sub New(cpu As X8086, dBmp As DirectBitmap, syncObj As Object)
+        Me.cpu = cpu
+        Me.syncObj = syncObj
+        mBitmap = dBmp
+
+        CreateClient()
+
+        Tasks.Task.Run(AddressOf ListenerSub)
+    End Sub
+
+    Public Property Bitmap As DirectBitmap
+        Get
+            Return mBitmap
+        End Get
+        Set(value As DirectBitmap)
+            SyncLock syncObj
+                mBitmap = value
+            End SyncLock
+        End Set
+    End Property
+
+    Private Sub ListenerSub()
+        Do
+            Try
+                If client?.Pending Then
+                    Using tcp As Sockets.TcpClient = client.AcceptTcpClient()
+                        Using netStream As Sockets.NetworkStream = tcp.GetStream()
+                            Dim buffer(1024 * 16 - 1) As Byte
+                            Dim data As New List(Of Byte)
+
+                            Do
+                                Dim len As Integer = netStream.Read(buffer, 0, buffer.Length)
+                                If len > 0 Then data.AddRange(buffer)
+                                If len < buffer.Length Then Exit Do
+                            Loop
+
+                            ' See '\Projects\SDFWebCuadre\SDFWebCuadre\ModuleMain.vb' for information
+                            ' on how to handle binary data, such as images
+
+                            Dim rcvData As String = Text.Encoding.UTF8.GetString(data.ToArray())
+                            Dim sndData As Byte() = Nothing
+                            Dim resource As String = GetResource(rcvData)
+                            Dim cntType As String = "text/html; text/html; charset=UTF-8"
+                            Dim params As String = ""
+                            If resource.Contains("?") Then
+                                params = HttpUtility.UrlDecode(resource.Split("?")(1))
+                                resource = resource.Split("?")(0)
+                            End If
+
+                            Select Case resource
+                                Case "/" : sndData = Text.UTF8Encoding.UTF8.GetBytes(GetUI())
+                                Case "/frame" : sndData = GetFrame() : cntType = "image/png"
+                                Case "/keyDown"
+                                    Dim k As Keys = CType(params.Split("=")(1), Keys)
+                                    If k = lastKeyDown AndAlso Now.Ticks - lastKeyDownTime < 3000000 Then Exit Select
+                                    lastKeyDown = k
+                                    lastKeyDownTime = Now.Ticks
+                                    cpu.PPI.PutKeyData(lastKeyDown, False)
+                                Case "/keyUp"
+                                    Dim k As Keys = CType(params.Split("=")(1), Keys)
+                                    If k = lastKeyUp AndAlso Now.Ticks - lastKeyUpTime < 3000000 Then Exit Select
+                                    lastKeyUp = k
+                                    lastKeyUpTime = Now.Ticks
+                                    cpu.PPI.PutKeyData(lastKeyUp, True)
+                            End Select
+
+                            If sndData?.Length > 0 Then
+                                Dim sb As New Text.StringBuilder()
+                                sb.Append("HTTP/1.0 200 OK" + ControlChars.CrLf)
+                                sb.Append($"Content-Type: {cntType}{ControlChars.CrLf}")
+                                sb.Append($"Content-Length: {sndData.Length}{ControlChars.CrLf}")
+                                sb.Append(ControlChars.CrLf)
+
+                                Dim b() As Byte = Text.Encoding.UTF8.GetBytes(sb.ToString())
+                                ReDim Preserve b(b.Length + sndData.Length - 1)
+                                Array.Copy(sndData, 0, b, sb.ToString().Length, sndData.Length)
+
+                                netStream.Write(b, 0, b.Length)
+                            End If
+
+                            netStream.Close()
+                        End Using
+
+                        tcp.Close()
+                    End Using
+                Else
+                    Thread.Sleep(100)
+                End If
+            Catch ex As Exception
+                X8086.Notify($"WebUI Error: {ex.Message}", X8086.NotificationReasons.Err)
+                'Exit Do
+            End Try
+        Loop While client IsNot Nothing
+    End Sub
+
+    Private Function GetUI() As String
+        ' FIXME: The zoom compensation is not implemented correctly
+        Return $"<!DOCTYPE html>
+                <html lang=""en"">
+                    <head>
+                    <title>x8086NetEmu WebUI</title>
+                    <meta charset=""utf-8"">
+                    <style>
+                        canvas {{
+                            padding: 0;
+                            margin: auto;
+                            display: block;
+                            width:  {640 * cpu.VideoAdapter.Zoom};
+                            height: {400 * cpu.VideoAdapter.Zoom};
+                            position: absolute;
+                            top: 0;
+                            bottom: 0;
+                            left: 0;
+                            right: 0;
+                        }}
+                    </style>
+                    <script type=""text/JavaScript"">
+                        var host = ""http://""+window.location.hostname+"":8086"";
+                        var canvas;
+                        var context;
+                        var xmlHttp = new XMLHttpRequest();
+                        var img = new Image();
+                        var lastWidth = 0;
+                        var lastHeight = 0;
+
+                        function init() {{
+                            canvas = document.getElementById(""x8086"");
+                            context = canvas.getContext(""2d"");
+                            setInterval(updateFrame, 60);
+
+                            document.onkeydown = function(e) {{
+                                e = e || window.event;
+                                xmlHttp.open(""GET"", host + ""/keyDown?key="" + e.keyCode, true);
+                                xmlHttp.send(null);
+                                e.preventDefault();
+                            }};
+
+                            document.onkeyup = function(e) {{
+                                e = e || window.event;
+                                xmlHttp.open(""GET"", host + ""/keyUp?key="" + e.keyCode, true);
+                                xmlHttp.send(null);
+                                e.preventDefault();
+                            }};
+
+                            img.onload = function() {{
+                                if((canvas.width != img.width) || (canvas.height = img.height)) {{
+                                    canvas.width =  {640 * cpu.VideoAdapter.Zoom};
+                                    canvas.height = {400 * cpu.VideoAdapter.Zoom};
+                                    lastWidth = img.width;
+                                    lastHeight = img.height;
+                                }}
+                                context.imageSmoothingEnabled = false;
+                                context.drawImage(img, 0, 0, canvas.width, canvas.height);
+                            }};
+                        }}
+
+                        function updateFrame() {{
+                            img.src = host + ""/frame"" + ""?d="" + Date.now();
+                        }}
+                    </script>
+
+                    <title>x8086 WebUI</title>
+                    </head>
+                    <body onload=""init()"" bgcolor=""#1F1F1F"">
+                        <canvas tabindex=""1"" id=""x8086"" width=""640"" height=""480""/>
+                    </body>
+                </html>"
+    End Function
+
+    Private Function GetFrame() As Byte()
+        Try
+            SyncLock syncObj
+                ' FIXME: When using the VGA adapter and UseVRAM is true we need to send the VGA adapter's RAM instead
+                Return CType(mBitmap, Byte())
+            End SyncLock
+        Catch
+            Return Nothing
+        End Try
+    End Function
+
+    Private Sub CreateClient()
+        Close()
+
+        client = New Sockets.TcpListener(IPAddress.Any, 8086)
+        client.Start()
+    End Sub
+
+    Public Sub Close()
+        If client IsNot Nothing Then
+            Try
+                client.Stop()
+                client = Nothing
+            Catch ex As Exception
+            End Try
+        End If
+    End Sub
+
+    Private Function GetParams(params As String) As Dictionary(Of String, String)
+        Dim data As New Dictionary(Of String, String)
+
+        Dim tokens() As String = params.ToLower().Split("&"c)
+        For Each token In tokens
+            If token.Contains("="c) Then
+                Dim subTokens() As String = token.Split("="c)
+                data.Add(subTokens(0), subTokens(1))
+            Else
+                data.Add(token, "")
+            End If
+        Next
+        Return data
+    End Function
+
+    Private Function GetResource(data As String) As String
+        Return If(data.StartsWith("GET /"), data.Split(" ")(1), "404")
+    End Function
+End Class
diff --git a/x8086NetEmu/Chipset/DMA8237.vb b/x8086NetEmu/Chipset/DMA8237.vb
index 3098e21..2a4a829 100644
--- a/x8086NetEmu/Chipset/DMA8237.vb
+++ b/x8086NetEmu/Chipset/DMA8237.vb
@@ -5,22 +5,22 @@
     Private msbFlipFlop As Boolean
 
     ' Command register (8-bit)
-    Private cmdreg As Integer
+    Private cmdReg As Integer
 
     ' Status register (8-bit)
-    Private statusreg As Integer
+    Private statusReg As Integer
 
     ' Temporary register (8-bit)
-    Private tempreg As Integer
+    Private tempReg As Integer
 
     ' Bitmask of active software DMA requests (bits 0-3)
-    Private reqreg As Integer
+    Private reqReg As Integer
 
     ' Mask register (bits 0-3)
-    Private maskreg As Integer
+    Public MaskReg As Integer
 
     ' Channel with highest priority
-    Private priochannel As Integer
+    Private prioChannel As Integer
 
     ' Four DMA channels in the I8237 chip
     Private ReadOnly channels() As Channel
@@ -57,50 +57,55 @@
     ' that has not yet been accounted for, or -1 to disable
     Private ch0NextTrigger As Long
 
-    Private Class Channel
+    Public Class Channel
         Implements IDMAChannel
 
         ' Base address register (16-bit)
-        Public baseaddr As Integer
+        Public BaseAddress As Integer
 
         ' Base count register (16-bit)
-        Public basecount As Integer
+        Public BaseCount As Integer
 
         ' Current address register (16-bit)
-        Public curaddr As Integer
+        Public CurrentAddress As Integer
 
         ' Current count register (16-bit)
-        Public curcount As Integer
+        Public CurrentCount As Integer
 
         ' Mode register (bits 2-7)
-        Public mode As Integer
+        Public Mode As Integer
+
+        Public Masked As Integer
+        Public Direction As Integer
+        Public AutoInit As Integer
+        Public WriteMode As Integer
 
         ' Page (address bits 16 - 23) for this channel.
-        Public page As Integer
+        Public Page As Integer
 
         ' Device with which this channel is currently associated.
-        Public dev As IDMADevice
+        Public Device As IDMADevice
 
         ' True if DREQ is active for this channel.
-        Public pendingRequest As Boolean
+        Public PendingRequest As Boolean
 
-        ' True if the device signalled external EOP.
-        Public externalEop As Boolean
+        ' True if the device signaled external EOP.
+        Public ExternalEop As Boolean
 
-        Private portDev As DMAI8237
+        Private PortDevice As DMAI8237
 
         ' Constructs channel.
         Public Sub New(dmaDev As DMAI8237)
-            Me.portDev = dmaDev
+            Me.PortDevice = dmaDev
         End Sub
 
         Public Sub DMAEOP() Implements IDMAChannel.DMAEOP
-            externalEop = True
+            ExternalEop = True
         End Sub
 
         Public Sub DMARequest(enable As Boolean) Implements IDMAChannel.DMARequest
-            pendingRequest = enable
-            portDev.TryHandleRequest()
+            PendingRequest = enable
+            PortDevice.TryHandleRequest()
         End Sub
     End Class
 
@@ -115,19 +120,19 @@
         For i As Integer = 0 To 4 - 1
             channels(i) = New Channel(Me)
         Next
-        maskreg = &HF '  mask all channels
+        MaskReg = &HF '  mask all channels
         ch0NextTrigger = -1
 
-        For i As Integer = &H0 To &HF
+        For i As UInt32 = &H0 To &HF
             ValidPortAddress.Add(i)
         Next
 
-        For i As Integer = &H80 To &H8F
+        For i As UInt32 = &H80 To &H8F
             ValidPortAddress.Add(i)
         Next
     End Sub
 
-    Public Function GetChannel(channelNumber) As IDMAChannel
+    Public Function GetChannel(channelNumber As Integer) As IDMAChannel
         Return channels(channelNumber)
     End Function
 
@@ -137,9 +142,9 @@
     ' @return the DmaChannel object
     Public Function BindChannel(channelNumber As Integer, dev As IDMADevice) As IDMAChannel
         If channelNumber = 0 Then Throw New ArgumentException("Can not bind DMA channel 0")
-        channels(channelNumber).dev = dev
-        channels(channelNumber).pendingRequest = False
-        channels(channelNumber).externalEop = False
+        channels(channelNumber).Device = dev
+        channels(channelNumber).PendingRequest = False
+        channels(channelNumber).ExternalEop = False
         Return channels(channelNumber)
     End Function
 
@@ -175,28 +180,28 @@
         If ntrigger = 0 Then Exit Sub
 
         ' Ignore triggers if DMA controller is disabled
-        If (cmdreg And &H4) <> 0 Then Exit Sub
+        If (cmdReg And &H4) <> 0 Then Exit Sub
 
         ' Ignore triggers if channel 0 is masked
-        If (maskreg And 1) = 1 Then Exit Sub
+        If (MaskReg And 1) = 1 Then Exit Sub
 
         ' The only sensible mode for channel 0 in a PC is
         ' auto-initialized single read mode, so we simply assume that.
 
         ' Update count, address and status registers to account for
         ' the past triggers.
-        Dim addrstep As Integer = If((cmdreg And &H2) = 0, If((channels(0).mode And &H20) = 0, 1, -1), 0)
-        If ntrigger <= channels(0).curcount Then
+        Dim addrstep As Integer = If((cmdReg And &H2) = 0, If((channels(0).Mode And &H20) = 0, 1, -1), 0)
+        If ntrigger <= channels(0).CurrentCount Then
             ' no terminal count
             Dim n As Integer = CInt(ntrigger)
-            channels(0).curcount -= n
-            channels(0).curaddr = (channels(0).curaddr + n * addrstep) And &HFFFF
+            channels(0).CurrentCount -= n
+            channels(0).CurrentAddress = (channels(0).CurrentAddress + n * addrstep) And &HFFFF
         Else
             ' terminal count occurred
-            Dim n As Integer = CInt((ntrigger - channels(0).curcount - 1) Mod (channels(0).basecount + 1))
-            channels(0).curcount = channels(0).basecount - n
-            channels(0).curaddr = (channels(0).baseaddr + n * addrstep) And &HFFFF
-            statusreg = statusreg Or 1
+            Dim n As Integer = CInt((ntrigger - channels(0).CurrentCount - 1) Mod (channels(0).BaseCount + 1))
+            channels(0).CurrentCount = channels(0).BaseCount - n
+            channels(0).CurrentAddress = (channels(0).BaseAddress + n * addrstep) And &HFFFF
+            statusReg = statusReg Or 1
         End If
     End Sub
 
@@ -204,36 +209,36 @@
         Dim i As Integer
 
         ' Update request bits in status register
-        Dim rbits As Integer = reqreg
+        Dim rbits As Integer = reqReg
         For i = 0 To 4 - 1
-            If channels(i).pendingRequest Then rbits = rbits Or (1 << i)
+            If channels(i).PendingRequest Then rbits = rbits Or (1 << i)
         Next
-        statusreg = (statusreg And &HF) Or (rbits << 4)
+        statusReg = (statusReg And &HF) Or (rbits << 4)
 
         ' Don't start a transfer during dead time after a previous transfer
         If pendingTask Then Exit Sub
 
         ' Don't start a transfer if the controller is disabled
-        If (cmdreg And &H4) <> 0 Then Exit Sub
+        If (cmdReg And &H4) <> 0 Then Exit Sub
 
         ' Select a channel with pending request
-        rbits = rbits And (Not maskreg)
+        rbits = rbits And (Not MaskReg)
         rbits = rbits And (Not 1) ' never select channel 0
         If rbits = 0 Then Exit Sub
 
-        i = priochannel
+        i = prioChannel
         While ((rbits >> i) And 1) = 0
             i = (i + 1) And 3
         End While
 
         ' Just decided to start a transfer on channel i
         Dim chan As Channel = channels(i)
-        Dim dev As IDMADevice = chan.dev
-        Dim mode As Integer = chan.mode
-        Dim page As Integer = chan.page
+        Dim dev As IDMADevice = chan.Device
+        Dim mode As Integer = chan.Mode
+        Dim page As Integer = chan.Page
 
         ' Update dynamic priority
-        If (cmdreg And 10) <> 0 Then priochannel = (i + 1) And 3
+        If (cmdReg And 10) <> 0 Then prioChannel = (i + 1) And 3
 
         ' Block further transactions until this one completes
         pendingTask = True
@@ -248,17 +253,17 @@
             ' Prepare for transfer
             Dim blockmode As Boolean = (mode And &HC0) = &H80
             Dim singlemode As Boolean = (mode And &HC0) = &H40
-            Dim curcount As Integer = chan.curcount
+            Dim curcount As Integer = chan.CurrentCount
             Dim maxlen As Integer = curcount + 1
-            Dim curaddr As Integer = chan.curaddr
-            Dim addrstep As Integer = If((chan.mode And &H20) = 0, 1, -1)
-            chan.externalEop = False
+            Dim curaddr As Integer = chan.CurrentAddress
+            Dim addrstep As Integer = If((chan.Mode And &H20) = 0, 1, -1)
+            chan.ExternalEop = False
 
             ' Don't combine too much single transfers in one atomic action
             If singlemode AndAlso maxlen > 25 Then maxlen = 25
 
             ' Execute transfer
-            Select Case (mode And &HC)
+            Select Case mode And &HC
                 Case &H0
                     ' DMA verify
                     curcount -= maxlen
@@ -266,11 +271,8 @@
                     transferTime += 3 * maxlen * Scheduler.BASECLOCK / cpu.Clock
                 Case &H4
                     ' DMA write
-                    While (maxlen > 0) AndAlso (Not chan.externalEop) AndAlso (blockmode OrElse chan.pendingRequest)
-                        If dev IsNot Nothing Then
-                            Dim b As Byte = dev.DMAWrite()
-                            cpu.RAM((page << 16) Or curaddr) = b
-                        End If
+                    While (maxlen > 0) AndAlso (Not chan.ExternalEop) AndAlso (blockmode OrElse chan.PendingRequest)
+                        If dev IsNot Nothing Then cpu.Memory((page << 16) Or curaddr) = dev.DMAWrite()
                         maxlen -= 1
                         curcount -= 1
                         curaddr = (curaddr + addrstep) And &HFFFF
@@ -278,11 +280,8 @@
                     End While
                 Case &H8
                     ' DMA read
-                    While maxlen > 0 AndAlso Not chan.externalEop AndAlso (blockmode OrElse chan.pendingRequest)
-                        If dev IsNot Nothing Then
-                            Dim b As Byte = cpu.RAM((page << 16) Or curaddr)
-                            dev.DMARead(b)
-                        End If
+                    While maxlen > 0 AndAlso Not chan.ExternalEop AndAlso (blockmode OrElse chan.PendingRequest)
+                        If dev IsNot Nothing Then dev.DMARead(cpu.Memory((page << 16) Or curaddr))
                         maxlen -= 1
                         curcount -= 1
                         curaddr = (curaddr + addrstep) And &HFFFF
@@ -291,40 +290,40 @@
             End Select
 
             ' Update registers
-            Dim termcount As Boolean = (curcount < 0)
-            chan.curcount = If(termcount, &HFFFF, curcount)
-            chan.curaddr = curaddr
+            Dim termcount As Boolean = curcount < 0
+            chan.CurrentCount = If(termcount, &HFFFF, curcount)
+            chan.CurrentAddress = curaddr
 
             ' Handle terminal count or external EOP
-            If termcount OrElse chan.externalEop Then
+            If termcount OrElse chan.ExternalEop Then
                 If (mode And &H10) = 0 Then
                     ' Set mask bit
-                    maskreg = maskreg Or (1 << i)
+                    MaskReg = MaskReg Or (1 << i)
                 Else
                     ' Auto-initialize
-                    chan.curcount = chan.basecount
-                    chan.curaddr = chan.baseaddr
+                    chan.CurrentCount = chan.BaseCount
+                    chan.CurrentAddress = chan.BaseAddress
                 End If
                 ' Clear software request
-                reqreg = reqreg And (Not (1 << i))
+                reqReg = reqReg And (Not 1 << i)
                 ' Set TC bit in status register
-                statusreg = statusreg Or (1 << i)
+                statusReg = statusReg Or (1 << i)
             End If
 
             ' Send EOP to device
-            If termcount AndAlso (Not chan.externalEop) AndAlso dev IsNot Nothing Then dev.DMAEOP()
+            If termcount AndAlso (Not chan.ExternalEop) AndAlso dev IsNot Nothing Then dev.DMAEOP()
         End If
 
         ' Schedule a task to run when the simulated DMA transfer completes
         cpu.Sched.RunTaskAfter(task, transferTime)
     End Sub
 
-    Public Overrides Function [In](port As UInt32) As UInt32
+    Public Overrides Function [In](port As UInt32) As UInt16
         UpdateCh0()
         If (port And &HFFF8) = 0 Then
             ' DMA controller: channel status
             Dim chan As Channel = channels((port >> 1) And 3)
-            Dim x As Integer = If((port And 1) = 0, chan.curaddr, chan.curcount)
+            Dim x As Integer = If((port And 1) = 0, chan.CurrentAddress, chan.CurrentCount)
             Dim p As Boolean = msbFlipFlop
             msbFlipFlop = Not p
             Return If(p, (x >> 8) And &HFF, x And &HFF)
@@ -333,19 +332,20 @@
             Dim v As Integer
             Select Case port
                 Case 8 ' read status register
-                    v = statusreg
-                    statusreg = statusreg And &HF0
+                    v = statusReg
+                    statusReg = statusReg And &HF0
                     Return v
                 Case 13 ' read temporary register
-                    Return tempreg
+                    Return tempReg
             End Select
         End If
 
         Return &HFF
     End Function
 
-    Public Overrides Sub Out(port As UInt32, v As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
         UpdateCh0()
+
         If (port And &HFFF8) = 0 Then
             ' DMA controller: channel setup
             Dim chan As Channel = channels((port >> 1) And 3)
@@ -355,81 +355,85 @@
 
             If (port And 1) = 0 Then
                 ' base/current address
-                x = chan.baseaddr
-                y = chan.curaddr
+                x = chan.BaseAddress
+                y = chan.CurrentAddress
             Else
-                x = chan.basecount
-                y = chan.curcount
+                x = chan.BaseCount
+                y = chan.CurrentCount
             End If
             Dim p As Boolean = msbFlipFlop
             msbFlipFlop = Not p
             If p Then
-                x = (x And &HFF) Or ((v << 8) And &HFF00)
-                y = (y And &HFF) Or ((v << 8) And &HFF00)
+                x = (x And &HFF) Or ((value << 8) And &HFF00)
+                y = (y And &HFF) Or ((value << 8) And &HFF00)
             Else
-                x = (x And &HFF00) Or (v And &HFF)
-                y = (y And &HFF00) Or (v And &HFF)
+                x = (x And &HFF00) Or (value And &HFF)
+                y = (y And &HFF00) Or (value And &HFF)
             End If
             If (port And 1) = 0 Then
-                chan.baseaddr = x
-                chan.curaddr = y
+                chan.BaseAddress = x
+                chan.CurrentAddress = y
             Else
-                chan.basecount = x
-                chan.curcount = y
+                chan.BaseCount = x
+                chan.CurrentCount = y
             End If
         ElseIf (port And &HFFF8) = &H8 Then
             ' DMA controller: operation registers
             Select Case port And &HF
                 Case 8 ' write command register
-                    cmdreg = v
-                    If (v And &H10) = 0 Then priochannel = 0 ' enable fixed priority
-                    If (v And 1) = 1 Then cpu.RaiseException("DMB8237: memory-to-memory transfer not implemented")
+                    cmdReg = value
+                    If (value And &H10) = 0 Then prioChannel = 0 ' enable fixed priority
+                    If (value And 1) = 1 Then cpu.RaiseException("DMA8237: memory-to-memory transfer not implemented")
 
                 Case 9 ' set/reset request register
-                    If ((v And 4) = 0) Then
-                        reqreg = reqreg And (Not (1 << (v And 3))) ' reset request bit
+                    If (value And 4) = 0 Then
+                        reqReg = reqReg And (Not 1 << (value And 3)) ' reset request bit
                     Else
-                        reqreg = reqreg Or (1 << (v And 3))  ' set request bit
-                        If ((v And 7) = 4) Then cpu.RaiseException("DMB8237: software request on channel 0 not implemented")
+                        reqReg = reqReg Or (1 << (value And 3))  ' set request bit
+                        If (value And 7) = 4 Then cpu.RaiseException("DMA8237: software request on channel 0 not implemented")
                     End If
 
                 Case 10 ' set/reset mask register
-                    If ((v And 4) = 0) Then
-                        maskreg = maskreg And (Not (1 << (v And 3))) ' reset mask bit
+                    If (value And 4) = 0 Then
+                        MaskReg = MaskReg And (Not 1 << (value And 3)) ' reset mask bit
                     Else
-                        maskreg = maskreg Or (1 << (v And 3))  ' set mask bit
+                        MaskReg = MaskReg Or (1 << (value And 3))  ' set mask bit
                     End If
+                    channels(value And 3).Masked = (value >> 2) And 1
 
                 Case 11 ' write mode register
-                    channels(v And 3).mode = v
-                    If ((v And 3) = 0 AndAlso (v And &HDC) <> &H58) Then cpu.RaiseException("DMB8237: unsupported mode on channel 0")
+                    channels(value And 3).Mode = value
+                    channels(value And 3).Direction = (value >> 5) And 1
+                    channels(value And 3).AutoInit = (value >> 4) And 1
+                    channels(value And 3).WriteMode = (value >> 2) And 1
+                    If (value And 3) = 0 AndAlso (value And &HDC) <> &H58 Then cpu.RaiseException("DMA8237: unsupported mode on channel 0")
 
                 Case 12 ' clear msb flipflop
                     msbFlipFlop = False
 
                 Case 13 ' master clear
                     msbFlipFlop = False
-                    cmdreg = 0
-                    statusreg = 0
-                    reqreg = 0
-                    tempreg = 0
-                    maskreg = &HF
+                    cmdReg = 0
+                    statusReg = 0
+                    reqReg = 0
+                    tempReg = 0
+                    MaskReg = &HF
 
                 Case 14 ' clear mask register
-                    maskreg = 0
+                    MaskReg = 0
 
                 Case 15 ' write mask register
-                    maskreg = v
+                    MaskReg = value
             End Select
             TryHandleRequest()
 
         ElseIf (port And &HFFF8) = &H80 Then
             ' DMA page registers
             Select Case port
-                Case &H81 : channels(2).page = v
-                Case &H82 : channels(3).page = v
-                Case &H83 : channels(1).page = v
-                Case &H87 : channels(0).page = v
+                Case &H81 : channels(2).Page = value
+                Case &H82 : channels(3).Page = value
+                Case &H83 : channels(1).Page = value
+                Case &H87 : channels(0).Page = value
             End Select
         End If
     End Sub
@@ -446,3 +450,447 @@
         End Get
     End Property
 End Class
+
+'Public Class DMAI8237
+'    Inherits IOPortHandler
+
+'    ' Switches between low/high byte of address and count registers
+'    Private msbFlipFlop As Boolean
+
+'    ' Command register (8-bit)
+'    Private cmdReg As Integer
+
+'    ' Status register (8-bit)
+'    Private statusReg As Integer
+
+'    ' Temporary register (8-bit)
+'    Private tempReg As Integer
+
+'    ' Bitmask of active software DMA requests (bits 0-3)
+'    Private reqReg As Integer
+
+'    ' Mask register (bits 0-3)
+'    Public MaskReg As Integer
+
+'    ' Channel with highest priority
+'    Private prioChannel As Integer
+
+'    ' Four DMA channels in the I8237 chip
+'    Private ReadOnly channels() As Channel
+
+'    ' CPU
+'    Private cpu As X8086
+
+'    ' True if the background task is currently scheduled
+'    Private pendingTask As Boolean
+
+'    ' Channel 0 DREQ trigger period for lazy simulation
+'    Private ch0TriggerPeriod As Long
+
+'    Private Class TaskSC
+'        Inherits Scheduler.Task
+
+'        Public Sub New(owner As IOPortHandler)
+'            MyBase.New(owner)
+'        End Sub
+
+'        Public Overrides Sub Run()
+'            Owner.Run()
+'        End Sub
+
+'        Public Overrides ReadOnly Property Name As String
+'            Get
+'                Return Owner.Name
+'            End Get
+'        End Property
+'    End Class
+'    Private task As Scheduler.Task = New TaskSC(Me)
+
+'    ' Scheduler time stamp for the first channel 0 DREQ trigger
+'    ' that has not yet been accounted for, or -1 to disable
+'    Private ch0NextTrigger As Long
+
+'    Public Class Channel
+'        Implements IDMAChannel
+
+'        ' Base address register (16-bit)
+'        Public BaseAddress As Integer
+
+'        ' Base count register (16-bit)
+'        Public BaseCount As Integer
+
+'        ' Current address register (16-bit)
+'        Public CurrentAddress As Integer
+
+'        ' Current count register (16-bit)
+'        Public CurrentCount As Integer
+
+'        ' Mode register (bits 2-7)
+'        Public Mode As Integer
+
+'        ' Page (address bits 16 - 23) for this channel.
+'        Public Page As Integer
+
+'        ' Device with which this channel is currently associated.
+'        Public Device As IDMADevice
+
+'        ' True if DREQ is active for this channel.
+'        Public PendingRequest As Boolean
+
+'        ' True if the device signaled external EOP.
+'        Public ExternalEop As Boolean
+
+'        Private PortDevice As DMAI8237
+
+'        ' Constructs channel.
+'        Public Sub New(dmaDev As DMAI8237)
+'            Me.PortDevice = dmaDev
+'        End Sub
+
+'        Public Sub DMAEOP() Implements IDMAChannel.DMAEOP
+'            ExternalEop = True
+'        End Sub
+
+'        Public Sub DMARequest(enable As Boolean) Implements IDMAChannel.DMARequest
+'            PendingRequest = enable
+'            PortDevice.TryHandleRequest()
+'        End Sub
+'    End Class
+
+'    Public Overrides Sub Run()
+'        pendingTask = False
+'        TryHandleRequest()
+'    End Sub
+
+'    Public Sub New(cpu As X8086)
+'        Me.cpu = cpu
+'        ReDim channels(4)
+'        For i As Integer = 0 To 4 - 1
+'            channels(i) = New Channel(Me)
+'        Next
+'        MaskReg = &HF '  mask all channels
+'        ch0NextTrigger = -1
+
+'        For i As UInt32 = &H0 To &HF
+'            ValidPortAddress.Add(i)
+'        Next
+
+'        For i As UInt32 = &H80 To &H8F
+'            ValidPortAddress.Add(i)
+'        Next
+'    End Sub
+
+'    Public Function GetChannel(channelNumber As Integer) As IDMAChannel
+'        Return channels(channelNumber)
+'    End Function
+
+'    ' Binds a device to a DMA channel.
+'    ' @param change DMA channel to use (0 ... 3)
+'    ' @param dev    device object to use for callbacks on this channel
+'    ' @return the DmaChannel object
+'    Public Function BindChannel(channelNumber As Integer, dev As IDMADevice) As IDMAChannel
+'        If channelNumber = 0 Then Throw New ArgumentException("Can not bind DMA channel 0")
+'        channels(channelNumber).Device = dev
+'        channels(channelNumber).PendingRequest = False
+'        channels(channelNumber).ExternalEop = False
+'        Return channels(channelNumber)
+'    End Function
+
+'    ' Changes the DREQ trigger period for channel 0.
+'    '@param period trigger period in nanoseconds, or 0 to disable
+'    Public Sub SetCh0Period(period As Long)
+'        UpdateCh0()
+'        ch0TriggerPeriod = period
+'        If ch0NextTrigger = -1 AndAlso period > 0 Then ch0NextTrigger = cpu.Sched.CurrentTime + period
+'    End Sub
+
+'    ' Updates the lazy simulation of the periodic channel 0 DREQ trigger.
+'    Protected Sub UpdateCh0()
+'        ' Figure out how many channel 0 DREQ triggers have occurred since
+'        ' the last update, and update channel 0 status to account for
+'        ' these triggers.
+
+'        Dim t As Long = cpu.Sched.CurrentTime
+'        Dim ntrigger As Long = 0
+'        If ch0NextTrigger >= 0 AndAlso ch0NextTrigger <= t Then
+'            ' Rounding errors cause some divergence between DMA channel 0 and
+'            ' timer channel 1, but probably nobody will notice.
+'            If ch0TriggerPeriod > 0 Then
+'                Dim d As Long = t - ch0NextTrigger
+'                ntrigger = 1 + d / ch0TriggerPeriod
+'                ch0NextTrigger = t + ch0TriggerPeriod - (d Mod ch0TriggerPeriod)
+'            Else
+'                ntrigger = 1
+'                ch0NextTrigger = -1
+'            End If
+'        End If
+
+'        If ntrigger = 0 Then Exit Sub
+
+'        ' Ignore triggers if DMA controller is disabled
+'        If (cmdReg And &H4) <> 0 Then Exit Sub
+
+'        ' Ignore triggers if channel 0 is masked
+'        If (MaskReg And 1) = 1 Then Exit Sub
+
+'        ' The only sensible mode for channel 0 in a PC is
+'        ' auto-initialized single read mode, so we simply assume that.
+
+'        ' Update count, address and status registers to account for
+'        ' the past triggers.
+'        Dim addrstep As Integer = If((cmdReg And &H2) = 0, If((channels(0).Mode And &H20) = 0, 1, -1), 0)
+'        If ntrigger <= channels(0).CurrentCount Then
+'            ' no terminal count
+'            Dim n As Integer = CInt(ntrigger)
+'            channels(0).CurrentCount -= n
+'            channels(0).CurrentAddress = (channels(0).CurrentAddress + n * addrstep) And &HFFFF
+'        Else
+'            ' terminal count occurred
+'            Dim n As Integer = CInt((ntrigger - channels(0).CurrentCount - 1) Mod (channels(0).BaseCount + 1))
+'            channels(0).CurrentCount = channels(0).BaseCount - n
+'            channels(0).CurrentAddress = (channels(0).BaseAddress + n * addrstep) And &HFFFF
+'            statusReg = statusReg Or 1
+'        End If
+'    End Sub
+
+'    Protected Sub TryHandleRequest()
+'        Dim i As Integer
+
+'        ' Update request bits in status register
+'        Dim rbits As Integer = reqReg
+'        For i = 0 To 4 - 1
+'            If channels(i).PendingRequest Then rbits = rbits Or (1 << i)
+'        Next
+'        statusReg = (statusReg And &HF) Or (rbits << 4)
+
+'        ' Don't start a transfer during dead time after a previous transfer
+'        If pendingTask Then Exit Sub
+
+'        ' Don't start a transfer if the controller is disabled
+'        If (cmdReg And &H4) <> 0 Then Exit Sub
+
+'        ' Select a channel with pending request
+'        rbits = rbits And (Not MaskReg)
+'        rbits = rbits And (Not 1) ' never select channel 0
+'        If rbits = 0 Then Exit Sub
+
+'        i = prioChannel
+'        While ((rbits >> i) And 1) = 0
+'            i = (i + 1) And 3
+'        End While
+
+'        ' Just decided to start a transfer on channel i
+'        Dim chan As Channel = channels(i)
+'        Dim dev As IDMADevice = chan.Device
+'        Dim mode As Integer = chan.Mode
+'        Dim page As Integer = chan.Page
+
+'        ' Update dynamic priority
+'        If (cmdReg And 10) <> 0 Then prioChannel = (i + 1) And 3
+
+'        ' Block further transactions until this one completes
+'        pendingTask = True
+'        Dim transferTime As Long = 0
+
+'        If (mode And &HC0) = &HC0 Then
+'            'log.warn("cascade mode not implemented (channel " + i + ")")
+'            Stop
+'        ElseIf (mode And &HC) = &HC Then
+'            'log.warn("invalid mode on channel " + i)
+'        Else
+'            ' Prepare for transfer
+'            Dim blockmode As Boolean = (mode And &HC0) = &H80
+'            Dim singlemode As Boolean = (mode And &HC0) = &H40
+'            Dim curcount As Integer = chan.CurrentCount
+'            Dim maxlen As Integer = curcount + 1
+'            Dim curaddr As Integer = chan.CurrentAddress
+'            Dim addrstep As Integer = If((chan.Mode And &H20) = 0, 1, -1)
+'            chan.ExternalEop = False
+
+'            ' Don't combine too much single transfers in one atomic action
+'            If singlemode AndAlso maxlen > 25 Then maxlen = 25
+
+'            ' Execute transfer
+'            Select Case mode And &HC
+'                Case &H0
+'                    ' DMA verify
+'                    curcount -= maxlen
+'                    curaddr = (curaddr + maxlen * addrstep) And &HFFFF
+'                    transferTime += 3 * maxlen * Scheduler.BASECLOCK / cpu.Clock
+'                Case &H4
+'                    ' DMA write
+'                    While (maxlen > 0) AndAlso (Not chan.ExternalEop) AndAlso (blockmode OrElse chan.PendingRequest)
+'                        If dev IsNot Nothing Then cpu.Memory((page << 16) Or curaddr) = dev.DMAWrite()
+'                        maxlen -= 1
+'                        curcount -= 1
+'                        curaddr = (curaddr + addrstep) And &HFFFF
+'                        transferTime += 3 * Scheduler.BASECLOCK / cpu.Clock
+'                    End While
+'                Case &H8
+'                    ' DMA read
+'                    While maxlen > 0 AndAlso Not chan.ExternalEop AndAlso (blockmode OrElse chan.PendingRequest)
+'                        If dev IsNot Nothing Then dev.DMARead(cpu.Memory((page << 16) Or curaddr))
+'                        maxlen -= 1
+'                        curcount -= 1
+'                        curaddr = (curaddr + addrstep) And &HFFFF
+'                        transferTime += 3 * Scheduler.BASECLOCK / cpu.Clock
+'                    End While
+'            End Select
+
+'            ' Update registers
+'            Dim termcount As Boolean = curcount < 0
+'            chan.CurrentCount = If(termcount, &HFFFF, curcount)
+'            chan.CurrentAddress = curaddr
+
+'            ' Handle terminal count or external EOP
+'            If termcount OrElse chan.ExternalEop Then
+'                If (mode And &H10) = 0 Then
+'                    ' Set mask bit
+'                    MaskReg = MaskReg Or (1 << i)
+'                Else
+'                    ' Auto-initialize
+'                    chan.CurrentCount = chan.BaseCount
+'                    chan.CurrentAddress = chan.BaseAddress
+'                End If
+'                ' Clear software request
+'                reqReg = reqReg And (Not 1 << i)
+'                ' Set TC bit in status register
+'                statusReg = statusReg Or (1 << i)
+'            End If
+
+'            ' Send EOP to device
+'            If termcount AndAlso (Not chan.ExternalEop) AndAlso dev IsNot Nothing Then dev.DMAEOP()
+'        End If
+
+'        ' Schedule a task to run when the simulated DMA transfer completes
+'        cpu.Sched.RunTaskAfter(task, transferTime)
+'    End Sub
+
+'    Public Overrides Function [In](port As UInt32) As UInt16
+'        UpdateCh0()
+'        If (port And &HFFF8) = 0 Then
+'            ' DMA controller: channel status
+'            Dim chan As Channel = channels((port >> 1) And 3)
+'            Dim x As Integer = If((port And 1) = 0, chan.CurrentAddress, chan.CurrentCount)
+'            Dim p As Boolean = msbFlipFlop
+'            msbFlipFlop = Not p
+'            Return If(p, (x >> 8) And &HFF, x And &HFF)
+'        ElseIf (port And &HFFF8) = &H8 Then
+'            ' DMA controller: operation registers
+'            Dim v As Integer
+'            Select Case port
+'                Case 8 ' read status register
+'                    v = statusReg
+'                    statusReg = statusReg And &HF0
+'                    Return v
+'                Case 13 ' read temporary register
+'                    Return tempReg
+'            End Select
+'        End If
+
+'        Return &HFF
+'    End Function
+
+'    Public Overrides Sub Out(port As UInt32, value As UInt16)
+'        UpdateCh0()
+
+'        If (port And &HFFF8) = 0 Then
+'            ' DMA controller: channel setup
+'            Dim chan As Channel = channels((port >> 1) And 3)
+
+'            Dim x As Integer
+'            Dim y As Integer
+
+'            If (port And 1) = 0 Then
+'                ' base/current address
+'                x = chan.BaseAddress
+'                y = chan.CurrentAddress
+'            Else
+'                x = chan.BaseCount
+'                y = chan.CurrentCount
+'            End If
+'            Dim p As Boolean = msbFlipFlop
+'            msbFlipFlop = Not p
+'            If p Then
+'                x = (x And &HFF) Or ((value << 8) And &HFF00)
+'                y = (y And &HFF) Or ((value << 8) And &HFF00)
+'            Else
+'                x = (x And &HFF00) Or (value And &HFF)
+'                y = (y And &HFF00) Or (value And &HFF)
+'            End If
+'            If (port And 1) = 0 Then
+'                chan.BaseAddress = x
+'                chan.CurrentAddress = y
+'            Else
+'                chan.BaseCount = x
+'                chan.CurrentCount = y
+'            End If
+'        ElseIf (port And &HFFF8) = &H8 Then
+'            ' DMA controller: operation registers
+'            Select Case port And &HF
+'                Case 8 ' write command register
+'                    cmdReg = value
+'                    If (value And &H10) = 0 Then prioChannel = 0 ' enable fixed priority
+'                    If (value And 1) = 1 Then cpu.RaiseException("DMA8237: memory-to-memory transfer not implemented")
+
+'                Case 9 ' set/reset request register
+'                    If (value And 4) = 0 Then
+'                        reqReg = reqReg And (Not 1 << (value And 3)) ' reset request bit
+'                    Else
+'                        reqReg = reqReg Or (1 << (value And 3))  ' set request bit
+'                        If (value And 7) = 4 Then cpu.RaiseException("DMA8237: software request on channel 0 not implemented")
+'                    End If
+
+'                Case 10 ' set/reset mask register
+'                    If (value And 4) = 0 Then
+'                        MaskReg = MaskReg And (Not 1 << (value And 3)) ' reset mask bit
+'                    Else
+'                        MaskReg = MaskReg Or (1 << (value And 3))  ' set mask bit
+'                    End If
+
+'                Case 11 ' write mode register
+'                    channels(value And 3).Mode = value
+'                    If (value And 3) = 0 AndAlso (value And &HDC) <> &H58 Then cpu.RaiseException("DMA8237: unsupported mode on channel 0")
+
+'                Case 12 ' clear msb flipflop
+'                    msbFlipFlop = False
+
+'                Case 13 ' master clear
+'                    msbFlipFlop = False
+'                    cmdReg = 0
+'                    statusReg = 0
+'                    reqReg = 0
+'                    tempReg = 0
+'                    MaskReg = &HF
+
+'                Case 14 ' clear mask register
+'                    MaskReg = 0
+
+'                Case 15 ' write mask register
+'                    MaskReg = value
+'            End Select
+'            TryHandleRequest()
+
+'        ElseIf (port And &HFFF8) = &H80 Then
+'            ' DMA page registers
+'            Select Case port
+'                Case &H81 : channels(2).Page = value
+'                Case &H82 : channels(3).Page = value
+'                Case &H83 : channels(1).Page = value
+'                Case &H87 : channels(0).Page = value
+'            End Select
+'        End If
+'    End Sub
+
+'    Public Overrides ReadOnly Property Description As String
+'        Get
+'            Return "DMA Controller"
+'        End Get
+'    End Property
+
+'    Public Overrides ReadOnly Property Name As String
+'        Get
+'            Return "8237"
+'        End Get
+'    End Property
+'End Class
diff --git a/x8086NetEmu/Chipset/IIOPortHandler.vb b/x8086NetEmu/Chipset/IIOPortHandler.vb
index eb801fa..7405c66 100644
--- a/x8086NetEmu/Chipset/IIOPortHandler.vb
+++ b/x8086NetEmu/Chipset/IIOPortHandler.vb
@@ -1,8 +1,8 @@
 ï»¿Public Interface IIOPortHandler
     ReadOnly Property ValidPortAddress As List(Of UInt32)
 
-    Sub Out(port As UInt32, value As UInt32)
-    Function [In](port As UInt32) As UInt32
+    Sub Out(port As UInt32, value As UInt16)
+    Function [In](port As UInt32) As UInt16
     ReadOnly Property Name() As String
     ReadOnly Property Description() As String
     Sub Run()
diff --git a/x8086NetEmu/Chipset/IOPortHandler.vb b/x8086NetEmu/Chipset/IOPortHandler.vb
index 9ce1a16..94bd438 100644
--- a/x8086NetEmu/Chipset/IOPortHandler.vb
+++ b/x8086NetEmu/Chipset/IOPortHandler.vb
@@ -15,13 +15,13 @@ Public MustInherit Class IOPortHandler
         End Get
     End Property
 
-    Public MustOverride Sub Out(port As UInt32, value As UInt32) Implements IIOPortHandler.Out
-    Public MustOverride Function [In](port As UInt32) As UInt32 Implements IIOPortHandler.In
+    Public MustOverride Sub Out(port As UInt32, value As UInt16) Implements IIOPortHandler.Out
+    Public MustOverride Function [In](port As UInt32) As UInt16 Implements IIOPortHandler.In
     Public MustOverride ReadOnly Property Description As String Implements IIOPortHandler.Description
     Public MustOverride ReadOnly Property Name As String Implements IIOPortHandler.Name
     Public MustOverride Sub Run() Implements IIOPortHandler.Run
 
-    Public Overridable Function GetPendingInterrupt() As Integer Implements IInterruptController.GetPendingInterrupt
+    Public Overridable Function GetPendingInterrupt() As Byte Implements IInterruptController.GetPendingInterrupt
         Return -1
     End Function
 
diff --git a/x8086NetEmu/Chipset/PIC8259.vb b/x8086NetEmu/Chipset/PIC8259.vb
index ce51f7c..8ab3f15 100644
--- a/x8086NetEmu/Chipset/PIC8259.vb
+++ b/x8086NetEmu/Chipset/PIC8259.vb
@@ -15,30 +15,30 @@
 
     Private slave() As PIC8259
     Private master As PIC8259
-    Private masterIrq As Integer
+    Private masterIrq As Byte
 
     Private levelTriggered As Boolean
     Private autoEOI As Boolean
     Private autoRotate As Boolean
-    Private baseVector As Integer
+    Private baseVector As Byte
     Private specialMask As Boolean
     Private specialNest As Boolean
     Private pollMode As Boolean
     Private readISR As Boolean
-    Private lowPrio As Integer
-    Private slaveInput As Integer
-    Private cascadeId As Integer
-    Private rIMR As Integer
-    Private rIRR As Integer
-    Private rISR As Integer
+    Private lowPrio As Byte
+    Private slaveInput As Byte
+    Private cascadeId As Byte
+    Private rIMR As Byte
+    Private rIRR As Byte
+    Private rISR As Byte
 
     Public Class IRQLine
         Inherits InterruptRequest
 
         Private mPic As PIC8259
-        Private mIrq As Integer
+        Private mIrq As Byte
 
-        Public Sub New(pic As PIC8259, irq As Integer)
+        Public Sub New(pic As PIC8259, irq As Byte)
             mPic = pic
             mIrq = irq
         End Sub
@@ -68,30 +68,27 @@
         state = States.ICW1
     End Sub
 
-    Public Overrides Function GetPendingInterrupt() As Integer
+    Public Overrides Function GetPendingInterrupt() As Byte
         If state <> States.Ready Then Return -1
 
         ' Determine set of pending interrupt requests
-        Dim reqmask As Integer = rIRR And (Not rIMR)
+        Dim reqmask As Byte = rIRR And (Not rIMR)
         If specialNest Then
             reqmask = reqmask And ((Not rISR) Or slaveInput)
         Else
             reqmask = reqmask And (Not rISR)
         End If
 
-        ' NOTE: This appears to fix an issue with the current mouse adapter
-        reqmask = reqmask And &HFF
-
         ' Select non-masked request with highest priority
-        If reqmask = 0 Then Return -1
+        If reqmask = 0 Then Return &HFF
 
         Dim irq As Integer = (lowPrio + 1) And 7
         While (reqmask And (1 << irq)) = 0
-            If Not specialMask AndAlso ((rISR And (1 << irq)) <> 0) Then Return -1 ' ISR bit blocks all lower-priority requests
+            If Not specialMask AndAlso ((rISR And (1 << irq)) <> 0) Then Return &HFF ' ISR bit blocks all lower-priority requests
             irq = (irq + 1) And 7
         End While
 
-        Dim irqbit As Integer = (1 << irq)
+        Dim irqbit As Byte = 1 << irq
 
         ' Update controller state
         If Not autoEOI Then rISR = rISR Or irqbit
@@ -103,29 +100,29 @@
         If (slaveInput And irqbit) <> 0 AndAlso slave(irq) IsNot Nothing Then
             Return slave(irq).GetPendingInterrupt()
         Else
-            Return (baseVector + irq) And &HFF
+            Return (baseVector + irq)
         End If
     End Function
 
-    Public Function GetIrqLine(i As Integer) As IRQLine
+    Public Function GetIrqLine(i As Byte) As IRQLine
         Return New IRQLine(Me, i)
     End Function
 
-    Public Sub RaiseIrq(irq As Integer, enable As Boolean)
+    Public Sub RaiseIrq(irq As Byte, enable As Boolean)
         If enable Then
             rIRR = rIRR Or (1 << irq)
         Else
-            rIRR = rIRR And (Not (1 << irq))
+            rIRR = rIRR And (Not 1 << irq)
         End If
         If master IsNot Nothing Then UpdateSlaveOutput()
     End Sub
 
-    Public Overrides Function [In](port As UInt32) As UInt32
+    Public Overrides Function [In](port As UInt32) As UInt16
         If (port And 1) = 0 Then
             ' A0 == 0
             If pollMode Then
-                Dim a = GetPendingInterrupt()
-                Return If(a = -1, 0, &H80 Or a)
+                Dim pi As Byte = GetPendingInterrupt()
+                Return If(pi = -1, 0, &H80 Or pi)
             End If
             Return If(readISR, rISR, rIRR)
         Else
@@ -134,23 +131,23 @@
         End If
     End Function
 
-    Public Overrides Sub Out(port As UInt32, value As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
         If (port And 1) = 0 Then
             ' A0 = 0
             If (value And &H10) <> 0 Then
-                doICW1(value)
+                DoICW1(value)
             ElseIf (value And &H8) = 0 Then
-                doOCW2(value)
+                DoOCW2(value)
             Else
-                doOCW3(value)
+                DoOCW3(value)
             End If
         Else
             ' A0 == 1
             Select Case state
-                Case States.ICW2 : doICW2(value)
-                Case States.ICW3 : doICW3(value)
-                Case States.ICW4 : doICW4(value)
-                Case Else : doOCW1(value)
+                Case States.ICW2 : DoICW2(value)
+                Case States.ICW3 : DoICW3(value)
+                Case States.ICW4 : DoICW4(value)
+                Case Else : DoOCW1(value)
             End Select
         End If
     End Sub
@@ -158,17 +155,17 @@
     Private Sub UpdateSlaveOutput()
         Dim reqmask As Integer = rIRR And (Not rIMR)
         If Not specialMask Then reqmask = reqmask And (Not rISR)
-        If master IsNot Nothing Then master.RaiseIrq(masterIrq, (reqmask <> 0))
+        If master IsNot Nothing Then master.RaiseIrq(masterIrq, reqmask <> 0)
     End Sub
 
-    Public Sub SetMaster(pic As PIC8259, irq As Integer)
+    Public Sub SetMaster(pic As PIC8259, irq As Byte)
         If master IsNot Nothing Then master.slave(cascadeId) = Nothing
         master = pic
         masterIrq = irq
         If master IsNot Nothing Then master.slave(cascadeId) = Me
     End Sub
 
-    Private Sub doICW1(v As Integer)
+    Private Sub DoICW1(v As Byte)
         state = States.ICW2
         rIMR = 0
         rISR = 0
@@ -189,12 +186,12 @@
         If master IsNot Nothing Then UpdateSlaveOutput()
     End Sub
 
-    Private Sub doICW2(v As Integer)
+    Private Sub DoICW2(v As Byte)
         baseVector = v And &HF8
         state = If(expectICW3, If(expectICW4, States.ICW4, States.Ready), States.ICW3)
     End Sub
 
-    Private Sub doICW3(v As Integer)
+    Private Sub DoICW3(v As Byte)
         slaveInput = v
         If master IsNot Nothing Then master.slave(cascadeId) = Nothing
         cascadeId = v And &H7
@@ -202,27 +199,27 @@
         state = If(expectICW4, States.ICW4, States.Ready)
     End Sub
 
-    Private Sub doICW4(v As Integer)
+    Private Sub DoICW4(v As Byte)
         specialNest = (v And &H10) <> 0
         autoEOI = (v And &H2) <> 0
         state = States.Ready
     End Sub
 
-    Private Sub doOCW1(v As Integer)
+    Private Sub DoOCW1(v As Byte)
         rIMR = v
         If master IsNot Nothing Then UpdateSlaveOutput()
     End Sub
 
-    Private Sub doOCW2(v As Integer)
-        Dim irq As Integer = v And &H7
+    Private Sub DoOCW2(v As Byte)
+        Dim irq As Byte = v And &H7
         Dim rotate As Boolean = (v And &H80) <> 0
         Dim specific As Boolean = (v And &H40) <> 0
         Dim eoi As Boolean = (v And &H20) <> 0
 
         ' Resolve non-specific EOI
         If Not specific Then
-            Dim m As Integer = If(specialMask, rISR And (Not rIMR), rISR)
-            Dim i As Integer = lowPrio
+            Dim m As Byte = If(specialMask, rISR And (Not rIMR), rISR)
+            Dim i As Byte = lowPrio
             Do
                 i = (i + 1) And 7
                 If (m And (1 << i)) <> 0 Then
@@ -233,7 +230,7 @@
         End If
 
         If eoi Then
-            rISR = rISR And (Not (1 << irq))
+            rISR = rISR And (Not 1 << irq)
             If master IsNot Nothing Then UpdateSlaveOutput()
         End If
 
@@ -244,14 +241,14 @@
         End If
     End Sub
 
-    Private Sub doOCW3(v As Integer)
+    Private Sub DoOCW3(v As Byte)
         If (v And &H40) <> 0 Then
             specialMask = (v And &H20) <> 0
             If master IsNot Nothing Then UpdateSlaveOutput()
         End If
 
         pollMode = (v And &H4) <> 0
-        If (v And &H2) <> 0 Then readISR = ((v And &H1) <> 0)
+        If (v And &H2) <> 0 Then readISR = (v And &H1) <> 0
     End Sub
 
     Public Overrides ReadOnly Property Name As String
diff --git a/x8086NetEmu/Chipset/PIT8254.vb b/x8086NetEmu/Chipset/PIT8254.vb
index ec94e09..0ec30cb 100644
--- a/x8086NetEmu/Chipset/PIT8254.vb
+++ b/x8086NetEmu/Chipset/PIT8254.vb
@@ -146,7 +146,7 @@
         End Function
 
         Public Sub PutByte(v As Integer)
-            If (countMode < 0) Then Return ' undefined state
+            If countMode < 0 Then Return ' undefined state
 
             ' write to count register
             Select Case rwMode
@@ -179,13 +179,13 @@
                 mGgate = value
                 ' mode 2 and mode 3: when gate goes low, output
                 ' is set high immediately
-                If ((Not mGgate) AndAlso ((countMode = 2) OrElse (countMode = 3))) Then outputValue = True
+                If (Not mGgate) AndAlso ((countMode = 2) OrElse (countMode = 3)) Then outputValue = True
             End Set
         End Property
 
         ' Returns current output state
         Public Function GetOutput() As Boolean
-            If (countMode >= 0) Then Update()
+            If countMode >= 0 Then Update()
             Return outputValue
         End Function
 
@@ -201,7 +201,7 @@
                     If active AndAlso mGgate AndAlso (Not outputValue) Then clocks = FromCounter(counterValue) + If(nullCount, 1, 0)
                 Case 1
                     ' output goes high on terminal count
-                    If (Not outputValue) Then clocks = FromCounter(counterValue) + If(trigger, 1, 0)
+                    If Not outputValue Then clocks = FromCounter(counterValue) + If(trigger, 1, 0)
                     ' output goes low on next clock after trigger
                     If outputValue AndAlso trigger Then clocks = 1
                 Case 2
@@ -288,7 +288,7 @@
                                     ((counterValue >> 8) And &HF) * 100 +
                                     ((counterValue >> 4) And &HF) * 10 +
                                     (counterValue And &HF)
-                zero = (c >= 10000 OrElse (v <> 0 AndAlso c >= v))
+                zero = c >= 10000 OrElse (v <> 0 AndAlso c >= v)
                 v += 10000 - (c Mod 10000)
                 counterValue =
                   ((v \ 1000) Mod 10) << 12 Or
@@ -296,7 +296,7 @@
                     ((v \ 10) Mod 10) << 4 Or
                       (v Mod 10)
             Else
-                zero = (c > &HFFFF OrElse (counterValue <> 0 AndAlso c >= counterValue))
+                zero = c > &HFFFF OrElse (counterValue <> 0 AndAlso c >= counterValue)
                 counterValue = (counterValue - c) And &HFFFF
             End If
 
@@ -366,7 +366,7 @@
             ' trigger:   reload counter
             ' on one:    output strobes low
             ' on zero:   reload counter
-            If (trigger) Then
+            If trigger Then
                 ' load counter on trigger
                 counterValue = countRegister
                 nullCount = False
@@ -388,7 +388,7 @@
                 counterValue = ToCounter(v)
             End If
             ' output strobes low on decrement to 1
-            outputValue = (Not mGgate OrElse counterValue <> 1)
+            outputValue = Not mGgate OrElse counterValue <> 1
         End Sub
 
         ' MODE 3 - SQUARE WAVE
@@ -460,7 +460,7 @@
             '  init:      output high, counter running
             '  set count: load counter
             '  on zero:   output strobes low, counter wraps
-            If (active AndAlso nullCount) Then
+            If active AndAlso nullCount Then
                 '  load counter on first clock
                 counterValue = countRegister
                 nullCount = False
@@ -471,7 +471,7 @@
                 '  count down
                 CountDown(clocks)
                 '  output strobes low on zero
-                outputValue = (Not active OrElse counterValue <> 0)
+                outputValue = Not active OrElse counterValue <> 0
             Else
                 '  end previous strobe
                 outputValue = True
@@ -492,11 +492,11 @@
                 active = True
                 clocks -= 1
             End If
-            If (clocks < 0) Then Return
+            If clocks < 0 Then Return
             '  count down
             CountDown(clocks)
             '  output strobes low on zero
-            outputValue = (Not active OrElse counterValue <> 0)
+            outputValue = Not active OrElse counterValue <> 0
         End Sub
 
         ' Called when a new count is written to the Count Register
@@ -587,7 +587,7 @@
         UpdateCh2(0)
     End Sub
 
-    Public Overrides Function [In](port As UInt32) As UInt32
+    Public Overrides Function [In](port As UInt32) As UInt16
         currentTime = cpu.Sched.CurrentTime
         Dim c As Integer = port And 3
         If c = 3 Then
@@ -599,46 +599,46 @@
         End If
     End Function
 
-    Public Overrides Sub Out(port As UInt32, v As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
         currentTime = cpu.Sched.CurrentTime
         Dim c As Integer = port And 3
         If c = 3 Then
             '  write Control Word
             Dim s As Integer
-            c = (v >> 6) And 3
+            c = (value >> 6) And 3
             If c = 3 Then
                 '  Read Back command
                 For i As Integer = 0 To 3 - 1
-                    s = (2 << i)
-                    If (v And (&H10 Or s)) = s Then mChannels(i).LatchStatus()
-                    If (v And (&H20 Or s)) = s Then mChannels(i).LatchOutput()
+                    s = 2 << i
+                    If (value And (&H10 Or s)) = s Then mChannels(i).LatchStatus()
+                    If (value And (&H20 Or s)) = s Then mChannels(i).LatchOutput()
                 Next
             Else
                 '  Channel Control Word
-                If (v And &H30) = 0 Then
+                If (value And &H30) = 0 Then
                     '  Counter Latch command
                     mChannels(c).LatchOutput()
                 Else
                     '  reprogram counter mode
-                    Dim countm As Integer = (v >> 1) And 7
+                    Dim countm As Integer = (value >> 1) And 7
                     If countm > 5 Then countm = countm And 3
-                    Dim rwm As Integer = (v >> 4) And 3
-                    Dim bcdm As Boolean = (v And 1) <> 0
+                    Dim rwm As Integer = (value >> 4) And 3
+                    Dim bcdm As Boolean = (value And 1) <> 0
                     mChannels(c).SetMode(countm, rwm, bcdm)
                     Select Case c
                         Case 0 : UpdateCh0()
                         Case 1 : UpdateCh1()
-                        Case 2 : UpdateCh2(v)
+                        Case 2 : UpdateCh2(value)
                     End Select
                 End If
             End If
         Else
             '  write to counter
-            mChannels(c).PutByte(v)
+            mChannels(c).PutByte(value)
             Select Case c
                 Case 0 : UpdateCh0()
                 Case 1 : UpdateCh1()
-                Case 2 : UpdateCh2(v)
+                Case 2 : UpdateCh2(value)
             End Select
         End If
     End Sub
@@ -680,9 +680,6 @@
             If period = 0 Then
                 mSpeaker.Frequency = 0
             Else
-                ' FIXME: Multiplying by 2000 moves notes three octaves up, 
-                '        while multiplying by 500, the notes played through the speaker, match the notes detected by any tuner.
-                '        But, multiplying by 2000 matches other emulators (such as DosBox) frequency.
                 mSpeaker.Frequency = speakerBaseFrequency / period
             End If
         End If
diff --git a/x8086NetEmu/Chipset/PPI8255.vb b/x8086NetEmu/Chipset/PPI8255.vb
index c059c2a..12d0a0f 100644
--- a/x8086NetEmu/Chipset/PPI8255.vb
+++ b/x8086NetEmu/Chipset/PPI8255.vb
@@ -3,12 +3,11 @@
 
     Private sched As Scheduler
     Private irq As InterruptRequest
-    Private switchS2 As Integer
     Private timer As PIT8254
 
-    Private port61 As Integer
+    Private ppiB As UInt32
     Private keyBuf As String
-    Private lastKeyCode As Integer
+    Private lastKeyCode As UInt16 = 0
     Private keyShiftPending As Boolean
 
     Private keyMap As KeyMap
@@ -35,6 +34,16 @@
     End Class
     Private task As Scheduler.Task = New TaskSC(Me)
 
+    ' Set configuration switch data to be reported by PPI.
+    ' bit 0: diskette drive present
+    ' bit 1: math coprocessor present
+    ' bits 3-2: memory size:
+    '   00=256k, 01=512k, 10=576k, 11=640k
+    ' bits 5-4: initial video mode:
+    '   00=EGA/VGA, 01=CGA 40x25, 10=CGA 80x25 color, 11=MDA 80x25
+    ' bits 7-6: one less than number of diskette drives (1 - 4 drives)
+    Public Property SwitchData As Byte
+
     Public Sub New(cpu As X8086, irq As InterruptRequest)
         For i As Integer = &H60 To &H6F
             ValidPortAddress.Add(i)
@@ -49,7 +58,7 @@
         Me.irq = irq
         If cpu.PIT IsNot Nothing Then
             timer = cpu.PIT
-            timer.SetCh2Gate((port61 And 1) <> 0)
+            timer.SetCh2Gate((ppiB And 1) <> 0)
         End If
 
         keyBuf = ""
@@ -69,18 +78,14 @@
         End Get
     End Property
 
-    Public Overrides Function [In](port As UInt32) As UInt32
-        Select Case (port And 3)
+    Public Overrides Function [In](port As UInt32) As UInt16
+        Select Case port And 3
             Case 0 ' port &h60 (PPI port A)
                 ' Return keyboard data if bit 7 in port B is cleared.
-                If (port61 And &H80) = 0 Then
-                    Return GetKeyData()
-                Else
-                    Return 0
-                End If
+                Return If((ppiB And &H80) = 0, GetKeyData(), 0)
             Case 1 ' port &h61 (PPI port B)
                 ' Return last value written to the port.
-                Return port61
+                Return ppiB
             Case 2 ' port &h62 (PPI port C)
                 Return GetStatusByte()
             Case Else
@@ -89,8 +94,8 @@
         End Select
     End Function
 
-    Public Overrides Sub Out(port As UInt32, v As UInt32)
-        Select Case (port And 3)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
+        Select Case port And 3
             Case 1
                 ' Write to port 0x61 (system control port)
                 ' bit 0: gate signal for timer channel 2
@@ -100,17 +105,14 @@
                 ' bit 5: NMI I/O check disable
                 ' bit 6: enable(1) or disable(0) keyboard clock ??
                 ' bit 7: pulse 1 to reset keyboard and IRQ1
-
-                Dim oldv As Integer = port61
-                port61 = v
-                If (timer IsNot Nothing) AndAlso ((oldv Xor v) And 1) <> 0 Then
-                    timer.SetCh2Gate((port61 And 1) <> 0)
+                Dim oldv As UInt32 = ppiB
+                ppiB = value
+                If (timer IsNot Nothing) AndAlso ((oldv Xor value) And 1) <> 0 Then
+                    timer.SetCh2Gate((ppiB And 1) <> 0)
 #If Win32 Then
-                    If timer.Speaker IsNot Nothing Then timer.Speaker.Enabled = (v And 1) = 1
+                    If timer.Speaker IsNot Nothing Then timer.Speaker.Enabled = (value And 1) = 1
 #End If
                 End If
-            Case 3
-
         End Select
     End Sub
 
@@ -120,18 +122,6 @@
         If keyBuf.Length() > 0 AndAlso irq IsNot Nothing Then irq.Raise(True)
     End Sub
 
-    ' Set configuration switch data to be reported by PPI.
-    ' bit 0: diskette drive present
-    ' bit 1: math coprocessor present
-    ' bits 3-2: memory size:
-    '   00=256k, 01=512k, 10=576k, 11=640k
-    ' bits 5-4: initial video mode:
-    '   00=EGA/VGA, 01=CGA 40x25, 10=CGA 80x25 color, 11=MDA 80x25
-    ' bits 7-6: one less than number of diskette drives (1 - 4 drives)
-    Public Sub SetSwitchData(S2 As Integer)
-        switchS2 = S2
-    End Sub
-
     Private Sub TrimBuffer()
         SyncLock keyBuf
             keyBuf = keyBuf.Substring(1)
@@ -174,7 +164,7 @@
     End Function
 
     ' Get a scancode byte from the buffer
-    Public Function GetKeyData() As Integer
+    Public Function GetKeyData() As UInt16
         ' release interrupt
         If irq IsNot Nothing Then irq.Raise(False)
         ' if the buffer is empty, we just return the most recent byte 
@@ -203,11 +193,11 @@
     ' bit 5: timer 2 output status
     ' bit 6: I/O channel parity error occurred (we always set it to 0)
     ' bit 7: RAM parity error occurred (we always set it to 0)
-    Private Function GetStatusByte() As Integer
-        Dim timerout As Boolean = (timer IsNot Nothing) AndAlso timer.GetOutput(2)
-        Dim speakerout As Boolean = timerout AndAlso ((port61 And 2) <> 0)
+    Private Function GetStatusByte() As Byte
+        Dim timerout As Boolean = timer?.GetOutput(2)
+        Dim speakerout As Boolean = timerout AndAlso ((ppiB And 2) <> 0)
         Dim vh As Integer = If(speakerout, 0, &H10) Or If(timerout, &H20, 0)
-        Dim vl As Integer = If((port61 And &H8) = 0, switchS2, switchS2 >> 4)
+        Dim vl As Integer = If((ppiB And &H8) = 0, SwitchData, SwitchData >> 4)
         Return (vh And &HF0) Or (vl And &HF)
     End Function
 End Class
diff --git a/x8086NetEmu/Chipset/PPI8255_ALT.vb b/x8086NetEmu/Chipset/PPI8255_ALT.vb
index 6a0001b..573ced1 100644
--- a/x8086NetEmu/Chipset/PPI8255_ALT.vb
+++ b/x8086NetEmu/Chipset/PPI8255_ALT.vb
@@ -93,7 +93,7 @@ Public Class PPI8255_ALT
 
                                                            If ((old Xor v) And 2) <> 0 Then
 #If Win32 Then
-                                                               cpu.PIT.Speaker.Enabled = ((v And 2) = 2)
+                                                               cpu.PIT.Speaker.Enabled = (v And 2) = 2
 #End If
                                                            End If
                                                        End Sub)
@@ -138,8 +138,8 @@ Public Class PPI8255_ALT
         End Get
     End Property
 
-    Public Overrides Function [In](port As UInt32) As UInt32
-        Select Case (port And 3)
+    Public Overrides Function [In](port As UInt32) As UInt16
+        Select Case port And 3
             Case 0 ' A
                 Return ReadFromPort(0)
             Case 1 ' B
@@ -153,33 +153,33 @@ Public Class PPI8255_ALT
         End Select
     End Function
 
-    Public Overrides Sub Out(port As UInt32, v As UInt32)
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
         Select Case port And 3
             Case 0 ' A
-                WriteToPort(0, v)
+                WriteToPort(0, value)
             Case 1 ' B
-                WriteToPort(1, v)
+                WriteToPort(1, value)
             Case 2 ' C
-                WriteToPort(2, v)
+                WriteToPort(2, value)
             Case 3
-                If (v And &H80) <> 0 Then
-                    mode = v
-
-                    modeGroupA = (v >> 5) And &H3
-                    modeGroupB = (v >> 2) And &H1
-                    ports(0).Inp = If((v And &H10) <> 0, &HFF, 0)
-                    ports(1).Inp = If((v And &H2) <> 0, &HFF, 0)
-                    ports(2).Inp = If((v And &H1) <> 0, &HF, 0)
-                    ports(2).Inp = ports(2).Inp Or If((v And &H8) <> 0, &HF0, 0)
+                If (value And &H80) <> 0 Then
+                    mode = value
+
+                    modeGroupA = (value >> 5) And &H3
+                    modeGroupB = (value >> 2) And &H1
+                    ports(0).Inp = If((value And &H10) <> 0, &HFF, 0)
+                    ports(1).Inp = If((value And &H2) <> 0, &HFF, 0)
+                    ports(2).Inp = If((value And &H1) <> 0, &HF, 0)
+                    ports(2).Inp = ports(2).Inp Or If((value And &H8) <> 0, &HF0, 0)
                 Else
-                    Dim bit As Byte = (v >> 1) And &H7
-                    If (v And 1) <> 0 Then
-                        v = ports(2).Output Or (1 << bit)
+                    Dim bit As Byte = (value >> 1) And &H7
+                    If (value And 1) <> 0 Then
+                        value = ports(2).Output Or (1 << bit)
                     Else
-                        v = ports(2).Output And (Not (1 << bit))
+                        value = ports(2).Output And (Not 1 << bit)
                     End If
 
-                    WriteToPort(2, v)
+                    WriteToPort(2, value)
                 End If
         End Select
     End Sub
@@ -201,7 +201,7 @@ Public Class PPI8255_ALT
         End If
 
         v = ports(port).Input And ports(port).Inp
-        v = v Or (ports(port).Output And (Not (ports(port).Inp)))
+        v = v Or (ports(port).Output And (Not ports(port).Inp))
 
         Return v
     End Function
diff --git a/x8086NetEmu/Chipset/RTC.vb b/x8086NetEmu/Chipset/RTC.vb
index 75cbae6..341495e 100644
--- a/x8086NetEmu/Chipset/RTC.vb
+++ b/x8086NetEmu/Chipset/RTC.vb
@@ -3,28 +3,20 @@
 
     Private irq As InterruptRequest
 
-    Private Delegate Sub ReadFunction()
+    Private Delegate Function ReadFunction() As Integer
     Private Delegate Sub WriteFunction(v As Integer)
 
-    Private Const YEAR = 7
-    Private Const MONTH = 6
-    Private Const DAY = 5
-    Private Const DOW = 4
-    Private Const HOUR = 3
-    Private Const MINUTE = 2
-    Private Const SECOND = 1
-    Private Const CENTURY = 0
+    Private index As Integer
 
-    ' CENTURY
-    Private Const CENTURY_W = &H80
-    Private Const CENTURY_R = &H40
+    Private cmosA As Integer = &H26
+    Private cmosB As Integer = &H2
+    Private cmosC As Integer = 0
+    Private cmosData(128 - 1) As Integer
 
-    ' DOW
-    Private Const DOW_BF = &H80
-    Private Const DOW_FT = &H40
-
-    ' SECONDS
-    Private Const SECOND_NOSC = &H80
+    Private periodicInt As Long
+    Private nextInt As Long
+    Private lastUpdate As Long
+    Private ticks As Long
 
     Private Const baseFrequency As Integer = 32.768 * X8086.KHz
 
@@ -47,24 +39,6 @@
     End Class
     Private task As Scheduler.Task = New TaskSC(Me)
 
-    Private Structure DS1743
-        Public Read As ReadFunction
-        Public Write As WriteFunction
-
-        Public Count As UInt16
-        Public RAM() As Byte
-
-        Public Year As UInt16
-        Public Month As UInt16
-        Public Day As UInt16
-        Public Dow As UInt16
-        Public Hour As UInt16
-        Public Minute As UInt16
-        Public Second As UInt16
-    End Structure
-
-    Private data As DS1743
-
     Public Sub New(cpu As X8086, irq As InterruptRequest)
         Me.irq = irq
 
@@ -72,115 +46,106 @@
             ValidPortAddress.Add(i)
         Next
 
-        ReDim data.RAM(8192 - 1)
-        data.Count = 8
-        data.Year = 2000
-
-        data.Read = New ReadFunction(Sub()
-                                         data.Year = Now.Year
-                                         data.Month = Now.Month
-                                         data.Day = Now.Day
-
-                                         data.Hour = Now.Hour
-                                         data.Minute = Now.Minute
-                                         data.Second = Now.Second
-
-                                         data.Dow = Now.DayOfWeek
-                                     End Sub)
-
-        data.Write = New WriteFunction(Sub()
-
-                                       End Sub)
-
-        Clock2RAM()
-    End Sub
-
-    Private Sub Clock2RAM()
-        If data.RAM(CENTURY) And CENTURY_R Then Exit Sub
-
-        Dim v As UInt16
-
-        v = ToBCD(data.Year / 100)
-        data.RAM(CENTURY) = data.RAM(CENTURY) And &HC0
-        data.RAM(CENTURY) = data.RAM(CENTURY) Or (v And &H3F)
-
-        v = ToBCD(data.Year Mod 100)
-        data.RAM(YEAR) = v
-
-        v = ToBCD(data.Month + 1)
-        data.RAM(MONTH) = data.RAM(MONTH) And &HE0
-        data.RAM(MONTH) = data.RAM(MONTH) Or (v And &H1F)
-
-        v = ToBCD(data.Dow + 1)
-        data.RAM(DOW) = data.RAM(DOW) And &HC0
-        data.RAM(DOW) = data.RAM(DOW) Or (v And &H3F)
-
-        v = ToBCD(data.Hour)
-        data.RAM(HOUR) = data.RAM(HOUR) And &H80
-        data.RAM(HOUR) = data.RAM(HOUR) Or (v And &H3F)
-
-        v = ToBCD(data.Minute)
-        data.RAM(MINUTE) = data.RAM(MINUTE) And &H80
-        data.RAM(MINUTE) = data.RAM(MINUTE) Or (v And &H7F)
+        For i As Integer = &H2C0 To &H2CF
+            ValidPortAddress.Add(i)
+        Next
 
-        v = ToBCD(data.Second)
-        data.RAM(SECOND) = data.RAM(SECOND) And &H80
-        data.RAM(SECOND) = data.RAM(SECOND) Or (v And &H7F)
+        'cpu.TryAttachHook(&H8, New X8086.IntHandler(Function()
+        '                                                Dim t As Long = Now.Ticks
+        '                                                ticks += 2
+        '                                                lastUpdate = t
+
+        '                                                If nextInt < t Then
+        '                                                    cmosC = cmosC Or ((1 << 6) Or (1 << 7))
+        '                                                    nextInt += periodicInt * Math.Ceiling((t - nextInt) / periodicInt)
+        '                                                End If
+
+        '                                                Return False
+        '                                            End Function))
+
+        'cpu.TryAttachHook(&H1A, New X8086.IntHandler(Function()
+        '                                                 Select Case cpu.Registers.AH
+        '                                                     Case 0
+        '                                                         cpu.Registers.AL = 0
+        '                                                         cpu.Registers.CX = (ticks >> 16) And &HFFFF
+        '                                                         cpu.Registers.DX = ticks And &HFFFF
+        '                                                         Return True
+        '                                                     Case 2
+        '                                                         cpu.Registers.CH = [In](4)
+        '                                                         cpu.Registers.CL = [In](2)
+        '                                                         cpu.Registers.DH = [In](0)
+        '                                                         cpu.Registers.DL = 0
+        '                                                         cpu.Flags.CF = 0
+        '                                                         Return True
+        '                                                 End Select
+
+        '                                                 Return False
+        '                                             End Function))
     End Sub
 
-    Private Sub RAM2Clock()
-        If data.RAM(CENTURY) And CENTURY_W Then Exit Sub
-
-        Dim v As UInt16
-
-        v = FromBCD(data.RAM(CENTURY) And &H3F)
-        data.Year = 10 * (v + 1)
-
-        v = FromBCD(data.RAM(YEAR))
-        data.Year += v
-
-        v = FromBCD(data.RAM(MONTH) And &H1F)
-        data.Month = v - 1
-
-        v = FromBCD(data.RAM(DAY) And &H3F)
-        data.Day = v - 1
-
-        v = FromBCD(data.RAM(DOW) And &H7)
-        data.Dow = v - 1
-
-        v = FromBCD(data.RAM(HOUR) And &H3F)
-        data.Hour = v
-
-        v = FromBCD(data.RAM(MINUTE) And &H7F)
-        data.Minute = v
-
-        v = FromBCD(data.RAM(SECOND) And &H7F)
-        data.Second = v
-    End Sub
+    Private Function EncodeTime(t As UInt16) As UInt16
+        If (cmosB And &H4) <> 0 Then
+            Return t
+        Else
+            Return ToBCD(t)
+        End If
+    End Function
 
     Private Function ToBCD(v As UInt16) As UInt16
-        If v >= 100 Then v = v Mod 100
-        Return ((v Mod 10) + 16 * (v / 10))
+        'If v >= 100 Then v = v Mod 100
+        'Return (v Mod 10) + 16 * (v / 10)
+
+        Dim i As Integer = 0
+        Dim r As Integer = 0
+        Dim d As Integer = 0
+
+        While v <> 0
+            d = v Mod 10
+            r = r Or (d << (4 * i))
+            i += 1
+            v = (v - d) \ 10
+        End While
+        Return r
     End Function
 
     Private Function FromBCD(v As UInt16) As UInt16
         If (v And &HF) > &H9 Then v += &H6
         If (v And &HF0) > &H90 Then v += &H60
-        Return ((v And &HF) + 10 * ((v >> 4) And &HF0))
+        Return (v And &HF) + 10 * ((v >> 4) And &HF0)
     End Function
 
-    Public Overrides Function [In](port As UInt32) As UInt32
-        Clock2RAM()
+    Public Overrides Function [In](port As UInt32) As UInt16
+        Select Case index
+            Case &H0 : Return EncodeTime(Now.ToUniversalTime().Second)
+            Case &H2 : Return EncodeTime(Now.ToUniversalTime().Minute)
+            Case &H4 : Return EncodeTime(Now.ToUniversalTime().Hour)
+            Case &H7 : Return EncodeTime(Now.ToUniversalTime().Day)
+            Case &H8 : Return EncodeTime(Now.ToUniversalTime().Month + 1)
+            Case &H9 : Return EncodeTime(Now.ToUniversalTime().Year Mod 100)
 
-        data.Read()
+            Case &HA : Return cmosA
+            Case &HB : Return cmosB
+            Case &HC : Return cmosC And (Not &HF0)
+            Case &HD : Return &HFF
 
-        Stop
+            Case &H32 : Return EncodeTime(Now.ToUniversalTime().Year \ 100)
+        End Select
 
-        Return 0 ' Just to suppress the warning
+        Return cmosData(index)
     End Function
 
-    Public Overrides Sub Out(port As UInt32, value As UInt32)
-        Stop
+    Public Overrides Sub Out(port As UInt32, value As UInt16)
+        If (port = &H70) OrElse (port = &H2C0) Then
+            index = value And &H7F
+        Else
+            Select Case index
+                Case &HA
+                    cmosA = value And &H7F
+                    periodicInt = 1000 / (32768 >> (cmosA And &HF) - 1)
+                Case &HB : cmosB = value
+                Case Else : cmosData(index) = value
+            End Select
+        End If
     End Sub
 
     Public Overrides ReadOnly Property Name As String
diff --git a/x8086NetEmu/Helpers/ConsoleCrayon.vb b/x8086NetEmu/Helpers/ConsoleCrayon.vb
index 29eaa68..6c46e30 100644
--- a/x8086NetEmu/Helpers/ConsoleCrayon.vb
+++ b/x8086NetEmu/Helpers/ConsoleCrayon.vb
@@ -46,14 +46,9 @@ Public NotInheritable Class ConsoleCrayon
     Public Const toRadians As Double = Math.PI / 180
     Public Const toDegrees As Double = 180 / Math.PI
 
-    Private Shared mForegroundColor As ConsoleColor
-    Private Shared mBackgroundColor As ConsoleColor
-
     Public Shared SyncObject As New Object()
 
     Public Shared Sub WriteFast(text As String, foreColor As ConsoleColor, backColor As ConsoleColor, col As Integer, row As Integer)
-        'Exit Sub
-
         SyncLock SyncObject
             If col < 0 OrElse col >= Console.WindowWidth OrElse
             row < 0 OrElse row >= Console.WindowHeight Then Exit Sub
@@ -67,18 +62,12 @@ Public NotInheritable Class ConsoleCrayon
                 If Console.CursorLeft <> col Then Console.CursorLeft = col
                 If Console.CursorTop <> row Then Console.CursorTop = row
 
-                If foreColor <> mForegroundColor Then
-                    Console.ForegroundColor = foreColor
-                    mForegroundColor = foreColor
-                End If
-                If backColor <> mBackgroundColor Then
-                    Console.BackgroundColor = backColor
-                    mBackgroundColor = backColor
-                End If
+                If foreColor <> Console.ForegroundColor Then Console.ForegroundColor = foreColor
+                If backColor <> Console.BackgroundColor Then Console.BackgroundColor = backColor
 
-                If row = Console.WindowHeight - 1 AndAlso col + text.Length >= Console.WindowWidth Then
-                    text = text.Substring(0, (text.Length * 2 + col) - Console.WindowWidth - 1)
-                End If
+                Dim index As Integer = col + row * Console.WindowWidth
+                Dim size As Integer = Console.WindowWidth * Console.WindowHeight
+                If index + text.Length >= size Then text = text.Substring(0, size - index - 1)
 
                 Console.Write(text)
             End If
@@ -87,25 +76,19 @@ Public NotInheritable Class ConsoleCrayon
 
     Public Shared Property ForegroundColor() As ConsoleColor
         Get
-            Return mForegroundColor
+            Return Console.ForegroundColor
         End Get
         Set(value As ConsoleColor)
-            If mForegroundColor <> value Then
-                mForegroundColor = value
-                SetColor(mForegroundColor, True)
-            End If
+            If Console.ForegroundColor <> value Then SetColor(value, True)
         End Set
     End Property
 
     Public Shared Property BackgroundColor() As ConsoleColor
         Get
-            Return mBackgroundColor
+            Return Console.BackgroundColor
         End Get
         Set(value As ConsoleColor)
-            If mBackgroundColor <> value Then
-                mBackgroundColor = value
-                SetColor(mBackgroundColor, False)
-            End If
+            If Console.BackgroundColor <> value Then SetColor(value, False)
         End Set
     End Property
 
@@ -181,7 +164,7 @@ Public NotInheritable Class ConsoleCrayon
     End Sub
 
     Public Shared Sub DrawLine(c As Char, fromCol As Integer, fromRow As Integer, toCol As Integer, toRow As Integer, foreColor As ConsoleColor, backColor As ConsoleColor)
-        Dim angle As Double = Atan2((toCol - fromCol), (toRow - fromRow))
+        Dim angle As Double = Atan2(toCol - fromCol, toRow - fromRow)
         Dim length As Integer = Math.Sqrt((toCol - fromCol) ^ 2 + (toRow - fromRow) ^ 2)
         Dim px As Integer
         Dim py As Integer
@@ -207,11 +190,7 @@ Public NotInheritable Class ConsoleCrayon
         Dim a As Double
 
         If dy = 0 Then
-            If dx > 0 Then
-                a = 0
-            Else
-                a = 180
-            End If
+            a = If(dx > 0, 0, 180)
         Else
             a = Math.Atan(dy / dx) * toDegrees
             Select Case a
@@ -308,8 +287,8 @@ Public NotInheritable Class ConsoleCrayon
         End Select
     End Function
 
-    Private Const ESC = Chr(27) + "["
-    Private Const ColorReset = ESC + "0m"
+    Private Const ESC As String = Chr(27) + "["
+    Private Const ColorReset As String = ESC + "0m"
     Private Shared Function GetAnsiColorControlCode(color As ConsoleColor, isForeground As Boolean) As String
         ' lighter fg colours are 90 -> 97 rather than 30 -> 37
         ' lighter bg colours are 100 -> 107 rather than 40 -> 47
diff --git a/x8086NetEmu/Helpers/Decoder.vb b/x8086NetEmu/Helpers/Decoder.vb
index 3d0ee76..b389c1d 100644
--- a/x8086NetEmu/Helpers/Decoder.vb
+++ b/x8086NetEmu/Helpers/Decoder.vb
@@ -75,7 +75,7 @@
         End Operator
 
         Public Shared Operator <>(i1 As Instruction, i2 As Instruction) As Boolean
-            Return Not (i1 = i2)
+            Return Not i1 = i2
         End Operator
     End Structure
 
@@ -100,13 +100,15 @@
     End Function
 
     Public Function Decode(segment As Integer, offset As Integer, Optional force As Boolean = False) As Instruction
-        'Threading.Monitor.Enter(Sched)
+        Dim r = mRegisters.Clone()
+        Dim f = mFlags.Clone()
         If (Not force) AndAlso (mIsExecuting OrElse isDecoding) Then
             Return InvalidOpCode()
         Else
             Return DoDecode(segment, offset)
         End If
-        'Threading.Monitor.Exit(Sched)
+        mRegisters = r
+        mFlags = f
     End Function
 
     Private Function DoDecode(segment As Integer, offset As Integer) As Instruction
@@ -148,11 +150,11 @@
                 End If
 
             Case &H4 ' add al and imm
-                opCodeASM = "ADD AL, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "ADD AL, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 4
 
             Case &H5 ' add ax and imm
-                opCodeASM = "ADD AX, " + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "ADD AX, " + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 4
 
             Case &H6 ' push es
@@ -183,11 +185,11 @@
                 End If
 
             Case &HC ' or al and imm
-                opCodeASM = "OR AL, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "OR AL, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 4
 
             Case &HD ' or ax and imm
-                opCodeASM = "OR AX, " + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "OR AX, " + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 4
 
             Case &HE ' push cs
@@ -214,11 +216,11 @@
                 End If
 
             Case &H14 ' adc al and imm
-                opCodeASM = "ADC AL, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "ADC AL, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 3
 
             Case &H15 ' adc ax and imm
-                opCodeASM = "ADC AX, " + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "ADC AX, " + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 3
 
             Case &H16 ' push ss
@@ -249,11 +251,11 @@
                 End If
 
             Case &H1C ' sbb al and imm
-                opCodeASM = "SBB AL, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "SBB AL, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 4
 
             Case &H1D ' sbb ax and imm
-                opCodeASM = "SBB AX, " + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "SBB AX, " + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 4
 
             Case &H1E ' push ds
@@ -285,11 +287,11 @@
                 End If
 
             Case &H24 ' and al and imm
-                opCodeASM = "AND AL, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "AND AL, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 4
 
             Case &H25 ' and ax and imm
-                opCodeASM = "AND AX, " + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "AND AX, " + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 4
 
             Case &H27 ' daa
@@ -316,11 +318,11 @@
                 End If
 
             Case &H2C ' sub al and imm
-                opCodeASM = "SUB AL, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "SUB AL, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 4
 
             Case &H2D ' sub ax and imm
-                opCodeASM = "SUB AX, " + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "SUB AX, " + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 4
 
             Case &H2F ' das
@@ -347,11 +349,11 @@
                 End If
 
             Case &H34 ' xor al and imm
-                opCodeASM = "XOR AL, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "XOR AL, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 4
 
             Case &H35 ' xor ax and imm
-                opCodeASM = "XOR AX, " + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "XOR AX, " + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 4
 
             Case &H37 ' aaa
@@ -377,11 +379,11 @@
                 End If
 
             Case &H3C ' cmp al and imm
-                opCodeASM = "CMP AL, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "CMP AL, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 4
 
             Case &H3D ' cmp ax and imm
-                opCodeASM = "CMP AX, " + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "CMP AX, " + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 4
 
             Case &H3F ' aas
@@ -390,7 +392,7 @@
 
             Case &H26, &H2E, &H36, &H3E ' segment override prefix
                 addrMode.Decode(decOpCode, decOpCode)
-                addrMode.Register1 = (addrMode.Register1 - GPRegisters.RegistersTypes.AH) + GPRegisters.RegistersTypes.ES
+                addrMode.Register1 = addrMode.Register1 - GPRegisters.RegistersTypes.AH + GPRegisters.RegistersTypes.ES
                 opCodeASM = addrMode.Register1.ToString() + ":"
                 segOvr = opCodeASM
                 clkCycDecoder += 2
@@ -528,7 +530,7 @@
                 SetDecoderAddressing()
                 If decOpCode = &H8C Then
                     If (addrMode.Register1 And &H4) = &H4 Then
-                        addrMode.Register1 = addrMode.Register1 And (Not (1 << 2))
+                        addrMode.Register1 = addrMode.Register1 And (Not 1 << 2)
                     Else
                         addrMode.Register1 += GPRegisters.RegistersTypes.ES
                         If addrMode.Register2 > &H3 Then
@@ -565,7 +567,7 @@
                 SetDecoderAddressing(DataSize.Word)
                 SetRegister2ToSegReg() 'ParamNOPS(SelPrmIndex.First, , DataSize.Byte))
                 If addrMode.IsDirect Then
-                    SetRegister1Alt(ParamNOPS(SelPrmIndex.First, , DataSize.Byte))
+                    SetRegister1Alt(ParamNOPS(ParamIndex.First, , DataSize.Byte))
                     opCodeASM = "MOV " + addrMode.Register2.ToString() + ", " + addrMode.Register1.ToString()
                     clkCycDecoder += 2
                 Else
@@ -601,7 +603,7 @@
                 clkCycDecoder += 5
 
             Case &H9A ' call direct intersegment
-                opCodeASM = "CALL " + Param(SelPrmIndex.Second, , DataSize.Word).ToString("X4") + ":" + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "CALL " + Param(ParamIndex.Second, , DataSize.Word).ToString("X4") + ":" + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 28
 
             Case &H9B ' wait
@@ -627,15 +629,15 @@
                 addrMode.Decode(decOpCode, decOpCode)
                 If addrMode.Direction = 0 Then
                     If addrMode.Size = DataSize.Byte Then
-                        opCodeASM = "MOV AL, [" + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4") + "]"
+                        opCodeASM = "MOV AL, [" + Param(ParamIndex.First, , DataSize.Word).ToString("X4") + "]"
                     Else
-                        opCodeASM = "MOV AX, [" + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4") + "]"
+                        opCodeASM = "MOV AX, [" + Param(ParamIndex.First, , DataSize.Word).ToString("X4") + "]"
                     End If
                 Else
                     If addrMode.Size = DataSize.Byte Then
-                        opCodeASM = "MOV [" + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4") + "], AL"
+                        opCodeASM = "MOV [" + Param(ParamIndex.First, , DataSize.Word).ToString("X4") + "], AL"
                     Else
-                        opCodeASM = "MOV [" + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4") + "], AX"
+                        opCodeASM = "MOV [" + Param(ParamIndex.First, , DataSize.Word).ToString("X4") + "], AX"
                     End If
                 End If
                 clkCycDecoder += 10
@@ -658,9 +660,9 @@
 
             Case &HA8 To &HA9 ' test
                 If (decOpCode And &H1) = 0 Then
-                    opCodeASM = "TEST AL, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                    opCodeASM = "TEST AL, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 Else
-                    opCodeASM = "TEST AX, " + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                    opCodeASM = "TEST AX, " + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 End If
                 clkCycDecoder += 4
 
@@ -689,7 +691,7 @@
                 clkCycDecoder += 15
 
             Case &HB0 To &HBF ' mov imm to reg
-                addrMode.Register1 = (decOpCode And &H7)
+                addrMode.Register1 = decOpCode And &H7
                 If (decOpCode And &H8) = &H8 Then
                     addrMode.Register1 += GPRegisters.RegistersTypes.AX
                     If (decOpCode And &H4) = &H4 Then addrMode.Register1 += GPRegisters.RegistersTypes.ES
@@ -697,13 +699,13 @@
                 Else
                     addrMode.Size = DataSize.Byte
                 End If
-                opCodeASM = "MOV " + addrMode.Register1.ToString() + ", " + Param(SelPrmIndex.First).ToHex(addrMode.Size)
+                opCodeASM = "MOV " + addrMode.Register1.ToString() + ", " + Param(ParamIndex.First).ToHex(addrMode.Size)
                 clkCycDecoder += 4
 
             Case &HC0, &HC1 : DecodeGroup2()
 
             Case &HC2 ' ret within segment adding imm to sp
-                opCodeASM = "RET " + Param(SelPrmIndex.First).ToHex()
+                opCodeASM = "RET " + Param(ParamIndex.First).ToHex()
                 clkCycDecoder += 20
 
             Case &HC3 ' ret within segment
@@ -724,7 +726,7 @@
                 If (addrMode.Register1 And shl2) = shl2 Then
                     addrMode.Register1 = (addrMode.Register1 + GPRegisters.RegistersTypes.ES) Or shl3
                 Else
-                    addrMode.Register1 = (addrMode.Register1 Or shl3)
+                    addrMode.Register1 = addrMode.Register1 Or shl3
                 End If
                 'If addrMode.IsDirect Then
                 '    If (addrMode.Register2 And shl2) = shl2 Then
@@ -742,10 +744,10 @@
             Case &HC6 To &HC7 ' mov imm to reg/mem
                 SetDecoderAddressing()
                 If addrMode.IsDirect Then
-                    mRegisters.Val(addrMode.Register1) = Param(SelPrmIndex.First, , DataSize.Byte)
+                    mRegisters.Val(addrMode.Register1) = Param(ParamIndex.First, , DataSize.Byte)
                     clkCycDecoder += 4
                 Else
-                    opCodeASM = "MOV " + indASM + ", " + Param(SelPrmIndex.First, opCodeSize).ToHex(addrMode.Size)
+                    opCodeASM = "MOV " + indASM + ", " + Param(ParamIndex.First, opCodeSize).ToHex(addrMode.Size)
                     clkCycDecoder += 10
                 End If
 
@@ -757,7 +759,7 @@
                 opCodeASM = "LEAVE"
 
             Case &HCA ' ret intersegment adding imm to sp
-                opCodeASM = "RETF " + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "RETF " + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 17
 
             Case &HCB ' ret intersegment (retf)
@@ -769,7 +771,7 @@
                 clkCycDecoder += 52
 
             Case &HCD ' int with type specified
-                opCodeASM = "INT " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "INT " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 51
 
             Case &HCE ' into
@@ -783,11 +785,11 @@
             Case &HD0 To &HD3 : DecodeGroup2()
 
             Case &HD4 ' aam
-                opCodeASM = "AAM " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "AAM " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 83
 
             Case &HD5 ' aad
-                opCodeASM = "AAD " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "AAD " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 60
 
             Case &HD6 ' xlat
@@ -799,7 +801,7 @@
                 clkCycDecoder += 11
 
             Case &HD9 ' fnstsw (required for BIOS to boot)?
-                If ParamNOPS(SelPrmIndex.First, , DataSize.Byte) = &H3C Then
+                If ParamNOPS(ParamIndex.First, , DataSize.Byte) = &H3C Then
                     opCodeASM = "FNSTSW {NOT IMPLEMENTED}"
                 Else
                     opCodeASM = decOpCode.ToString("X2") + " {NOT IMPLEMENTED}"
@@ -807,7 +809,7 @@
                 opCodeSize += 1
 
             Case &HDB ' fninit (required for BIOS to boot)?
-                If ParamNOPS(SelPrmIndex.First, , DataSize.Byte) = &HE3 Then
+                If ParamNOPS(ParamIndex.First, , DataSize.Byte) = &HE3 Then
                     opCodeASM = "FNINIT {NOT IMPLEMENTED}"
                 Else
                     opCodeASM = decOpCode.ToString("X2") + " {NOT IMPLEMENTED}"
@@ -835,19 +837,19 @@
                 clkCycDecoder += If(mRegisters.CX = 0, 18, 6)
 
             Case &HE4 ' in to al from fixed port
-                opCodeASM = "IN AL, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "IN AL, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 10
 
             Case &HE5 ' inw to ax from fixed port
-                opCodeASM = "IN AX, " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2")
+                opCodeASM = "IN AX, " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2")
                 clkCycDecoder += 10
 
             Case &HE6  ' out to al to fixed port
-                opCodeASM = "OUT " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2") + ", AL"
+                opCodeASM = "OUT " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2") + ", AL"
                 clkCycDecoder += 10
 
             Case &HE7  ' outw to ax to fixed port
-                opCodeASM = "OUT " + Param(SelPrmIndex.First, , DataSize.Byte).ToString("X2") + ", Ax"
+                opCodeASM = "OUT " + Param(ParamIndex.First, , DataSize.Byte).ToString("X2") + ", Ax"
                 clkCycDecoder += 10
 
             Case &HE8 ' call direct within segment
@@ -859,7 +861,7 @@
                 clkCycDecoder += 15
 
             Case &HEA ' jmp direct intersegment
-                opCodeASM = "JMP " + Param(SelPrmIndex.Second, , DataSize.Word).ToString("X4") + ":" + Param(SelPrmIndex.First, , DataSize.Word).ToString("X4")
+                opCodeASM = "JMP " + Param(ParamIndex.Second, , DataSize.Word).ToString("X4") + ":" + Param(ParamIndex.First, , DataSize.Word).ToString("X4")
                 clkCycDecoder += 15
 
             Case &HEB ' jmp direct within segment short
@@ -939,7 +941,7 @@
             Throw New Exception("Decoding error for decOpCode " + decOpCode.ToString("X2"))
         End If
 
-        Dim info As Instruction = New Instruction With {
+        Dim info As Instruction = New Instruction() With {
             .IsValid = True,
             .decOpCode = decOpCode,
             .CS = mRegisters.CS,
@@ -958,7 +960,7 @@
                 info.Bytes(0) = decOpCode
             End If
             For i As Integer = 1 To opCodeSize - 1
-                info.Bytes(i) = ParamNOPS(SelPrmIndex.First, i, DataSize.Byte)
+                info.Bytes(i) = ParamNOPS(ParamIndex.First, i, DataSize.Byte)
             Next
             If opCodeASM.Contains(" ") Then
                 Dim space As Integer = opCodeASM.IndexOf(" ")
@@ -1025,9 +1027,9 @@
                 clkCycDecoder += If(addrMode.IsDirect, 4, 10)
         End Select
         If addrMode.IsDirect Then
-            opCodeASM += " " + addrMode.Register2.ToString() + ", " + Param(SelPrmIndex.First, opCodeSize, paramSize).ToHex(paramSize)
+            opCodeASM += " " + addrMode.Register2.ToString() + ", " + Param(ParamIndex.First, opCodeSize, paramSize).ToHex(paramSize)
         Else
-            opCodeASM += " " + indASM + ", " + Param(SelPrmIndex.First, opCodeSize, paramSize).ToHex(paramSize)
+            opCodeASM += " " + indASM + ", " + Param(ParamIndex.First, opCodeSize, paramSize).ToHex(paramSize)
         End If
     End Sub
 
@@ -1068,10 +1070,10 @@
         Select Case addrMode.Reg
             Case 0 ' 000    --  test
                 If addrMode.IsDirect Then
-                    opCodeASM = "TEST " + addrMode.Register2.ToString() + ", " + Param(SelPrmIndex.First, opCodeSize).ToHex(addrMode.Size)
+                    opCodeASM = "TEST " + addrMode.Register2.ToString() + ", " + Param(ParamIndex.First, opCodeSize).ToHex(addrMode.Size)
                     clkCycDecoder += 5
                 Else
-                    opCodeASM = "TEST " + indASM + ", " + Param(SelPrmIndex.First, opCodeSize).ToHex(addrMode.Size)
+                    opCodeASM = "TEST " + indASM + ", " + Param(ParamIndex.First, opCodeSize).ToHex(addrMode.Size)
                     clkCycDecoder += 11
                 End If
             Case 2 ' 010    --  not
@@ -1195,7 +1197,7 @@
     End Sub
 
     Private Sub SetDecoderAddressing(Optional forceSize As DataSize = DataSize.UseAddressingMode)
-        addrMode.Decode(decOpCode, ParamNOPS(SelPrmIndex.First, , DataSize.Byte))
+        addrMode.Decode(decOpCode, ParamNOPS(ParamIndex.First, , DataSize.Byte))
 
         If forceSize <> DataSize.UseAddressingMode Then addrMode.Size = forceSize
 
@@ -1225,8 +1227,8 @@
                     Case 4 : addrMode.IndAdr = mRegisters.SI : indASM = "[SI]" : clkCyc += 5                                               ' 100 [SI]
                     Case 5 : addrMode.IndAdr = mRegisters.DI : indASM = "[DI]" : clkCyc += 5                                               ' 101 [DI]
                     Case 6                                                                                                                 ' 110 Direct Addressing
-                        addrMode.IndAdr = ParamNOPS(SelPrmIndex.First, 2, DataSize.Word)
-                        indASM = "[" + ParamNOPS(SelPrmIndex.First, 2, DataSize.Word).ToString("X4") + "]"
+                        addrMode.IndAdr = ParamNOPS(ParamIndex.First, 2, DataSize.Word)
+                        indASM = "[" + ParamNOPS(ParamIndex.First, 2, DataSize.Word).ToString("X4") + "]"
                         opCodeSize += 2
                         clkCyc += 9
                     Case 7 : addrMode.IndAdr = mRegisters.BX : indASM = "[BX]" : clkCyc += 5                                               ' 111 [BX]
@@ -1246,7 +1248,7 @@
                     Case 7 : addrMode.IndAdr = mRegisters.BX : indASM = "[BX]" : clkCyc += 5                                               ' 111 [BX]
                 End Select
 
-                Dim p As Byte = ParamNOPS(SelPrmIndex.First, 2, DataSize.Byte)
+                Dim p As Byte = ParamNOPS(ParamIndex.First, 2, DataSize.Byte)
                 Dim s As Integer
                 If p > &H80 Then
                     p = &H100 - p
@@ -1272,8 +1274,8 @@
                     Case 7 : addrMode.IndAdr = mRegisters.BX : indASM = "[BX]" : clkCyc += 5                                               ' 111 [BX]
                 End Select
 
-                indASM = indASM.Replace("]", " + " + ParamNOPS(SelPrmIndex.First, 2, DataSize.Word).ToString("X4") + "]")
-                addrMode.IndAdr += ParamNOPS(SelPrmIndex.First, 2, DataSize.Word)
+                indASM = indASM.Replace("]", " + " + ParamNOPS(ParamIndex.First, 2, DataSize.Word).ToString("X4") + "]")
+                addrMode.IndAdr += ParamNOPS(ParamIndex.First, 2, DataSize.Word)
                 addrMode.IndMem = RAMn
                 opCodeSize += 2
 
diff --git a/x8086NetEmu/Helpers/EmulatorState.vb b/x8086NetEmu/Helpers/EmulatorState.vb
index bb45c82..0740230 100644
--- a/x8086NetEmu/Helpers/EmulatorState.vb
+++ b/x8086NetEmu/Helpers/EmulatorState.vb
@@ -1,6 +1,4 @@
-ï»¿Imports System.IO
-
-Public Class EmulatorState
+ï»¿Public Class EmulatorState
     Private mCPU As X8086
 
     Public Sub New(cpu As X8086)
diff --git a/x8086NetEmu/Helpers/Exceptions.vb b/x8086NetEmu/Helpers/Exceptions.vb
index 12492bd..1a2f15e 100644
--- a/x8086NetEmu/Helpers/Exceptions.vb
+++ b/x8086NetEmu/Helpers/Exceptions.vb
@@ -17,11 +17,11 @@
 
     Private Sub OpCodeNotImplemented(Optional comment As String = "")
         Dim originalOpCodeSize As Integer = opCodeSize
-        ThrowException(String.Format("OpCode '{0}' at {1} Not Implemented{2}", Decode(Me, True).Mnemonic.Replace("h:", ""),
+        ThrowException(String.Format("OpCode '{0}' at {1} Not Implemented{2}", Decode(Me, True).Mnemonic?.Replace("h:", ""),
                                                                                mRegisters.PointerAddressToString().Replace("h", ""),
                                                                                If(comment = "", "", ": " + comment)))
         opCodeSize = originalOpCodeSize
-        If mVic20 Then HandleInterrupt(6, False) ' 80186
+        If mVic20 Then HandleInterrupt(6, False)
     End Sub
 
     Private Sub InterruptNotImplemented(intNum As Integer)
diff --git a/x8086NetEmu/Helpers/Helpers.vb b/x8086NetEmu/Helpers/Helpers.vb
index 200cff0..5eb37b6 100644
--- a/x8086NetEmu/Helpers/Helpers.vb
+++ b/x8086NetEmu/Helpers/Helpers.vb
@@ -15,7 +15,7 @@
     Private szpLUT8(256 - 1) As GPFlags.FlagsTypes
     Private szpLUT16(65536 - 1) As GPFlags.FlagsTypes
 
-    Public Enum SelPrmIndex
+    Public Enum ParamIndex
         First = 0
         Second = 1
         Thrid = 2
@@ -55,17 +55,18 @@
         Public IndAdr As UInt16    ' Indirect Address
         Public IndMem As UInt16    ' Indirect Memory Contents
 
-        Private regOffset As UInt32
+        Private regOffset As Byte
 
+        ' http://aturing.umcs.maine.edu/~meadow/courses/cos335/8086-instformat.pdf
         Public Sub Decode(data As Byte, addressingModeByte As Byte)
-            Size = data And 1US                                 ' (0000 0001)
-            Direction = (data And 2US) >> 1US                   ' (0000 0010)
+            Size = data And 1                                 ' (0000 0001)
+            Direction = (data >> 1) And 1                     ' (0000 0010)
 
-            Modifier = addressingModeByte >> 6US                ' (1100 0000)
-            Reg = (addressingModeByte >> 3US) And 7US           ' (0011 1000)
-            Rm = addressingModeByte And 7US                     ' (0000 0111)
+            Modifier = addressingModeByte >> 6                ' (1100 0000)
+            Reg = (addressingModeByte >> 3) And 7             ' (0011 1000)
+            Rm = addressingModeByte And 7                     ' (0000 0111)
 
-            regOffset = (Size << 3US)
+            regOffset = Size << 3
 
             Register1 = Reg Or regOffset
             If Register1 >= GPRegisters.RegistersTypes.ES Then Register1 += GPRegisters.RegistersTypes.ES
@@ -86,7 +87,7 @@
     End Sub
 
     Private Sub SetAddressing(Optional forceSize As DataSize = DataSize.UseAddressingMode)
-        addrMode.Decode(opCode, ParamNOPS(SelPrmIndex.First, , DataSize.Byte))
+        addrMode.Decode(opCode, ParamNOPS(ParamIndex.First, , DataSize.Byte))
 
         If forceSize <> DataSize.UseAddressingMode Then addrMode.Size = forceSize
 
@@ -108,45 +109,45 @@
             Case 0 ' 00
                 addrMode.IsDirect = False
                 Select Case addrMode.Rm
-                    Case 0 : addrMode.IndAdr = mRegisters.BX + mRegisters.SI : clkCyc += 7                          ' 000 [BX+SI]
-                    Case 1 : addrMode.IndAdr = mRegisters.BX + mRegisters.DI : clkCyc += 8                          ' 001 [BX+DI]
-                    Case 2 : addrMode.IndAdr = mRegisters.BP + mRegisters.SI : clkCyc += 8                          ' 010 [BP+SI]
-                    Case 3 : addrMode.IndAdr = mRegisters.BP + mRegisters.DI : clkCyc += 7                          ' 011 [BP+DI]
-                    Case 4 : addrMode.IndAdr = mRegisters.SI : clkCyc += 5                                          ' 100 [SI]
-                    Case 5 : addrMode.IndAdr = mRegisters.DI : clkCyc += 5                                          ' 101 [DI]
-                    Case 6 : addrMode.IndAdr = To32bitsWithSign(Param(SelPrmIndex.First, 2, DataSize.Word)) : clkCyc += 9             ' 110 Direct Addressing
-                    Case 7 : addrMode.IndAdr = mRegisters.BX : clkCyc += 5                                          ' 111 [BX]
+                    Case 0 : addrMode.IndAdr = mRegisters.BX + mRegisters.SI : clkCyc += 7UL                        ' 000 [BX+SI]
+                    Case 1 : addrMode.IndAdr = mRegisters.BX + mRegisters.DI : clkCyc += 8UL                        ' 001 [BX+DI]
+                    Case 2 : addrMode.IndAdr = mRegisters.BP + mRegisters.SI : clkCyc += 8UL                        ' 010 [BP+SI]
+                    Case 3 : addrMode.IndAdr = mRegisters.BP + mRegisters.DI : clkCyc += 7UL                        ' 011 [BP+DI]
+                    Case 4 : addrMode.IndAdr = mRegisters.SI : clkCyc += 5UL                                        ' 100 [SI]
+                    Case 5 : addrMode.IndAdr = mRegisters.DI : clkCyc += 5UL                                        ' 101 [DI]
+                    Case 6 : addrMode.IndAdr = To32bitsWithSign(Param(ParamIndex.First, 2, DataSize.Word)) : clkCyc += 9UL  ' 110 Direct Addressing
+                    Case 7 : addrMode.IndAdr = mRegisters.BX : clkCyc += 5UL                                        ' 111 [BX]
                 End Select
                 addrMode.IndMem = RAMn
 
             Case 1 ' 01 - 8bit
                 addrMode.IsDirect = False
                 Select Case addrMode.Rm
-                    Case 0 : addrMode.IndAdr = mRegisters.BX + mRegisters.SI : clkCyc += 7                          ' 000 [BX+SI]
-                    Case 1 : addrMode.IndAdr = mRegisters.BX + mRegisters.DI : clkCyc += 8                          ' 001 [BX+DI]
-                    Case 2 : addrMode.IndAdr = mRegisters.BP + mRegisters.SI : clkCyc += 8                          ' 010 [BP+SI]
-                    Case 3 : addrMode.IndAdr = mRegisters.BP + mRegisters.DI : clkCyc += 7                          ' 011 [BP+DI]
-                    Case 4 : addrMode.IndAdr = mRegisters.SI : clkCyc += 5                                          ' 100 [SI]
-                    Case 5 : addrMode.IndAdr = mRegisters.DI : clkCyc += 5                                          ' 101 [DI]
-                    Case 6 : addrMode.IndAdr = mRegisters.BP : clkCyc += 5                                          ' 110 [BP]
-                    Case 7 : addrMode.IndAdr = mRegisters.BX : clkCyc += 5                                          ' 111 [BX]
+                    Case 0 : addrMode.IndAdr = mRegisters.BX + mRegisters.SI : clkCyc += 7UL                        ' 000 [BX+SI]
+                    Case 1 : addrMode.IndAdr = mRegisters.BX + mRegisters.DI : clkCyc += 8UL                        ' 001 [BX+DI]
+                    Case 2 : addrMode.IndAdr = mRegisters.BP + mRegisters.SI : clkCyc += 8UL                        ' 010 [BP+SI]
+                    Case 3 : addrMode.IndAdr = mRegisters.BP + mRegisters.DI : clkCyc += 7UL                        ' 011 [BP+DI]
+                    Case 5 : addrMode.IndAdr = mRegisters.DI : clkCyc += 5UL                                        ' 101 [DI]
+                    Case 4 : addrMode.IndAdr = mRegisters.SI : clkCyc += 5UL                                        ' 100 [SI]
+                    Case 6 : addrMode.IndAdr = mRegisters.BP : clkCyc += 5UL                                        ' 110 [BP]
+                    Case 7 : addrMode.IndAdr = mRegisters.BX : clkCyc += 5UL                                        ' 111 [BX]
                 End Select
-                addrMode.IndAdr += To16bitsWithSign(Param(SelPrmIndex.First, 2, DataSize.Byte))
+                addrMode.IndAdr += To16bitsWithSign(Param(ParamIndex.First, 2, DataSize.Byte))
                 addrMode.IndMem = RAMn
 
             Case 2 ' 10 - 16bit
                 addrMode.IsDirect = False
                 Select Case addrMode.Rm
-                    Case 0 : addrMode.IndAdr = mRegisters.BX + mRegisters.SI : clkCyc += 7                          ' 000 [BX+SI]
-                    Case 1 : addrMode.IndAdr = mRegisters.BX + mRegisters.DI : clkCyc += 8                          ' 001 [BX+DI]
-                    Case 2 : addrMode.IndAdr = mRegisters.BP + mRegisters.SI : clkCyc += 8                          ' 010 [BP+SI]
-                    Case 3 : addrMode.IndAdr = mRegisters.BP + mRegisters.DI : clkCyc += 7                          ' 011 [BP+DI]
-                    Case 4 : addrMode.IndAdr = mRegisters.SI : clkCyc += 5                                          ' 100 [SI]
-                    Case 5 : addrMode.IndAdr = mRegisters.DI : clkCyc += 5                                          ' 101 [DI]
-                    Case 6 : addrMode.IndAdr = mRegisters.BP : clkCyc += 5                                          ' 110 [BP]
-                    Case 7 : addrMode.IndAdr = mRegisters.BX : clkCyc += 5                                          ' 111 [BX]
+                    Case 0 : addrMode.IndAdr = mRegisters.BX + mRegisters.SI : clkCyc += 7UL                        ' 000 [BX+SI]
+                    Case 1 : addrMode.IndAdr = mRegisters.BX + mRegisters.DI : clkCyc += 8UL                        ' 001 [BX+DI]
+                    Case 2 : addrMode.IndAdr = mRegisters.BP + mRegisters.SI : clkCyc += 8UL                        ' 010 [BP+SI]
+                    Case 3 : addrMode.IndAdr = mRegisters.BP + mRegisters.DI : clkCyc += 7UL                        ' 011 [BP+DI]
+                    Case 4 : addrMode.IndAdr = mRegisters.SI : clkCyc += 5UL                                        ' 100 [SI]
+                    Case 5 : addrMode.IndAdr = mRegisters.DI : clkCyc += 5UL                                        ' 101 [DI]
+                    Case 6 : addrMode.IndAdr = mRegisters.BP : clkCyc += 5UL                                        ' 110 [BP]
+                    Case 7 : addrMode.IndAdr = mRegisters.BX : clkCyc += 5UL                                        ' 111 [BX]
                 End Select
-                addrMode.IndAdr += To32bitsWithSign(Param(SelPrmIndex.First, 2, DataSize.Word))
+                addrMode.IndAdr += To32bitsWithSign(Param(ParamIndex.First, 2, DataSize.Word))
                 addrMode.IndMem = RAMn
 
             Case 3 ' 11
@@ -157,19 +158,19 @@
         opCodeSize += 1
     End Sub
 
-    Private Function To16bitsWithSign(v As UInt16) As UInt16
-        If (v And &H80US) <> 0 Then
-            Return &HFF00US Or v
+    Private Function To16bitsWithSign(v As UShort) As UInt16
+        If (v And &H80) <> 0 Then
+            Return &HFF00 Or v
         Else
-            Return v And &HFFUS
+            Return v
         End If
     End Function
 
-    Private Function To32bitsWithSign(v As UInt32) As UInt32
+    Private Function To32bitsWithSign(v As UInt16) As UInt32
         If (v And &H8000UI) <> 0 Then
             Return &HFFFF0000UI Or v
         Else
-            Return v And &HFFFFUI
+            Return v
         End If
     End Function
 
@@ -182,7 +183,7 @@
     End Function
 
     Private Sub SendToPort(portAddress As UInt32, value As UInt32)
-        FlushCycles()
+        'FlushCycles()
 
         If portsCache.ContainsKey(portAddress) Then
             portsCache(portAddress).Out(portAddress, value)
@@ -244,24 +245,24 @@
         Return &HFF
     End Function
 
-    Private ReadOnly Property Param(index As SelPrmIndex, Optional ipOffset As UInt16 = 1, Optional size As DataSize = DataSize.UseAddressingMode) As UInt16
+    Private ReadOnly Property Param(index As ParamIndex, Optional ipOffset As UInt16 = 1, Optional size As DataSize = DataSize.UseAddressingMode) As UInt16
         Get
             If size = DataSize.UseAddressingMode Then size = addrMode.Size
-            opCodeSize += (size + 1)
+            opCodeSize += size + 1
             Return ParamNOPS(index, ipOffset, size)
         End Get
     End Property
 
-    Private ReadOnly Property ParamNOPS(index As SelPrmIndex, Optional ipOffset As UInt16 = 1, Optional size As DataSize = DataSize.UseAddressingMode) As UInt16
+    Private ReadOnly Property ParamNOPS(index As ParamIndex, Optional ipOffset As UInt16 = 1, Optional size As DataSize = DataSize.UseAddressingMode) As UInt16
         Get
             ' Extra cycles for address misalignment
             ' This is too CPU expensive, with few benefits, if any... not worth it
             'If (mRegisters.IP Mod 2) <> 0 Then clkCyc += 4
 
             If size = DataSize.Byte OrElse (size = DataSize.UseAddressingMode AndAlso addrMode.Size = DataSize.Byte) Then
-                Return RAM8(mRegisters.CS, mRegisters.IP + ipOffset + index)
+                Return RAM8(mRegisters.CS, mRegisters.IP, ipOffset + index, True)
             Else
-                Return RAM16(mRegisters.CS, mRegisters.IP + ipOffset + index * 2)
+                Return RAM16(mRegisters.CS, mRegisters.IP, ipOffset + index * 2, True)
             End If
         End Get
     End Property
@@ -272,9 +273,9 @@
 
     Private Function OffsetIP(size As DataSize) As UInt16
         If size = DataSize.Byte Then
-            Return mRegisters.IP + To16bitsWithSign(Param(SelPrmIndex.First, , DataSize.Byte)) + opCodeSize
+            Return mRegisters.IP + To16bitsWithSign(Param(ParamIndex.First, , size)) + opCodeSize
         Else
-            Return mRegisters.IP + To32bitsWithSign(Param(SelPrmIndex.First, , DataSize.Word)) + opCodeSize
+            Return mRegisters.IP + To32bitsWithSign(Param(ParamIndex.First, , size)) + opCodeSize
         End If
     End Function
 
@@ -287,7 +288,7 @@
                 SetAddSubFlags(result, v1, v2, size, False)
 
             Case Operation.AddWithCarry
-                result = v1 + (v2 + mFlags.CF)
+                result = v1 + v2 + mFlags.CF
                 SetAddSubFlags(result, v1, v2, size, False)
 
             Case Operation.Substract, Operation.Compare
@@ -387,7 +388,7 @@
                 mMouse = adptr
             Case Adapter.AdapterType.Video
                 mVideoAdapter = adptr
-                isVideoAdapterAvailable = (adptr IsNot Nothing)
+                isVideoAdapterAvailable = adptr IsNot Nothing
             Case Adapter.AdapterType.Floppy
                 mFloppyController = adptr
         End Select
@@ -449,7 +450,7 @@
             X8086.Notify("{0}:{1}  {2}{3}", NotificationReasons.Info,
                                     mRegisters.SS.ToString("X4"),
                                     i.ToString("X4"),
-                                    RAM16(mRegisters.SS, i).ToString("X4"),
+                                    RAM16(mRegisters.SS, i,, True).ToString("X4"),
                                     If(i = mRegisters.SP, "<<", ""))
         Next
     End Sub
diff --git a/x8086NetEmu/Helpers/Hooks/INT13.vb b/x8086NetEmu/Helpers/Hooks/INT13.vb
index b3a3f32..14db648 100644
--- a/x8086NetEmu/Helpers/Hooks/INT13.vb
+++ b/x8086NetEmu/Helpers/Hooks/INT13.vb
@@ -62,7 +62,7 @@ Partial Public Class X8086
                     ret = &H4 ' sector not found
                     Exit Select
                 End If
-                CopyToRAM(buf, X8086.SegmentOffetToAbsolute(mRegisters.ES, mRegisters.BX))
+                CopyToMemory(buf, X8086.SegmentOffetToAbsolute(mRegisters.ES, mRegisters.BX))
                 AL = bufSize / dskImg.SectorSize
 
             Case &H3 ' Write sectors
@@ -98,7 +98,7 @@ Partial Public Class X8086
                                 mRegisters.BX)
 
                 Dim buf(bufSize - 1) As Byte
-                CopyFromRAM(buf, X8086.SegmentOffetToAbsolute(mRegisters.ES, mRegisters.BX))
+                CopyFromMemory(buf, X8086.SegmentOffetToAbsolute(mRegisters.ES, mRegisters.BX))
                 ret = dskImg.Write(offset, buf)
                 If ret = DiskImage.EIO Then
                     X8086.Notify("Write Sectors: Drive {0} CRC Error", NotificationReasons.Warn, mRegisters.DL)
@@ -209,7 +209,7 @@ Partial Public Class X8086
                     ret = &HAA
                 Else
                     mRegisters.CH = (dskImg.Cylinders - 1) And &HFF
-                    mRegisters.CL = (dskImg.Sectors And 63)
+                    mRegisters.CL = dskImg.Sectors And 63
                     mRegisters.CL += ((dskImg.Cylinders - 1) \ 256) * 64
                     mRegisters.DH = dskImg.Heads - 1
 
@@ -278,7 +278,7 @@ Partial Public Class X8086
                 buf(buf.Length - 3) = ecc(0)
                 buf(buf.Length - 2) = ecc(3)
                 buf(buf.Length - 1) = ecc(2)
-                CopyToRAM(buf, X8086.SegmentOffetToAbsolute(mRegisters.ES, mRegisters.BX))
+                CopyToMemory(buf, X8086.SegmentOffetToAbsolute(mRegisters.ES, mRegisters.BX))
                 AL = bufSize \ dskImg.SectorSize
 
             Case &HC ' Seek to Cylinder
@@ -305,15 +305,10 @@ Partial Public Class X8086
                 End If
 
                 If mRegisters.DL < &H80 Then
-                    If dskImg IsNot Nothing Then
-                        ret = &H64
-                    Else
-                        ret = &HFF
-                    End If
+                    ret = &H64
                 Else
-                    Dim n As Integer = dskImg.Sectors
-                    mRegisters.CX = n \ 256
-                    mRegisters.DX = n And &HFF
+                    mRegisters.CX = dskImg.Sectors \ 256
+                    mRegisters.DX = dskImg.Sectors And &HFF
                     ret = &H12C
                 End If
                 X8086.Notify("Drive {0} Read DASD Type", NotificationReasons.Info, mRegisters.DL)
@@ -378,7 +373,7 @@ Partial Public Class X8086
                     ret = &H4 ' sector not found
                     Exit Select
                 End If
-                CopyToRAM(buf, X8086.SegmentOffetToAbsolute(seg, off))
+                CopyToMemory(buf, X8086.SegmentOffetToAbsolute(seg, off))
                 AL = bufSize / dskImg.SectorSize
 
             Case &H43 ' Extended Sectors Write
@@ -411,7 +406,7 @@ Partial Public Class X8086
                                 off)
 
                 Dim buf(bufSize - 1) As Byte
-                CopyFromRAM(buf, X8086.SegmentOffetToAbsolute(seg, off))
+                CopyFromMemory(buf, X8086.SegmentOffetToAbsolute(seg, off))
                 ret = dskImg.Write(offset, buf)
                 If ret = DiskImage.EIO Then
                     X8086.Notify("Write Sectors: Drive {0} CRC Error", NotificationReasons.Warn, mRegisters.DL)
@@ -450,7 +445,7 @@ Partial Public Class X8086
         ' Store return status
         If mRegisters.AH <> 0 Then
             RAM8(&H40, &H41) = ret And &HFF
-            mRegisters.AX = ret << 8 Or AL
+            mRegisters.AX = (ret << 8) Or AL
         End If
         mFlags.CF = If(ret <> 0, 1, 0)
 
diff --git a/x8086NetEmu/Helpers/InterruptHandlers.vb b/x8086NetEmu/Helpers/InterruptHandlers.vb
index 7611916..35a6d41 100644
--- a/x8086NetEmu/Helpers/InterruptHandlers.vb
+++ b/x8086NetEmu/Helpers/InterruptHandlers.vb
@@ -20,8 +20,8 @@ Partial Public Class X8086
            repeLoopMode = REPLoopModes.None AndAlso
            picIsAvailable Then
 
-            Dim pendingIntNum As Integer = PIC.GetPendingInterrupt()
-            If pendingIntNum >= 0 Then
+            Dim pendingIntNum As Byte = PIC.GetPendingInterrupt()
+            If pendingIntNum <> &HFF Then
                 mIsHalted = False
                 HandleHardwareInterrupt(pendingIntNum)
             End If
@@ -29,21 +29,19 @@ Partial Public Class X8086
     End Sub
 
     Private Sub HandleInterrupt(intNum As Byte, isHard As Boolean)
-        'FlushCycles() ' Not calling FlushCycles provides a considerable performance boost
-
         If Not (intHooks.ContainsKey(intNum) AndAlso intHooks(intNum).Invoke()) Then
             PushIntoStack(mFlags.EFlags)
             PushIntoStack(mRegisters.CS)
 
             If isHard Then
-                PushIntoStack(mRegisters.IP)
+                PushIntoStack(AdjustIP(mRegisters.IP))
             Else
                 PushIntoStack(mRegisters.IP + opCodeSize)
             End If
 
             tmpVal = intNum * 4
-            IPAddrOffet = RAM16(0, tmpVal)
-            mRegisters.CS = RAM16(0, tmpVal + 2)
+            IPAddrOffet = RAM16(0, tmpVal,, True)
+            mRegisters.CS = RAM16(0, tmpVal, 2, True)
 
             If intNum = 0 Then DivisionByZero()
         End If
@@ -53,4 +51,18 @@ Partial Public Class X8086
 
         clkCyc += 51
     End Sub
+
+    Private Function IsPrefix(opCode As Byte) As Boolean
+        Select Case opCode
+            Case &H26, &H2E, &H36, &H3E, &HF2, &HF3 : Return True
+        End Select
+        Return False
+    End Function
+
+    Private Function AdjustIP(v As UShort) As UShort
+        While IsPrefix(RAM8(mRegisters.CS, v - 1))
+            v -= 1
+        End While
+        Return v
+    End Function
 End Class
\ No newline at end of file
diff --git a/x8086NetEmu/Helpers/Memory.vb b/x8086NetEmu/Helpers/Memory.vb
index c17400f..e239e47 100644
--- a/x8086NetEmu/Helpers/Memory.vb
+++ b/x8086NetEmu/Helpers/Memory.vb
@@ -2,8 +2,9 @@
     Public Const MemSize As UInt32 = &H100000UI  ' 1MB
     Public Const ROMStart As UInt32 = &HC0000UI
 
-    Public Memory(MemSize - 1) As Byte
+    Public ReadOnly Memory(MemSize - 1) As Byte
 
+    Private address As UInt32
     Private Const shl2 As UInt16 = 1 << 2
     Private Const shl3 As UInt16 = 1 << 3
 
@@ -58,16 +59,6 @@
             SI = SP + 2
             DI = SP + 3
             IP = SP + 4
-
-            'ES = (AL + BX + 1) Or shl3
-            'CS = ES + 1
-            'SS = ES + 2
-            'DS = ES + 3
-            'SP = (AH + BX + 1) Or shl3
-            'BP = (CH + BX + 1) Or shl3
-            'SI = (DH + BX + 1) Or shl3
-            'DI = (BH + BX + 1) Or shl3
-            'IP = DI + 1
         End Enum
 
         Private mActiveSegmentRegister As RegistersTypes = RegistersTypes.DS
@@ -148,7 +139,7 @@
 
         Public Property AX As UInt16
             Get
-                Return ((CShort(AH) << 8) Or AL)
+                Return (CShort(AH) << 8) Or AL
             End Get
             Set(value As UInt16)
                 AH = value >> 8
@@ -160,7 +151,7 @@
 
         Public Property BX As UInt16
             Get
-                Return ((CShort(BH) << 8) Or BL)
+                Return (CShort(BH) << 8) Or BL
             End Get
             Set(value As UInt16)
                 BH = value >> 8
@@ -172,7 +163,7 @@
 
         Public Property CX As UInt16
             Get
-                Return ((CShort(CH) << 8) Or CL)
+                Return (CShort(CH) << 8) Or CL
             End Get
             Set(value As UInt16)
                 CH = value >> 8
@@ -184,7 +175,7 @@
 
         Public Property DX As UInt16
             Get
-                Return ((CShort(DH) << 8) Or DL)
+                Return (CShort(DH) << 8) Or DL
             End Get
             Set(value As UInt16)
                 DH = value >> 8
@@ -324,28 +315,28 @@
     End Class
 
     Public Sub LoadBIN(fileName As String, segment As UInt16, offset As UInt16)
-        'Debug.WriteLine($"Loading: {fileName} @ {segment:X4}:{offset:X4}")
+        'Console.WriteLine($"Loading: {fileName} @ {segment:X4}:{offset:X4}")
         fileName = X8086.FixPath(fileName)
 
         If IO.File.Exists(fileName) Then
-            CopyToRAM(IO.File.ReadAllBytes(fileName), segment, offset)
+            CopyToMemory(IO.File.ReadAllBytes(fileName), segment, offset)
         Else
             ThrowException("File Not Found: " + vbCrLf + fileName)
         End If
     End Sub
 
-    Public Sub CopyToRAM(bytes() As Byte, segment As UInt16, offset As UInt16)
-        CopyToRAM(bytes, X8086.SegmentOffetToAbsolute(segment, offset))
+    Public Sub CopyToMemory(bytes() As Byte, segment As UInt16, offset As UInt16)
+        CopyToMemory(bytes, X8086.SegmentOffetToAbsolute(segment, offset))
     End Sub
 
-    Public Sub CopyToRAM(bytes() As Byte, address As UInt32)
+    Public Sub CopyToMemory(bytes() As Byte, address As UInt32)
         ' TODO: We need to implement some checks to prevent loading code into ROM areas.
         '       Something like this, for example:
-        '       If address + bytes.Length >= ROMStart Then Stop
+        '       If address + bytes.Length >= ROMStart Then ...
         Array.Copy(bytes, 0, Memory, address, bytes.Length)
     End Sub
 
-    Public Sub CopyFromRAM(bytes() As Byte, address As UInt32)
+    Public Sub CopyFromMemory(bytes() As Byte, address As UInt32)
         Array.Copy(Memory, address, bytes, 0, bytes.Length)
     End Sub
 
@@ -369,78 +360,79 @@
 
     Private Sub PushIntoStack(value As UInt16)
         mRegisters.SP -= 2
-        RAM16(mRegisters.SS, mRegisters.SP) = value
+        RAM16(mRegisters.SS, mRegisters.SP,, True) = value
     End Sub
 
     Private Function PopFromStack() As UInt16
         mRegisters.SP += 2
-        Return RAM16(mRegisters.SS, mRegisters.SP - 2)
+        Return RAM16(mRegisters.SS, mRegisters.SP - 2,, True)
     End Function
 
     Public Shared Function SegmentOffetToAbsolute(segment As UInt16, offset As UInt16) As UInt32
-        Return (CUInt(segment) << 4) + offset
+        Return (CUInt(segment) << 4UI) + offset
     End Function
 
     Public Shared Function AbsoluteToSegment(address As UInt32) As UInt16
-        Return (address >> 4) And &HFFF00
+        Return (address >> 4UI) And &HFFF00UI
     End Function
 
     Public Shared Function AbsoluteToOffset(address As UInt32) As UInt16
-        Return address And &HFFF
+        Return address And &HFFFUI
     End Function
 
-    Public Property RAM(address As UInt32) As Byte
+    Public Property RAM(address As UInt32, Optional ignoreHooks As Boolean = False) As Byte
         Get
             'If mDebugMode Then RaiseEvent MemoryAccess(Me, New MemoryAccessEventArgs(address, MemoryAccessEventArgs.AccessModes.Read))
             'Return FromPreftch(address)
 
-            For i As Integer = 0 To memHooks.Count - 1
-                If memHooks(i).Invoke(address, tmpVal, MemHookMode.Read) Then Return tmpVal
-            Next
+            If Not ignoreHooks Then
+                For i As Integer = 0 To memHooks.Count - 1
+                    If memHooks(i).Invoke(address, tmpVal, MemHookMode.Read) Then Return tmpVal
+                Next
+            End If
 
             Return Memory(address And &HFFFFFUI) ' "Call 5" Legacy Interface: http://www.os2museum.com/wp/?p=734
         End Get
         Set(value As Byte)
-            'If address >= ROMStart OrElse Memory(address) = value Then Exit Property
-            If address >= ROMStart Then Exit Property
-
-            For i As Integer = 0 To memHooks.Count - 1
-                If memHooks(i).Invoke(address, value, MemHookMode.Write) Then Exit Property
-            Next
+            If Not ignoreHooks Then
+                For i As Integer = 0 To memHooks.Count - 1
+                    If memHooks(i).Invoke(address, value, MemHookMode.Write) Then Exit Property
+                Next
+            End If
 
-            Memory(address) = value
+            If address < ROMStart Then Memory(address) = value
 
             'If mDebugMode Then RaiseEvent MemoryAccess(Me, New MemoryAccessEventArgs(address, MemoryAccessEventArgs.AccessModes.Write))
         End Set
     End Property
 
-    Public Property RAM8(segment As UInt16, offset As UInt16, Optional inc As Byte = 0) As Byte
+    Public Property RAM8(segment As UInt16, offset As UInt16, Optional inc As Byte = 0, Optional ignoreHooks As Boolean = False) As Byte
         Get
-            Return RAM(SegmentOffetToAbsolute(segment, offset + inc))
+            Return RAM(SegmentOffetToAbsolute(segment, offset + inc), ignoreHooks)
         End Get
         Set(value As Byte)
-            RAM(SegmentOffetToAbsolute(segment, offset + inc)) = value
+            RAM(SegmentOffetToAbsolute(segment, offset + inc), ignoreHooks) = value
         End Set
     End Property
 
-    Public Property RAM16(segment As UInt16, offset As UInt16, Optional inc As Byte = 0) As UInt16
+    Public Property RAM16(segment As UInt16, offset As UInt16, Optional inc As Byte = 0, Optional ignoreHooks As Boolean = False) As UInt16
         Get
-            Dim address As UInt32 = SegmentOffetToAbsolute(segment, offset + inc)
-            Return (CUInt(RAM(address + 1UI)) << 8UI Or RAM(address))
+            address = SegmentOffetToAbsolute(segment, offset + inc)
+            Return (CUInt(RAM(address + 1UI, ignoreHooks)) << 8UI) Or RAM(address, ignoreHooks)
         End Get
         Set(value As UInt16)
-            Dim address As UInt32 = SegmentOffetToAbsolute(segment, offset + inc)
-            RAM(address) = value
-            RAM(address + 1UI) = (value >> 8UI)
+            address = SegmentOffetToAbsolute(segment, offset + inc)
+            RAM(address, ignoreHooks) = value
+            RAM(address + 1UI, ignoreHooks) = value >> 8UI
         End Set
     End Property
 
-    Public Property RAMn() As UInt16
+    Public Property RAMn(Optional ignoreHooks As Boolean = False) As UInt16
         Get
             If addrMode.Size = DataSize.Byte Then
-                Return RAM8(mRegisters.ActiveSegmentValue, addrMode.IndAdr)
+                Return RAM8(mRegisters.ActiveSegmentValue, addrMode.IndAdr,, ignoreHooks)
             Else
-                Return RAM16(mRegisters.ActiveSegmentValue, addrMode.IndAdr)
+                Return RAM16(mRegisters.ActiveSegmentValue, addrMode.IndAdr,, ignoreHooks)
             End If
         End Get
         Set(value As UInt16)
diff --git a/x8086NetEmu/Helpers/Misc/IInterruptController.vb b/x8086NetEmu/Helpers/Misc/IInterruptController.vb
index 6064807..1342539 100644
--- a/x8086NetEmu/Helpers/Misc/IInterruptController.vb
+++ b/x8086NetEmu/Helpers/Misc/IInterruptController.vb
@@ -1,3 +1,3 @@
 ï»¿Public Interface IInterruptController
-    Function GetPendingInterrupt() As Integer
+    Function GetPendingInterrupt() As Byte
 End Interface
diff --git a/x8086NetEmu/Helpers/Misc/InterruptController.vb b/x8086NetEmu/Helpers/Misc/InterruptController.vb
index d89be9c..ba2d81d 100644
--- a/x8086NetEmu/Helpers/Misc/InterruptController.vb
+++ b/x8086NetEmu/Helpers/Misc/InterruptController.vb
@@ -1,4 +1,4 @@
 ï»¿Public MustInherit Class InterruptController
     Implements IInterruptController
-    Public MustOverride Function GetPendingInterrupt() As Integer Implements IInterruptController.GetPendingInterrupt
+    Public MustOverride Function GetPendingInterrupt() As Byte Implements IInterruptController.GetPendingInterrupt
 End Class
diff --git a/x8086NetEmu/Helpers/Misc/PriorityQueue.vb b/x8086NetEmu/Helpers/Misc/PriorityQueue.vb
index e1883d0..750888a 100644
--- a/x8086NetEmu/Helpers/Misc/PriorityQueue.vb
+++ b/x8086NetEmu/Helpers/Misc/PriorityQueue.vb
@@ -99,7 +99,7 @@
 
     Public ReadOnly Property IsEmpty As Boolean
         Get
-            Return (nHeap = 0)
+            Return nHeap = 0
         End Get
     End Property
 End Class
diff --git a/x8086NetEmu/Helpers/Misc/Scheduler.vb b/x8086NetEmu/Helpers/Misc/Scheduler.vb
index 1ffda40..20ee0ae 100644
--- a/x8086NetEmu/Helpers/Misc/Scheduler.vb
+++ b/x8086NetEmu/Helpers/Misc/Scheduler.vb
@@ -9,7 +9,7 @@ Public Class Scheduler
     Private Const STOPPING As Long = Long.MinValue
 
     ' Number of scheduler time units per simulated second (~1.0 GHz)
-    Public Const BASECLOCK = 1.19318 * X8086.GHz
+    Public Const BASECLOCK As ULong = 1.19318 * X8086.GHz
 
     ' Current simulation time in scheduler time units (ns)
     Private mCurrentTime As Long
@@ -131,8 +131,8 @@ Public Class Scheduler
         If enabled And simTimePerWallMs < 1000 Then Throw New ArgumentException("Invalid value for simTimePerWallMs")
 #End If
         syncScheduler = enabled
-        syncQuantum = quantum
-        syncSimTimePerWallMs = simTimePerWallMs
+        syncQuantum = quantum * simulationMultiplier
+        syncSimTimePerWallMs = simTimePerWallMs * simulationMultiplier
         syncTimeSaldo = 0
         syncWallTimeMillis = CurrentTimeMillis()
 
@@ -250,8 +250,6 @@ Public Class Scheduler
     End Sub
 
     Private Sub Wait(delay As Integer)
-        If delay > 1000 Then Exit Sub ' FIXME: Don't know why, sometimes, delay gets extremely large!
-
         Monitor.Enter(Me)
         Monitor.Wait(Me, delay)
         Monitor.Exit(Me)
@@ -390,9 +388,7 @@ Public Class Scheduler
                 For i As Integer = 0 To inputBuf.Count - 1
                     evt = CType(inputBuf.Item(i), ExternalInputEvent)
                     evt.TimeStamp = mCurrentTime
-                    ' Tasks.Task.Run(Sub() evt.Handler.HandleInput(evt)) ' <- This freezes Windows 10!!!!
-                    Tasks.Task.Run(Sub() evt.Handler.HandleInput(evt))
-                    'evt.Handler.HandleInput(evt)
+                    evt.Handler.HandleInput(evt)
                 Next
                 inputBuf.Clear()
                 cleanInputBuf = inputBuf
@@ -405,9 +401,10 @@ Public Class Scheduler
                     mCPU.PreExecute()
                 Catch ex As Exception
                     X8086.Notify("Shit happens at {0}:{1}: {2}", X8086.NotificationReasons.Fck,
-                                                                 mCPU.Registers.CS.ToString("X4"),
-                                                                 mCPU.Registers.IP.ToString("X4"),
-                                                                 ex.Message)
+                                                                mCPU.Registers.CS.ToString("X4"),
+                                                                mCPU.Registers.IP.ToString("X4"),
+                                                                ex.Message)
+                    mCPU.RaiseException($"Scheduler Main Loop Error: {ex.Message}")
                 End Try
 
                 If mCPU.IsHalted() Then SkipToNextEvent() ' The CPU is halted, skip immediately to the next event
@@ -431,7 +428,7 @@ Public Class Scheduler
             Else
                 isCtrlDown = False
             End If
-            If ((theEvent.Modifiers And Keys.Alt) = Keys.Alt) Then
+            If (theEvent.Modifiers And Keys.Alt) = Keys.Alt Then
                 isAltDown = Not CType(e.Extra, Boolean)
             Else
                 isAltDown = False
diff --git a/x8086NetEmu/Helpers/OpCodes.vb b/x8086NetEmu/Helpers/OpCodes.vb
index 999e5c2..c6251e0 100644
--- a/x8086NetEmu/Helpers/OpCodes.vb
+++ b/x8086NetEmu/Helpers/OpCodes.vb
@@ -5,16 +5,16 @@ Partial Public Class X8086
 AddressOf _00_03,
 AddressOf _00_03,
 AddressOf _00_03,
-AddressOf _04,  ' add al, imm
+AddressOf _04,      ' add al, imm
 AddressOf _05,  ' add ax, imm
 AddressOf _06,  ' push es
-AddressOf _07,  ' pop es
-AddressOf _08_0B,   ' or
+AddressOf _07,      ' pop es
+AddressOf _08_0B,       ' or
 AddressOf _08_0B,
 AddressOf _08_0B,
 AddressOf _08_0B,
 AddressOf _0C,  ' or al and imm
-AddressOf _0D,  ' or ax and imm
+AddressOf _0D,      ' or ax and imm
 AddressOf _0E,  ' push cs
 AddressOf _0F,  ' pop cs
 AddressOf _10_13,   ' adc
@@ -39,15 +39,15 @@ AddressOf _20_23,
 AddressOf _20_23,
 AddressOf _24,  ' and al and imm
 AddressOf _25,  ' and ax and imm
-AddressOf _3E,
+AddressOf _26_2E_36_3E,     ' ES, CS, SS and DS segment override prefix
 AddressOf _27,  ' daa
 AddressOf _28_2B,   ' sub reg/mem with reg to either
 AddressOf _28_2B,
 AddressOf _28_2B,
 AddressOf _28_2B,
-AddressOf _2C,  ' sub al and imm
+AddressOf _2C,      ' sub al and imm
 AddressOf _2D,  ' sub ax and imm
-AddressOf _3E,
+AddressOf _26_2E_36_3E, ' ES, CS, SS and DS segment override prefix
 AddressOf _2F,  ' das
 AddressOf _30_33,   ' xor reg/mem and reg to either
 AddressOf _30_33,
@@ -55,15 +55,15 @@ AddressOf _30_33,
 AddressOf _30_33,
 AddressOf _34,  ' xor al and imm
 AddressOf _35,  ' xor ax and imm
-AddressOf _3E,
+AddressOf _26_2E_36_3E, ' ES, CS, SS and DS segment override prefix
 AddressOf _37,  ' aaa
 AddressOf _38_3B,   ' cmp reg/mem and reg
 AddressOf _38_3B,
 AddressOf _38_3B,
 AddressOf _38_3B,
-AddressOf _3C,  ' cmp al and imm
+AddressOf _3C,      ' cmp al and imm
 AddressOf _3D,  ' cmp ax and imm
-AddressOf _3E,
+AddressOf _26_2E_36_3E, ' ES, CS, SS and DS segment override prefix
 AddressOf _3F,  ' aas
 AddressOf _40_47,   ' inc reg
 AddressOf _40_47,
@@ -98,7 +98,7 @@ AddressOf _58_5F,
 AddressOf _58_5F,
 AddressOf _58_5F,
 AddressOf _60,  ' pusha (80186)
-AddressOf _61,  ' popa (80186)
+AddressOf _61,      ' popa (80186)
 AddressOf _62,  ' bound (80186)
 AddressOf OpCodeNotImplemented,
 AddressOf OpCodeNotImplemented,
@@ -106,36 +106,36 @@ AddressOf OpCodeNotImplemented,
 AddressOf OpCodeNotImplemented,
 AddressOf OpCodeNotImplemented,
 AddressOf _68,  ' push (80186)
-AddressOf _69,      ' imul (80186)
+AddressOf _69,  ' imul (80186)
 AddressOf _6A,  ' push (80186)
 AddressOf _6B,  ' imul (80186)
-AddressOf _6C_6F,   ' Ignore 80186/V20 port operations... for now...
+AddressOf _6C_6F,       ' Ignore 80186/V20 port operations... for now...
 AddressOf _6C_6F,
 AddressOf _6C_6F,
 AddressOf _6C_6F,
 AddressOf _70,  ' jo
 AddressOf _71,  ' jno
-AddressOf _72,  ' jb/jnae
-AddressOf _73,  ' jnb/jae
-AddressOf _74,      ' je/jz
+AddressOf _72,  ' jb/jnae/jc (unsigned)
+AddressOf _73,  ' jnb/jae/jnc (unsigned)
+AddressOf _74,  ' je/jz
 AddressOf _75,  ' jne/jnz
-AddressOf _76,  ' jbe/jna
-AddressOf _77,  ' jnbe/ja
+AddressOf _76,      ' jbe/jna (unsigned)
+AddressOf _77,  ' ja/jnbe (unsigned)
 AddressOf _78,  ' js
-AddressOf _79,      ' jns
+AddressOf _79,  ' jns
 AddressOf _7A,  ' jp/jpe
 AddressOf _7B,  ' jnp/jpo
-AddressOf _7C,  ' jl/jnge
-AddressOf _7D,  ' jnl/jge
-AddressOf _7E,  ' jle/jng
-AddressOf _7F,      ' jnle/jg
-AddressOf _80_83,   ' 
+AddressOf _7C,      ' jl/jnge (signed)
+AddressOf _7D,  ' jnl/jge (signed)
+AddressOf _7E,  ' jle/jng (signed)
+AddressOf _7F,  ' jg/jnle (signed)
 AddressOf _80_83,
 AddressOf _80_83,
 AddressOf _80_83,
-AddressOf _84_85,       ' test reg with reg/mem
+AddressOf _80_83,
+AddressOf _84_85,   ' test reg with reg/mem
 AddressOf _84_85,
-AddressOf _86_87,   ' xchg reg/mem with reg
+AddressOf _86_87,       ' xchg reg/mem with reg
 AddressOf _86_87,
 AddressOf _88_8C,   ' mov ind <-> reg8/reg16
 AddressOf _88_8C,
@@ -144,7 +144,7 @@ AddressOf _88_8C,
 AddressOf _88_8C,
 AddressOf _8D,  ' lea
 AddressOf _8E,  ' mov reg/mem to seg reg
-AddressOf _8F,      ' pop reg/mem
+AddressOf _8F,  ' pop reg/mem
 AddressOf _90_97,   ' xchg reg with acc
 AddressOf _90_97,
 AddressOf _90_97,
@@ -157,10 +157,10 @@ AddressOf _98,  ' cbw
 AddressOf _99,  ' cwd
 AddressOf _9A,  ' call direct intersegment
 AddressOf _9B,  ' wait
-AddressOf _9C,  ' pushf
+AddressOf _9C,      ' pushf
 AddressOf _9D,  ' popf
 AddressOf _9E,  ' sahf
-AddressOf _9F,      ' lahf
+AddressOf _9F,  ' lahf
 AddressOf _A0_A3,   ' mov mem to acc | mov acc to mem
 AddressOf _A0_A3,
 AddressOf _A0_A3,
@@ -170,7 +170,7 @@ AddressOf _A4_A7,
 AddressOf _A4_A7,
 AddressOf _A4_A7,
 AddressOf _A8,  ' test al imm8
-AddressOf _A9,      ' test ax imm16
+AddressOf _A9,  ' test ax imm16
 AddressOf _AA_AF,
 AddressOf _AA_AF,
 AddressOf _AA_AF,
@@ -193,29 +193,29 @@ AddressOf _B0_BF,
 AddressOf _B0_BF,
 AddressOf _B0_BF,
 AddressOf _B0_BF,
-AddressOf _C1,
-AddressOf _C1,
+AddressOf _C0_C1,   ' GRP2 byte/word imm8/16 ??? (80186)
+AddressOf _C0_C1,       ' GRP2 byte/word imm8/16 ??? (80186)
 AddressOf _C2,  ' ret (ret n) within segment adding imm to sp
 AddressOf _C3,  ' ret within segment
-AddressOf _C4_C5,       ' les | lds
+AddressOf _C4_C5,   ' les | lds
 AddressOf _C4_C5,
-AddressOf _C6_C7,   ' mov imm to reg/mem
+AddressOf _C6_C7,       ' mov imm to reg/mem
 AddressOf _C6_C7,
 AddressOf _C8,  ' enter (80186)
-AddressOf _C9,      ' leave (80186)
+AddressOf _C9,  ' leave (80186)
 AddressOf _CA,  ' ret intersegment adding imm to sp (ret n /retf)
 AddressOf _CB,  ' ret intersegment (retf)
-AddressOf _CC,  ' int with type 3
+AddressOf _CC,      ' int with type 3
 AddressOf _CD,  ' int with type specified
 AddressOf _CE,  ' into
-AddressOf _CF,      ' iret
-AddressOf _D0_D3,   ' 
+AddressOf _CF,  ' iret
+AddressOf _D0_D3,
 AddressOf _D0_D3,
 AddressOf _D0_D3,
 AddressOf _D0_D3,
-AddressOf _D4,      ' aam
+AddressOf _D4,  ' aam
 AddressOf _D5,  ' aad
-AddressOf _D6,  ' xlat 
+AddressOf _D6,  ' xlat / salc
 AddressOf _D7,  ' xlatb
 AddressOf _D8_DF,   ' Ignore co-processor instructions
 AddressOf _D8_DF,
@@ -228,37 +228,37 @@ AddressOf _D8_DF,
 AddressOf _E0,  ' loopne/loopnz
 AddressOf _E1,  ' loope/loopz
 AddressOf _E2,  ' loop
-AddressOf _E3,  ' jcxz
-AddressOf _E4,      ' in to al from fixed port
+AddressOf _E3,  ' jcxz/jecxz
+AddressOf _E4,  ' in to al from fixed port
 AddressOf _E5,  ' inw to ax from fixed port
-AddressOf _E6,  ' out to al to fixed port
+AddressOf _E6,      ' out to al to fixed port
 AddressOf _E7,  ' outw to ax to fixed port
 AddressOf _E8,  ' call direct within segment
-AddressOf _E9,      ' jmp direct within segment
+AddressOf _E9,  ' jmp direct within segment
 AddressOf _EA,  ' jmp direct intersegment
 AddressOf _EB,  ' jmp direct within segment short
-AddressOf _EC,  ' in to al from variable port
+AddressOf _EC,      ' in to al from variable port
 AddressOf _ED,  ' inw to ax from variable port
 AddressOf _EE,  ' out to port dx from al
-AddressOf _EF,      ' out to port dx from ax
+AddressOf _EF,  ' out to port dx from ax
 AddressOf _F0,  ' lock
 AddressOf OpCodeNotImplemented,
 AddressOf _F2,  ' repne/repnz
 AddressOf _F3,  ' repe/repz
-AddressOf _F4,      ' hlt
+AddressOf _F4,  ' hlt
 AddressOf _F5,  ' cmc
-AddressOf _F6_F7,   ' 
+AddressOf _F6_F7,
 AddressOf _F6_F7,
 AddressOf _F8,  ' clc
-AddressOf _F9,      ' stc
+AddressOf _F9,  ' stc
 AddressOf _FA,  ' cli
 AddressOf _FB,  ' sti
-AddressOf _FC,  ' cld
+AddressOf _FC,      ' cld
 AddressOf _FD,  ' std
-AddressOf _FF,
-AddressOf _FF}
+AddressOf _FE_FF,
+AddressOf _FE_FF}
 
-    Private Sub _00_03()
+    Private Sub _00_03()    ' add reg<->reg / reg<->mem
         SetAddressing()
         If addrMode.IsDirect Then
             If addrMode.Direction = 0 Then
@@ -278,27 +278,28 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _04()
-        mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.Add, DataSize.Byte)
+    Private Sub _04()   ' add al, imm
+        mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.Add, DataSize.Byte)
         clkCyc += 4
     End Sub
 
-    Private Sub _05()
-        mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.Add, DataSize.Word)
+    Private Sub _05()   ' add ax, imm
+        mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.Add, DataSize.Word)
         clkCyc += 4
     End Sub
 
-    Private Sub _06()
+    Private Sub _06()   ' push es
         PushIntoStack(mRegisters.ES)
         clkCyc += 10
     End Sub
 
-    Private Sub _07()
+    Private Sub _07()   ' pop es
         mRegisters.ES = PopFromStack()
+        ignoreINTs = True
         clkCyc += 8
     End Sub
 
-    Private Sub _08_0B()
+    Private Sub _08_0B()    ' or
         SetAddressing()
         If addrMode.IsDirect Then
             If addrMode.Direction = 0 Then
@@ -318,29 +319,30 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _0C()
-        mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.LogicOr, DataSize.Byte)
+    Private Sub _0C()   ' or al and imm
+        mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.LogicOr, DataSize.Byte)
         clkCyc += 4
     End Sub
 
-    Private Sub _0D()
-        mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.LogicOr, DataSize.Word)
+    Private Sub _0D()   ' or ax and imm
+        mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.LogicOr, DataSize.Word)
         clkCyc += 4
     End Sub
 
-    Private Sub _0E()
+    Private Sub _0E()   ' push cs
         PushIntoStack(mRegisters.CS)
         clkCyc += 10
     End Sub
 
-    Private Sub _0F()
+    Private Sub _0F()   ' pop cs
         If Not mVic20 Then
             mRegisters.CS = PopFromStack()
+            ignoreINTs = True
             clkCyc += 8
         End If
     End Sub
 
-    Private Sub _10_13()
+    Private Sub _10_13()    ' adc
         SetAddressing()
         If addrMode.IsDirect Then
             If addrMode.Direction = 0 Then
@@ -360,30 +362,31 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _14()
-        mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.AddWithCarry, DataSize.Byte)
+    Private Sub _14()   ' adc al and imm
+        mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.AddWithCarry, DataSize.Byte)
         clkCyc += 3
     End Sub
 
-    Private Sub _15()
-        mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.AddWithCarry, DataSize.Word)
+    Private Sub _15()   ' adc ax and imm
+        mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.AddWithCarry, DataSize.Word)
         clkCyc += 3
     End Sub
 
-    Private Sub _16()
+    Private Sub _16()   ' push ss
         PushIntoStack(mRegisters.SS)
         clkCyc += 10
     End Sub
 
-    Private Sub _17()
+    Private Sub _17()   ' pop ss
         mRegisters.SS = PopFromStack()
         ' Lesson 4: http://ntsecurity.nu/onmymind/2007/2007-08-22.html
         ' http://zet.aluzina.org/forums/viewtopic.php?f=6&t=287
+        ' http://www.vcfed.org/forum/archive/index.php/t-41453.html
         ignoreINTs = True
         clkCyc += 8
     End Sub
 
-    Private Sub _18_1B()
+    Private Sub _18_1B()    ' sbb
         SetAddressing()
         If addrMode.IsDirect Then
             If addrMode.Direction = 0 Then
@@ -403,27 +406,28 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _1C()
-        mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.SubstractWithCarry, DataSize.Byte)
+    Private Sub _1C()   ' sbb al and imm
+        mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.SubstractWithCarry, DataSize.Byte)
         clkCyc += 4
     End Sub
 
-    Private Sub _1D()
-        mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.SubstractWithCarry, DataSize.Word)
+    Private Sub _1D()   ' sbb ax and imm
+        mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.SubstractWithCarry, DataSize.Word)
         clkCyc += 4
     End Sub
 
-    Private Sub _1E()
+    Private Sub _1E()   ' push ds
         PushIntoStack(mRegisters.DS)
         clkCyc += 10
     End Sub
 
-    Private Sub _1F()
+    Private Sub _1F()   ' pop ds
         mRegisters.DS = PopFromStack()
+        ignoreINTs = True
         clkCyc += 8
     End Sub
 
-    Private Sub _20_23()
+    Private Sub _20_23()    ' and reg/mem and reg to either
         SetAddressing()
         If addrMode.IsDirect Then
             If addrMode.Direction = 0 Then
@@ -443,25 +447,25 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _24()
-        mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.LogicAnd, DataSize.Byte)
+    Private Sub _24()   ' and al and imm
+        mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.LogicAnd, DataSize.Byte)
         clkCyc += 4
     End Sub
 
-    Private Sub _25()
-        mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.LogicAnd, DataSize.Word)
+    Private Sub _25()   ' and ax and imm
+        mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.LogicAnd, DataSize.Word)
         clkCyc += 4
     End Sub
 
-    Private Sub _3E()
+    Private Sub _26_2E_36_3E()  ' ES, CS, SS and DS segment override prefix
         addrMode.Decode(opCode, opCode)
-        mRegisters.ActiveSegmentRegister = (addrMode.Register1 - GPRegisters.RegistersTypes.AH) + GPRegisters.RegistersTypes.ES
-        isStringOp = True
+        mRegisters.ActiveSegmentRegister = addrMode.Register1 - GPRegisters.RegistersTypes.AH + GPRegisters.RegistersTypes.ES
+        newPrefix = True
         clkCyc += 2
     End Sub
 
-    Private Sub _27()
-        If (mRegisters.AL And &HF) > 9 OrElse mFlags.AF = 1 Then
+    Private Sub _27()   ' daa
+        If mRegisters.AL.LowNib() > 9 OrElse mFlags.AF = 1 Then
             tmpVal = CUInt(mRegisters.AL) + 6
             mRegisters.AL += 6
             mFlags.AF = 1
@@ -480,7 +484,7 @@ AddressOf _FF}
         clkCyc += 4
     End Sub
 
-    Private Sub _28_2B()
+    Private Sub _28_2B()    ' sub reg/mem with reg to either
         SetAddressing()
         If addrMode.IsDirect Then
             If addrMode.Direction = 0 Then
@@ -500,19 +504,19 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _2C()
-        mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.Substract, DataSize.Byte)
+    Private Sub _2C()   ' sub al and imm
+        mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.Substract, DataSize.Byte)
         clkCyc += 4
     End Sub
 
-    Private Sub _2D()
-        mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.Substract, DataSize.Word)
+    Private Sub _2D()   ' sub ax and imm
+        mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.Substract, DataSize.Word)
         clkCyc += 4
     End Sub
 
-    Private Sub _2F()
-        Dim al = mRegisters.AL
-        If (mRegisters.AL And &HF) > 9 OrElse mFlags.AF = 1 Then
+    Private Sub _2F()   ' das
+        Dim al As Byte = mRegisters.AL
+        If mRegisters.AL.LowNib() > 9 OrElse mFlags.AF = 1 Then
             tmpVal = CShort(mRegisters.AL) - 6
             mRegisters.AL -= 6
             mFlags.AF = 1
@@ -531,7 +535,7 @@ AddressOf _FF}
         clkCyc += 4
     End Sub
 
-    Private Sub _30_33()
+    Private Sub _30_33()    ' xor reg/mem and reg to either
         SetAddressing()
         If addrMode.IsDirect Then
             If addrMode.Direction = 0 Then
@@ -551,18 +555,18 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _34()
-        mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.LogicXor, DataSize.Byte)
+    Private Sub _34()   ' xor al and imm
+        mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.LogicXor, DataSize.Byte)
         clkCyc += 4
     End Sub
 
-    Private Sub _35()
-        mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.LogicXor, DataSize.Word)
+    Private Sub _35()   ' xor ax and imm
+        mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.LogicXor, DataSize.Word)
         clkCyc += 4
     End Sub
 
-    Private Sub _37()
-        If (mRegisters.AL And &HF) > 9 OrElse mFlags.AF = 1 Then
+    Private Sub _37()   ' aaa
+        If mRegisters.AL.LowNib() > 9 OrElse mFlags.AF = 1 Then
             mRegisters.AX += &H106
             mFlags.AF = 1
             mFlags.CF = 1
@@ -570,13 +574,13 @@ AddressOf _FF}
             mFlags.AF = 0
             mFlags.CF = 0
         End If
-        mRegisters.AL = mRegisters.AL And &HF
-        mFlags.OF = 0
-        mFlags.SF = 0
+        mRegisters.AL = mRegisters.AL.LowNib()
+        'mFlags.OF = 0
+        'mFlags.SF = 0
         clkCyc += 8
     End Sub
 
-    Private Sub _38_3B()
+    Private Sub _38_3B()    ' cmp reg/mem and reg
         SetAddressing()
         If addrMode.IsDirect Then
             If addrMode.Direction = 0 Then
@@ -595,18 +599,18 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _3C()
-        Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.Compare, DataSize.Byte)
+    Private Sub _3C()   ' cmp al and imm
+        Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.Compare, DataSize.Byte)
         clkCyc += 4
     End Sub
 
-    Private Sub _3D()
-        Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.Compare, DataSize.Word)
+    Private Sub _3D()   ' cmp ax and imm
+        Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.Compare, DataSize.Word)
         clkCyc += 4
     End Sub
 
-    Private Sub _3F()
-        If (mRegisters.AL And &HF) > 9 OrElse mFlags.AF = 1 Then
+    Private Sub _3F()   ' aas
+        If mRegisters.AL.LowNib() > 9 OrElse mFlags.AF = 1 Then
             mRegisters.AX -= &H106
             mFlags.AF = 1
             mFlags.CF = 1
@@ -614,25 +618,23 @@ AddressOf _FF}
             mFlags.AF = 0
             mFlags.CF = 0
         End If
-        mRegisters.AL = mRegisters.AL And &HF
-        mFlags.OF = 0
-        mFlags.SF = 0
+        mRegisters.AL = mRegisters.AL.LowNib()
         clkCyc += 8
     End Sub
 
-    Private Sub _40_47()
+    Private Sub _40_47()    ' inc reg
         SetRegister1Alt(opCode)
         mRegisters.Val(addrMode.Register1) = Eval(mRegisters.Val(addrMode.Register1), 1, Operation.Increment, DataSize.Word)
         clkCyc += 3
     End Sub
 
-    Private Sub _48_4F()
+    Private Sub _48_4F()    ' dec reg
         SetRegister1Alt(opCode)
         mRegisters.Val(addrMode.Register1) = Eval(mRegisters.Val(addrMode.Register1), 1, Operation.Decrement, DataSize.Word)
         clkCyc += 3
     End Sub
 
-    Private Sub _50_57()
+    Private Sub _50_57()    ' push reg
         If opCode = &H54 Then ' SP
             ' The 8086/8088 pushes the value of SP after it has been decremented
             ' http://css.csail.mit.edu/6.858/2013/readings/i386/s15_06.htm
@@ -644,13 +646,13 @@ AddressOf _FF}
         clkCyc += 11
     End Sub
 
-    Private Sub _58_5F()
+    Private Sub _58_5F()    ' pop reg
         SetRegister1Alt(opCode)
         mRegisters.Val(addrMode.Register1) = PopFromStack()
         clkCyc += 8
     End Sub
 
-    Private Sub _60()
+    Private Sub _60()   ' pusha (80186)
         If mVic20 Then
             tmpVal = mRegisters.SP
             PushIntoStack(mRegisters.AX)
@@ -665,7 +667,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _61()
+    Private Sub _61()   ' popa (80186)
         If mVic20 Then
             mRegisters.DI = PopFromStack()
             mRegisters.SI = PopFromStack()
@@ -679,7 +681,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _62()
+    Private Sub _62()   ' bound (80186)
         If mVic20 Then
             ' PRE ALPHA CODE - UNTESTED
             SetAddressing()
@@ -695,20 +697,20 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _68()
+    Private Sub _68()   ' push (80186)
         ' PRE ALPHA CODE - UNTESTED
         If mVic20 Then
-            PushIntoStack(Param(SelPrmIndex.First, , DataSize.Word))
+            PushIntoStack(Param(ParamIndex.First, , DataSize.Word))
             clkCyc += 3
         End If
     End Sub
 
-    Private Sub _69()
+    Private Sub _69()   ' imul (80186)
         If mVic20 Then
             ' PRE ALPHA CODE - UNTESTED
             SetAddressing()
             Dim tmp1 As UInt32 = mRegisters.Val(addrMode.Register1)
-            Dim tmp2 As UInt32 = Param(SelPrmIndex.First, , DataSize.Word)
+            Dim tmp2 As UInt32 = Param(ParamIndex.First, , DataSize.Word)
             If (tmp1 And &H8000) = &H8000 Then tmp1 = tmp1 Or &HFFFF0000UI
             If (tmp2 And &H8000) = &H8000 Then tmp2 = tmp2 Or &HFFFF0000UI
             Dim tmp3 As UInt32 = tmp1 * tmp2
@@ -724,20 +726,20 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _6A()
+    Private Sub _6A()   ' push (80186)
         If mVic20 Then
             ' PRE ALPHA CODE - UNTESTED
-            PushIntoStack(Param(SelPrmIndex.First, , DataSize.Byte))
+            PushIntoStack(Param(ParamIndex.First, , DataSize.Byte))
             clkCyc += 3
         End If
     End Sub
 
-    Private Sub _6B()
+    Private Sub _6B()   ' imul (80186)
         If mVic20 Then
             ' PRE ALPHA CODE - UNTESTED
             SetAddressing()
             Dim tmp1 As UInt32 = mRegisters.Val(addrMode.Register1)
-            Dim tmp2 As UInt32 = To16bitsWithSign(Param(SelPrmIndex.First, , DataSize.Byte))
+            Dim tmp2 As UInt32 = To16bitsWithSign(Param(ParamIndex.First, , DataSize.Byte))
             If (tmp1 And &H8000) = &H8000 Then tmp1 = tmp1 Or &HFFFF0000UI
             If (tmp2 And &H8000) = &H8000 Then tmp2 = tmp2 Or &HFFFF0000UI
             Dim tmp3 As UInt32 = tmp1 * tmp2
@@ -753,12 +755,12 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _6C_6F()
+    Private Sub _6C_6F()    ' Ignore 80186/V20 port operations... for now...
         opCodeSize += 1
         clkCyc += 3
     End Sub
 
-    Private Sub _70()
+    Private Sub _70()   ' jo
         If mFlags.OF = 1 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -768,7 +770,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _71()
+    Private Sub _71()   ' jno
         If mFlags.OF = 0 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -778,7 +780,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _72()
+    Private Sub _72()   ' jb/jnae/jc (unsigned)
         If mFlags.CF = 1 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -788,7 +790,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _73()
+    Private Sub _73()   ' jnb/jae/jnc (unsigned)
         If mFlags.CF = 0 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -798,7 +800,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _74()
+    Private Sub _74()   ' je/jz
         If mFlags.ZF = 1 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -808,7 +810,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _75()
+    Private Sub _75()   ' jne/jnz
         If mFlags.ZF = 0 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -818,7 +820,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _76()
+    Private Sub _76()   ' jbe/jna (unsigned)
         If mFlags.CF = 1 OrElse mFlags.ZF = 1 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -828,7 +830,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _77()
+    Private Sub _77()   ' ja/jnbe (unsigned)
         If mFlags.CF = 0 AndAlso mFlags.ZF = 0 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -838,7 +840,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _78()
+    Private Sub _78()   ' js
         If mFlags.SF = 1 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -848,7 +850,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _79()
+    Private Sub _79()   ' jns
         If mFlags.SF = 0 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -858,7 +860,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _7A()
+    Private Sub _7A()   ' jp/jpe
         If mFlags.PF = 1 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -868,7 +870,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _7B()
+    Private Sub _7B()   ' jnp/jpo
         If mFlags.PF = 0 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -878,7 +880,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _7C()
+    Private Sub _7C()   ' jl/jnge (signed)
         If mFlags.SF <> mFlags.OF Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -888,7 +890,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _7D()
+    Private Sub _7D()   ' jnl/jge (signed)
         If mFlags.SF = mFlags.OF Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -898,7 +900,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _7E()
+    Private Sub _7E()   ' jle/jng (signed)
         If mFlags.ZF = 1 OrElse (mFlags.SF <> mFlags.OF) Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -908,7 +910,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _7F()
+    Private Sub _7F()   ' jg/jnle (signed)
         If mFlags.ZF = 0 AndAlso (mFlags.SF = mFlags.OF) Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 16
@@ -922,7 +924,7 @@ AddressOf _FF}
         ExecuteGroup1()
     End Sub
 
-    Private Sub _84_85()
+    Private Sub _84_85()    ' test reg with reg/mem
         SetAddressing()
         If addrMode.IsDirect Then
             Eval(mRegisters.Val(addrMode.Register1), mRegisters.Val(addrMode.Register2), Operation.Test, addrMode.Size)
@@ -933,7 +935,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _86_87()
+    Private Sub _86_87()    ' xchg reg/mem with reg
         SetAddressing()
         If addrMode.IsDirect Then
             tmpVal = mRegisters.Val(addrMode.Register1)
@@ -947,7 +949,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _88_8C()
+    Private Sub _88_8C()    ' mov ind <-> reg8/reg16
         SetAddressing()
 
         If opCode = &H8C Then ' mov r/m16, sreg
@@ -982,27 +984,33 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _8D()
+    Private Sub _8D()   ' lea
         SetAddressing()
         mRegisters.Val(addrMode.Register1) = addrMode.IndAdr
         clkCyc += 2
     End Sub
 
-    Private Sub _8E()
+    Private Sub _8E()   ' mov reg/mem to seg reg
         SetAddressing(DataSize.Word)
         SetRegister2ToSegReg()
         If addrMode.IsDirect Then
-            SetRegister1Alt(ParamNOPS(SelPrmIndex.First, , DataSize.Byte))
+            SetRegister1Alt(ParamNOPS(ParamIndex.First, , DataSize.Byte))
             mRegisters.Val(addrMode.Register2) = mRegisters.Val(addrMode.Register1)
             clkCyc += 2
         Else
             mRegisters.Val(addrMode.Register2) = addrMode.IndMem
             clkCyc += 8
         End If
-        ignoreINTs = ignoreINTs Or (addrMode.Register2 = GPRegisters.RegistersTypes.CS)
+        ignoreINTs = ignoreINTs Or
+                (addrMode.Register2 = GPRegisters.RegistersTypes.CS) Or
+                (addrMode.Register2 = GPRegisters.RegistersTypes.SS) Or
+                (addrMode.Register2 = GPRegisters.RegistersTypes.DS) Or
+                (addrMode.Register2 = GPRegisters.RegistersTypes.ES)
+
+        If addrMode.Register2 = GPRegisters.RegistersTypes.CS Then FlushCycles()
     End Sub
 
-    Private Sub _8F()
+    Private Sub _8F()   ' pop reg/mem
         SetAddressing()
         addrMode.Decode(opCode, opCode)
         If addrMode.IsDirect Then
@@ -1013,11 +1021,11 @@ AddressOf _FF}
         clkCyc += 17
     End Sub
 
-    Private Sub _90()
+    Private Sub _90()   ' nop
         clkCyc += 3
     End Sub
 
-    Private Sub _90_97()
+    Private Sub _90_97()    ' xchg reg with acc
         SetRegister1Alt(opCode)
         tmpVal = mRegisters.AX
         mRegisters.AX = mRegisters.Val(addrMode.Register1)
@@ -1025,24 +1033,19 @@ AddressOf _FF}
         clkCyc += 3
     End Sub
 
-    Private Sub _98()
-        If (mRegisters.AL And &H80) = &H80 Then
-            mRegisters.AH = &HFF
-        Else
-            mRegisters.AH = &H0
-        End If
-        'mRegisters.AX = To16bitsWithSign(mRegisters.AL)
+    Private Sub _98()   ' cbw
+        mRegisters.AX = To16bitsWithSign(mRegisters.AL)
         clkCyc += 2
     End Sub
 
-    Private Sub _99()
+    Private Sub _99()   ' cwd
         mRegisters.DX = If((mRegisters.AH And &H80) = 0, &H0, &HFFFF)
         clkCyc += 5
     End Sub
 
-    Private Sub _9A()
-        IPAddrOffet = Param(SelPrmIndex.First, , DataSize.Word)
-        tmpVal = Param(SelPrmIndex.Second, , DataSize.Word)
+    Private Sub _9A()   ' call direct intersegment
+        IPAddrOffet = Param(ParamIndex.First, , DataSize.Word)
+        tmpVal = Param(ParamIndex.Second, , DataSize.Word)
 
         PushIntoStack(mRegisters.CS)
         PushIntoStack(mRegisters.IP + opCodeSize)
@@ -1052,33 +1055,34 @@ AddressOf _FF}
         clkCyc += 28
     End Sub
 
-    Private Sub _9B()
+    Private Sub _9B()   ' wait
         clkCyc += 4
     End Sub
 
-    Private Sub _9C()
+    Private Sub _9C()   ' pushf
         PushIntoStack(If(mModel = Models.IBMPC_5150, &HFFF, &HFFFF) And mFlags.EFlags)
         clkCyc += 10
     End Sub
 
-    Private Sub _9D()
+    Private Sub _9D()   ' popf
         mFlags.EFlags = PopFromStack()
         clkCyc += 8
     End Sub
 
-    Private Sub _9E()
+    Private Sub _9E()   ' sahf
         mFlags.EFlags = (mFlags.EFlags And &HFF00) Or mRegisters.AH
         clkCyc += 4
     End Sub
 
-    Private Sub _9F()
-        mRegisters.AH = mFlags.EFlags And &HFF
+    Private Sub _9F()   ' lahf
+        mRegisters.AH = mFlags.EFlags
         clkCyc += 4
     End Sub
 
-    Private Sub _A0_A3()
-        addrMode.Decode(opCode, opCode)
-        addrMode.IndAdr = Param(SelPrmIndex.First, , DataSize.Word)
+    Private Sub _A0_A3()    ' mov mem to acc | mov acc to mem
+        addrMode.Size = opCode And 1
+        addrMode.Direction = (opCode >> 1) And 1
+        addrMode.IndAdr = Param(ParamIndex.First, , DataSize.Word)
         addrMode.Register1 = If(addrMode.Size = DataSize.Byte, GPRegisters.RegistersTypes.AL, GPRegisters.RegistersTypes.AX)
         If addrMode.Direction = 0 Then
             mRegisters.Val(addrMode.Register1) = RAMn
@@ -1090,26 +1094,26 @@ AddressOf _FF}
 
     Private Sub _A4_A7()
         HandleREPMode()
-        isStringOp = True
+        newPrefix = True
     End Sub
 
     Private Sub _AA_AF()
         HandleREPMode()
-        isStringOp = True
+        newPrefix = True
     End Sub
 
-    Private Sub _A8()
-        Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.Test, DataSize.Byte)
+    Private Sub _A8()   ' test al imm8
+        Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.Test, DataSize.Byte)
         clkCyc += 4
     End Sub
 
-    Private Sub _A9()
-        Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.Test, DataSize.Word)
+    Private Sub _A9()   ' test ax imm16
+        Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.Test, DataSize.Word)
         clkCyc += 4
     End Sub
 
-    Private Sub _B0_BF()
-        addrMode.Register1 = (opCode And &H7)
+    Private Sub _B0_BF()    ' mov imm to reg
+        addrMode.Register1 = opCode And &H7
         If (opCode And &H8) = &H8 Then
             addrMode.Register1 += GPRegisters.RegistersTypes.AX
             If (opCode And &H4) = &H4 Then addrMode.Register1 += GPRegisters.RegistersTypes.ES
@@ -1117,56 +1121,53 @@ AddressOf _FF}
         Else
             addrMode.Size = DataSize.Byte
         End If
-        mRegisters.Val(addrMode.Register1) = Param(SelPrmIndex.First)
+        mRegisters.Val(addrMode.Register1) = Param(ParamIndex.First,, addrMode.Size)
         clkCyc += 4
     End Sub
 
-    Private Sub _C1()
+    Private Sub _C0_C1()    ' GRP2 byte/word imm8/16 ??? (80186)
         If mVic20 Then
             ' PRE ALPHA CODE - UNTESTED
             ExecuteGroup2()
         End If
     End Sub
 
-    Private Sub _C2()
+    Private Sub _C2()   ' ret (ret n) within segment adding imm to sp
         IPAddrOffet = PopFromStack()
-        mRegisters.SP += Param(SelPrmIndex.First, , DataSize.Word)
+        mRegisters.SP += Param(ParamIndex.First, , DataSize.Word)
         clkCyc += 20
     End Sub
 
-    Private Sub _C3()
+    Private Sub _C3()   ' ret within segment
         IPAddrOffet = PopFromStack()
         clkCyc += 16
     End Sub
 
-    Private Sub _C4_C5()
+    Private Sub _C4_C5()    ' les | lds
         SetAddressing(DataSize.Word)
-        If (addrMode.Register1 And shl2) = shl2 Then
-            addrMode.Register1 = (addrMode.Register1 + GPRegisters.RegistersTypes.ES) Or shl3
-        Else
-            addrMode.Register1 = (addrMode.Register1 Or shl3)
-        End If
-        mRegisters.Val(addrMode.Register1) = addrMode.IndMem
+        If (addrMode.Register1 And shl2) = shl2 Then addrMode.Register1 += GPRegisters.RegistersTypes.ES
+        mRegisters.Val(addrMode.Register1 Or shl3) = addrMode.IndMem
         mRegisters.Val(If(opCode = &HC4, GPRegisters.RegistersTypes.ES, GPRegisters.RegistersTypes.DS)) = RAM16(mRegisters.ActiveSegmentValue, addrMode.IndAdr, 2)
+        ignoreINTs = True
         clkCyc += 16
     End Sub
 
-    Private Sub _C6_C7()
+    Private Sub _C6_C7()    ' mov imm to reg/mem
         SetAddressing()
         If addrMode.IsDirect Then
-            mRegisters.Val(addrMode.Register1) = Param(SelPrmIndex.First, opCodeSize)
+            mRegisters.Val(addrMode.Register1) = Param(ParamIndex.First, opCodeSize)
             clkCyc += 4
         Else
-            RAMn = Param(SelPrmIndex.First, opCodeSize)
+            RAMn = Param(ParamIndex.First, opCodeSize)
             clkCyc += 10
         End If
     End Sub
 
-    Private Sub _C8()
+    Private Sub _C8()   ' enter (80186)
         If mVic20 Then
             ' PRE ALPHA CODE - UNTESTED
-            Dim stackSize = Param(SelPrmIndex.First, , DataSize.Word)
-            Dim nestLevel = Param(SelPrmIndex.Second, , DataSize.Byte) And &H1F
+            Dim stackSize = Param(ParamIndex.First, , DataSize.Word)
+            Dim nestLevel = Param(ParamIndex.Second, , DataSize.Byte) And &H1F
             PushIntoStack(mRegisters.BP)
             Dim frameTemp = mRegisters.SP
             If nestLevel > 0 Then
@@ -1191,7 +1192,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _C9()
+    Private Sub _C9()   ' leave (80186)
         If mVic20 Then
             mRegisters.SP = mRegisters.BP
             mRegisters.BP = PopFromStack()
@@ -1199,31 +1200,31 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _CA()
-        tmpVal = Param(SelPrmIndex.First, , DataSize.Word)
+    Private Sub _CA()   ' ret intersegment adding imm to sp (ret n /retf)
+        tmpVal = Param(ParamIndex.First, , DataSize.Word)
         IPAddrOffet = PopFromStack()
         mRegisters.CS = PopFromStack()
         mRegisters.SP += tmpVal
         clkCyc += 17
     End Sub
 
-    Private Sub _CB()
+    Private Sub _CB()   ' ret intersegment (retf)
         IPAddrOffet = PopFromStack()
         mRegisters.CS = PopFromStack()
         clkCyc += 18
     End Sub
 
-    Private Sub _CC()
+    Private Sub _CC()   ' int with type 3
         HandleInterrupt(3, False)
         clkCyc += 52
     End Sub
 
-    Private Sub _CD()
-        HandleInterrupt(Param(SelPrmIndex.First, , DataSize.Byte), False)
+    Private Sub _CD()   ' int with type specified
+        HandleInterrupt(Param(ParamIndex.First, , DataSize.Byte), False)
         clkCyc += 51
     End Sub
 
-    Private Sub _CE()
+    Private Sub _CE()   ' into
         If mFlags.OF = 1 Then
             HandleInterrupt(4, False)
             clkCyc += 3
@@ -1232,7 +1233,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _CF()
+    Private Sub _CF()   ' iret
         IPAddrOffet = PopFromStack()
         mRegisters.CS = PopFromStack()
         mFlags.EFlags = PopFromStack()
@@ -1243,39 +1244,41 @@ AddressOf _FF}
         ExecuteGroup2()
     End Sub
 
-    Private Sub _D4()
-        Dim div As Byte = Param(SelPrmIndex.First, , DataSize.Byte)
-        If div = 0 Then
+    Private Sub _D4()   ' aam
+        tmpVal = Param(ParamIndex.First, , DataSize.Byte)
+        If tmpVal = 0 Then
             HandleInterrupt(0, True)
             Exit Sub
         End If
-        mRegisters.AH = mRegisters.AL \ div
-        mRegisters.AL = mRegisters.AL Mod div
+        mRegisters.AH = mRegisters.AL \ tmpVal
+        mRegisters.AL = mRegisters.AL Mod tmpVal
         SetSZPFlags(mRegisters.AX, DataSize.Word)
         clkCyc += 83
     End Sub
 
-    Private Sub _D5()
-        mRegisters.AL += mRegisters.AH * Param(SelPrmIndex.First, , DataSize.Byte)
+    Private Sub _D5()   ' aad
+        mRegisters.AL += mRegisters.AH * Param(ParamIndex.First, , DataSize.Byte)
         mRegisters.AH = 0
         SetSZPFlags(mRegisters.AX, DataSize.Word)
         mFlags.SF = 0
         clkCyc += 60
     End Sub
 
-    Private Sub _D6()
-        If Not mVic20 Then
+    Private Sub _D6()   ' xlat / salc
+        If mVic20 Then
+            mRegisters.AL = RAM8(mRegisters.ActiveSegmentValue, mRegisters.BX + mRegisters.AL)
+        Else
             mRegisters.AL = If(mFlags.CF = 1, &HFF, &H0)
             clkCyc += 4
         End If
     End Sub
 
-    Private Sub _D7()
+    Private Sub _D7()   ' xlatb
         mRegisters.AL = RAM8(mRegisters.ActiveSegmentValue, mRegisters.BX + mRegisters.AL)
         clkCyc += 11
     End Sub
 
-    Private Sub _D8_DF()
+    Private Sub _D8_DF()    ' Ignore co-processor instructions
         SetAddressing()
 
         'FPU.Execute(opCode, addrMode)
@@ -1289,7 +1292,7 @@ AddressOf _FF}
         clkCyc += 2
     End Sub
 
-    Private Sub _E0()
+    Private Sub _E0()   ' loopne/loopnz
         mRegisters.CX -= 1
         If mRegisters.CX > 0 AndAlso mFlags.ZF = 0 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
@@ -1300,7 +1303,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _E1()
+    Private Sub _E1()   ' loope/loopz
         mRegisters.CX -= 1
         If mRegisters.CX > 0 AndAlso mFlags.ZF = 1 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
@@ -1311,7 +1314,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _E2()
+    Private Sub _E2()   ' loop
         mRegisters.CX -= 1
         If mRegisters.CX > 0 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
@@ -1322,7 +1325,7 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _E3()
+    Private Sub _E3()   ' jcxz/jecxz
         If mRegisters.CX = 0 Then
             IPAddrOffet = OffsetIP(DataSize.Byte)
             clkCyc += 18
@@ -1332,94 +1335,94 @@ AddressOf _FF}
         End If
     End Sub
 
-    Private Sub _E4()
-        mRegisters.AL = ReceiveFromPort(Param(SelPrmIndex.First, , DataSize.Byte))
+    Private Sub _E4()   ' in to al from fixed port
+        mRegisters.AL = ReceiveFromPort(Param(ParamIndex.First, , DataSize.Byte))
         clkCyc += 10
     End Sub
 
-    Private Sub _E5()
-        mRegisters.AX = ReceiveFromPort(Param(SelPrmIndex.First, , DataSize.Byte))
+    Private Sub _E5()   ' inw to ax from fixed port
+        mRegisters.AX = ReceiveFromPort(Param(ParamIndex.First, , DataSize.Byte))
         clkCyc += 10
     End Sub
 
-    Private Sub _E6()
+    Private Sub _E6()   ' out to al to fixed port
         FlushCycles()
-        SendToPort(Param(SelPrmIndex.First, , DataSize.Byte), mRegisters.AL)
+        SendToPort(Param(ParamIndex.First, , DataSize.Byte), mRegisters.AL)
         clkCyc += 10
     End Sub
 
-    Private Sub _E7()
+    Private Sub _E7()   ' outw to ax to fixed port
         FlushCycles()
-        SendToPort(Param(SelPrmIndex.First, , DataSize.Byte), mRegisters.AX)
+        SendToPort(Param(ParamIndex.First, , DataSize.Byte), mRegisters.AX)
         clkCyc += 10
     End Sub
 
-    Private Sub _E8()
+    Private Sub _E8()   ' call direct within segment
         IPAddrOffet = OffsetIP(DataSize.Word)
         PushIntoStack(Registers.IP + opCodeSize)
         clkCyc += 19
     End Sub
 
-    Private Sub _E9()
+    Private Sub _E9()   ' jmp direct within segment
         IPAddrOffet = OffsetIP(DataSize.Word)
         clkCyc += 15
     End Sub
 
-    Private Sub _EA()
-        IPAddrOffet = Param(SelPrmIndex.First, , DataSize.Word)
-        mRegisters.CS = Param(SelPrmIndex.Second, , DataSize.Word)
+    Private Sub _EA()   ' jmp direct intersegment
+        IPAddrOffet = Param(ParamIndex.First, , DataSize.Word)
+        mRegisters.CS = Param(ParamIndex.Second, , DataSize.Word)
         clkCyc += 15
     End Sub
 
-    Private Sub _EB()
+    Private Sub _EB()   ' jmp direct within segment short
         IPAddrOffet = OffsetIP(DataSize.Byte)
         clkCyc += 15
     End Sub
 
-    Private Sub _EC()
+    Private Sub _EC()   ' in to al from variable port
         mRegisters.AL = ReceiveFromPort(mRegisters.DX)
         clkCyc += 8
     End Sub
 
-    Private Sub _ED()
+    Private Sub _ED()   ' inw to ax from variable port
         mRegisters.AX = ReceiveFromPort(mRegisters.DX)
         clkCyc += 8
     End Sub
 
-    Private Sub _EE()
+    Private Sub _EE()   ' out to port dx from al
         SendToPort(mRegisters.DX, mRegisters.AL)
         clkCyc += 8
     End Sub
 
-    Private Sub _EF()
+    Private Sub _EF()   ' out to port dx from ax
         SendToPort(mRegisters.DX, mRegisters.AX)
         clkCyc += 8
     End Sub
 
-    Private Sub _F0()
+    Private Sub _F0()   ' lock
         OpCodeNotImplemented("LOCK")
         clkCyc += 2
     End Sub
 
-    Private Sub _F2()
+    Private Sub _F2()   ' repne/repnz
         repeLoopMode = REPLoopModes.REPENE
-        isStringOp = True
+        newPrefix = True
         clkCyc += 2
     End Sub
 
-    Private Sub _F3()
+    Private Sub _F3()   ' repe/repz
         repeLoopMode = REPLoopModes.REPE
-        isStringOp = True
+        newPrefix = True
         clkCyc += 2
     End Sub
 
-    Private Sub _F4()
+    Private Sub _F4()   ' hlt
         clkCyc += 2
         If Not mIsHalted Then SystemHalted()
         IncIP(-1)
     End Sub
 
-    Private Sub _F5()
+    Private Sub _F5()   ' cmc
         mFlags.CF = If(mFlags.CF = 0, 1, 0)
         clkCyc += 2
     End Sub
@@ -1428,38 +1431,38 @@ AddressOf _FF}
         ExecuteGroup3()
     End Sub
 
-    Private Sub _F8()
+    Private Sub _F8()   ' clc
         mFlags.CF = 0
         clkCyc += 2
     End Sub
 
-    Private Sub _F9()
+    Private Sub _F9()   ' stc
         mFlags.CF = 1
         clkCyc += 2
     End Sub
 
-    Private Sub _FA()
+    Private Sub _FA()   ' cli
         mFlags.IF = 0
         clkCyc += 2
     End Sub
 
-    Private Sub _FB()
+    Private Sub _FB()   ' sti
         mFlags.IF = 1
         ignoreINTs = True ' http://zet.aluzina.org/forums/viewtopic.php?f=6&t=287
         clkCyc += 2
     End Sub
 
-    Private Sub _FC()
+    Private Sub _FC()   ' cld
         mFlags.DF = 0
         clkCyc += 2
     End Sub
 
-    Private Sub _FD()
+    Private Sub _FD()   ' std
         mFlags.DF = 1
         clkCyc += 2
     End Sub
 
-    Private Sub _FF()
+    Private Sub _FE_FF()
         ExecuteGroup4_And_5()
     End Sub
 
diff --git a/x8086NetEmu/My Project/AssemblyInfo.vb b/x8086NetEmu/My Project/AssemblyInfo.vb
index 0623623..e628044 100644
--- a/x8086NetEmu/My Project/AssemblyInfo.vb	
+++ b/x8086NetEmu/My Project/AssemblyInfo.vb	
@@ -31,5 +31,5 @@ Imports System.Runtime.InteropServices
 ' by using the '*' as shown below:
 ' <Assembly: AssemblyVersion("1.0.*")> 
 
-<Assembly: AssemblyVersion("2018.8.27.4505")>
-<Assembly: AssemblyFileVersion("2018.8.27.4498")>
+<Assembly: AssemblyVersion("2019.2.13.6529")>
+<Assembly: AssemblyFileVersion("2019.2.13.6522")>
diff --git a/x8086NetEmu/My Project/Settings.Designer.vb b/x8086NetEmu/My Project/Settings.Designer.vb
index dd71389..491b793 100644
--- a/x8086NetEmu/My Project/Settings.Designer.vb	
+++ b/x8086NetEmu/My Project/Settings.Designer.vb	
@@ -15,7 +15,7 @@ Option Explicit On
 Namespace My
     
     <Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
-     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.5.0.0"),  _
+     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.8.0.0"),  _
      Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
     Partial Friend NotInheritable Class MySettings
         Inherits Global.System.Configuration.ApplicationSettingsBase
diff --git a/x8086NetEmu/x8086.vb b/x8086NetEmu/x8086.vb
index ea5e690..9110480 100644
--- a/x8086NetEmu/x8086.vb
+++ b/x8086NetEmu/x8086.vb
@@ -38,7 +38,7 @@ Public Class X8086
     Private memHooks As New List(Of MemHandler)
 
     Private opCode As Byte
-    Private opCodeSize As Byte = 0
+    Private opCodeSize As Byte
 
     Private tmpVal As UInt32
 
@@ -49,7 +49,7 @@ Public Class X8086
     Private mipsWaiter As AutoResetEvent
     Private mMPIs As Double
     Private instrucionsCounter As UInt32
-    Private isStringOp As Boolean = False
+    Private newPrefix As Boolean = False
 
     Public Shared Property LogToConsole As Boolean
 
@@ -78,7 +78,7 @@ Public Class X8086
     Public Const KHz As ULong = 1000
     Public Const MHz As ULong = KHz * KHz
     Public Const GHz As ULong = MHz * KHz
-    Private Const BASECLOCK As ULong = 4.77273 * MHz ' http://dosmandrivel.blogspot.com/2009/03/ibm-pc-design-antics.html
+    Public Const BASECLOCK As ULong = 4.77273 * MHz ' http://dosmandrivel.blogspot.com/2009/03/ibm-pc-design-antics.html
     Private mCyclesPerSecond As ULong = BASECLOCK
     Private clkCyc As ULong = 0
 
@@ -98,7 +98,7 @@ Public Class X8086
     Public PIT As PIT8254
     Public PPI As PPI8255
     'Public PPI As PPI8255_ALT
-    'Public RTC As RTC
+    Public RTC As RTC
     Public FPU As x8087
 
     Private picIsAvailable As Boolean
@@ -106,7 +106,7 @@ Public Class X8086
     Public Event EmulationTerminated()
     Public Event EmulationHalted()
     Public Event InstructionDecoded()
-    Public Event [Error](sender As Object, e As EmulatorErrorEventArgs)
+    Public Shared Event [Error](sender As Object, e As EmulatorErrorEventArgs)
     Public Shared Event Output(message As String, reason As NotificationReasons, arg() As Object)
     Public Event MIPsUpdated()
 
@@ -117,6 +117,7 @@ Public Class X8086
                    Optional int13 As Boolean = True,
                    Optional restartEmulationCallback As RestartEmulation = Nothing,
                    Optional model As Models = Models.IBMPC_5160)
+
         mVic20 = v20
         mEmulateINT13 = int13
         reCallback = restartEmulationCallback
@@ -133,39 +134,12 @@ Public Class X8086
 
     Private Function GetCpuSpeed() As UInt32
         Using managementObject As New Management.ManagementObject("Win32_Processor.DeviceID='CPU0'")
-            Return managementObject("CurrentClockSpeed")
+            Return CUInt(managementObject("CurrentClockSpeed"))
         End Using
     End Function
 
     Private Sub AddInternalHooks()
         If mEmulateINT13 Then TryAttachHook(&H13, AddressOf HandleINT13) ' Disk I/O Emulation
-
-        ' This doesn't work :(
-        'TryAttachHook(&H1A, New IntHandler(Function()
-        '                                       Dim ToBCD = Function(v As UInt32) ((v \ 10) << 4) + (v Mod 10)
-
-        '                                       Select Case mRegisters.AH
-
-        '                                                           Case 2
-        '                                                               mRegisters.CH = ToBCD(Now.Hour)
-        '                                                               mRegisters.CL = ToBCD(Now.Minute)
-        '                                                               mRegisters.DH = ToBCD(Now.Second)
-        '                                                               mRegisters.DL = 0
-        '                                                               mFlags.CF = 0
-
-        '                                                           Case 4
-        '                                                               mRegisters.CH = ToBCD(Now.Year \ 100 + 1)
-        '                                                               mRegisters.CL = ToBCD(Now.Year)
-        '                                                               mRegisters.DH = ToBCD(Now.Month)
-        '                                                               mRegisters.DL = ToBCD(Now.Day)
-        '                                                               mFlags.CF = 0
-
-        '                                                           Case Else
-        '                                                               Return False
-        '                                                       End Select
-
-        '                                                       Return True
-        '                                                   End Function))
     End Sub
 
     Private Sub BuildSZPTables()
@@ -182,7 +156,7 @@ Public Class X8086
             If (c And 64) <> 0 Then d += 1
             If (c And 128) <> 0 Then d += 1
 
-            If ((d And 1) <> 0) Then
+            If (d And 1) <> 0 Then
                 szpLUT8(c) = 0
             Else
                 szpLUT8(c) = GPFlags.FlagsTypes.PF
@@ -202,7 +176,7 @@ Public Class X8086
             If (c And 64) <> 0 Then d += 1
             If (c And 128) <> 0 Then d += 1
 
-            If ((d And 1) <> 0) Then
+            If (d And 1) <> 0 Then
                 szpLUT16(c) = 0
             Else
                 szpLUT16(c) = GPFlags.FlagsTypes.PF
@@ -231,6 +205,12 @@ Public Class X8086
         Return True
     End Function
 
+    Public Function TryDetachHook(memHandler As MemHandler) As Boolean
+        If Not memHooks.Contains(memHandler) Then Return False
+        memHooks.Remove(memHandler)
+        Return True
+    End Function
+
     Public Shared ReadOnly Property IsRunningOnMono As Boolean
         Get
             Return Type.GetType("Mono.Runtime") IsNot Nothing
@@ -318,26 +298,26 @@ Public Class X8086
     End Sub
 
     Private Sub SetupSystem()
-        picIsAvailable = (PIC IsNot Nothing)
+        picIsAvailable = PIC IsNot Nothing
         If Not picIsAvailable Then Exit Sub
 
         ' http://docs.huihoo.com/help-pc/int-int_11.html
-        Dim equipmentByte As Byte = (Binary.From("0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1".Replace(" ", "")))
-        '                                        âFâEâDâCâBâAâ9â8â7â6â5â4â3â2â1â0â  AX
-        '                                         â â â â â â â â â â â â â â â âââââ IPL diskette installed
-        '                                         â â â â â â â â â â â â â â ââââââ math coprocessor
-        '                                         â â â â â â â â â â â â âââ¼ââââââ old PC system board RAM < 256K
-        '                                         â â â â â â â â â â â â â ââââââ pointing device installed (PS/2)
-        '                                         â â â â â â â â â â â â âââââââ not used on PS/2
-        '                                         â â â â â â â â â â âââ´âââââââ initial video mode
-        '                                         â â â â â â â â âââ´ââââââââââ # of diskette drives, less 1
-        '                                         â â â â â â â ââââââââââââââ 0 if DMA installed
-        '                                         â â â â âââ´ââ´ââââââââââââââ number of serial ports
-        '                                         â â â ââââââââââââââââââââ game adapter installed
-        '                                         â â âââââââââââââââââââââ unused, internal modem (PS/2)
-        '                                         âââ´âââââââââââââââââââââ number of printer ports
-
-        PPI.SetSwitchData(equipmentByte)
+        Dim equipmentByte As Byte = Binary.From("0 0 0 0 0 0 0 0 0 1 1 0 1 1 0 1".Replace(" ", ""))
+        '                                       âFâEâDâCâBâAâ9â8â7â6â5â4â3â2â1â0â  AX
+        '                                        â â â â â â â â â â â â â â â âââââ IPL diskette installed
+        '                                        â â â â â â â â â â â â â â ââââââ math coprocessor
+        '                                        â â â â â â â â â â â â âââ¼ââââââ old PC system board RAM < 256K (00=256k, 01=512k, 10=576k, 11=640k)
+        '                                        â â â â â â â â â â â â â ââââââ pointing device installed (PS/2)
+        '                                        â â â â â â â â â â â â âââââââ not used on PS/2
+        '                                        â â â â â â â â â â âââ´âââââââ initial video mode (00=EGA/VGA, 01=CGA 40x25, 10=CGA 80x25 color, 11=MDA 80x25)
+        '                                        â â â â â â â â âââ´ââââââââââ # of diskette drives, less 1
+        '                                        â â â â â â â ââââââââââââââ 0 if DMA installed
+        '                                        â â â â âââ´ââ´ââââââââââââââ number of serial ports
+        '                                        â â â ââââââââââââââââââââ game adapter installed
+        '                                        â â âââââââââââââââââââââ unused, internal modem (PS/2)
+        '                                        âââ´âââââââââââââââââââââ number of printer ports
+
+        PPI.SwitchData = equipmentByte
 
         'RTC.CmosWrite(RTC.CMOS_BIOS_BOOTFLAG1, 1 Or (2 Or &H213) >> 4 And &HF0)
         'RTC.CmosWrite(RTC.CMOS_BIOS_BOOTFLAG2, (2 Or &H213) >> 4 And &HFF)
@@ -410,7 +390,7 @@ Public Class X8086
 
     Private Sub LoadBIOS()
         ' BIOS
-        LoadBIN("roms\PCXTBIOS.ROM", &HFE00, &H0)
+        LoadBIN("roms\pcxtbios.rom", &HFE00, &H0)
         'LoadBIN("..\..\Other Emulators & Resources\xtbios2\EPROMS\2764\XTBIOS.ROM", &HFE00, &H0)
         'LoadBIN("..\..\Other Emulators & Resources\xtbios25\EPROMS\2764\PCXTBIOS.ROM", &HFE00, &H0)
         'LoadBIN("..\..\Other Emulators & Resources\xtbios30\eproms\2764\pcxtbios.ROM", &HFE00, &H0)
@@ -421,7 +401,7 @@ Public Class X8086
         'LoadBIN("..\..\Other Emulators & Resources\PCE - PC Emulator\bin\rom\ibm-pc-1982.rom", &HFE00, &H0)
 
         ' BASIC C1.10
-        LoadBIN("roms\BASICC11.BIN", &HF600, &H0)
+        LoadBIN("roms\basicc11.bin", &HF600, &H0)
         'LoadBIN("..\..\Other Emulators & Resources\xtbios30\eproms\2764\basicf6.rom", &HF600, &H0)
         'LoadBIN("..\..\Other Emulators & Resources\xtbios30\eproms\2764\basicf8.rom", &HF800, &H0)
         'LoadBIN("..\..\Other Emulators & Resources\xtbios30\eproms\2764\basicfa.rom", &HFA00, &H0)
@@ -468,7 +448,6 @@ Public Class X8086
         Else
             Close()
             Init()
-            'Run(mDebugMode, cs, ip)
         End If
     End Sub
 
@@ -514,7 +493,7 @@ Public Class X8086
         Do
             mipsWaiter.WaitOne(delay)
 
-            mMPIs = (instrucionsCounter / delay) / 1000
+            mMPIs = instrucionsCounter / delay / 1000
             instrucionsCounter = 0
 
             If cancelAllThreads Then Exit Do
@@ -542,8 +521,8 @@ Public Class X8086
     End Sub
 
     Private Sub FlushCycles()
-        Dim t As ULong = clkCyc * Scheduler.BASECLOCK + leftCycleFrags
-        Sched.AdvanceTime(t / mCyclesPerSecond)
+        Dim t As Long = clkCyc * Scheduler.BASECLOCK + leftCycleFrags
+        Sched.AdvanceTime(t \ mCyclesPerSecond)
         leftCycleFrags = t Mod mCyclesPerSecond
         clkCyc = 0
 
@@ -560,30 +539,35 @@ Public Class X8086
     End Property
 
     Private Sub SetSynchronization()
-        Const syncQuantum As Double = 0.05
+        Const syncQuantum As Double = 0.01
         FlushCycles()
+
         Sched.SetSynchronization(True,
                                 Scheduler.BASECLOCK * syncQuantum,
-                                Scheduler.BASECLOCK * mSimulationMultiplier / 1000,
+                                Scheduler.BASECLOCK / 1000,
                                 mSimulationMultiplier)
     End Sub
 
     Public Sub PreExecute()
         If mIsExecuting OrElse isDecoding OrElse mIsPaused Then Exit Sub
-
         mDoReSchedule = False
 
         Dim maxRunTime As ULong = Sched.GetTimeToNextEvent()
-        If maxRunTime > Scheduler.BASECLOCK OrElse maxRunTime <= 0 Then maxRunTime = Scheduler.BASECLOCK
+        If maxRunTime <= 0 Then Exit Sub
+        If maxRunTime > Scheduler.BASECLOCK Then maxRunTime = Scheduler.BASECLOCK
         Dim maxRunCycl As ULong = (maxRunTime * mCyclesPerSecond - leftCycleFrags + Scheduler.BASECLOCK - 1) / Scheduler.BASECLOCK
 
         If mDebugMode Then
-            While (clkCyc < maxRunCycl AndAlso Not mDoReSchedule AndAlso mDebugMode)
+            While clkCyc < maxRunCycl AndAlso Not mDoReSchedule AndAlso mDebugMode
                 debugWaiter.WaitOne()
 
                 If Not isDecoding Then
                     mIsExecuting = True
+#If DEBUG Then
+                    Execute_OLD()
+#Else
                     Execute()
+#End If
                     mIsExecuting = False
                 End If
 
@@ -591,8 +575,12 @@ Public Class X8086
             End While
         Else
             mIsExecuting = True
-            While (clkCyc < maxRunCycl AndAlso Not mDoReSchedule)
-                Execute()
+            While clkCyc < maxRunCycl AndAlso Not mDoReSchedule
+#If DEBUG Then
+                Execute_OLD()
+#Else
+                    Execute()
+#End If
             End While
             mIsExecuting = False
         End If
@@ -601,12 +589,10 @@ Public Class X8086
     End Sub
 
     Public Sub Execute()
-        isStringOp = False
+        newPrefix = False
         instrucionsCounter += 1
 
         If mFlags.TF = 1 Then
-            ' The addition of the "If ignoreINTs Then" not only fixes the dreaded "Interrupt Check" in CheckIt,
-            ' but it even allows it to pass it successfully!!!
             If ignoreINTs Then HandleInterrupt(1, False)
         ElseIf ignoreINTs Then
             ignoreINTs = False
@@ -629,7 +615,7 @@ Public Class X8086
 
         clkCyc += opCodeSize * 4
 
-        If Not isStringOp Then
+        If Not newPrefix Then
             If repeLoopMode <> REPLoopModes.None Then repeLoopMode = REPLoopModes.None
             If mRegisters.ActiveSegmentChanged AndAlso repeLoopMode = REPLoopModes.None Then
                 mRegisters.ResetActiveSegment()
@@ -639,7 +625,7 @@ Public Class X8086
     End Sub
 
     Public Sub Execute_OLD()
-        isStringOp = False
+        newPrefix = False
         instrucionsCounter += 1
 
         If mFlags.TF = 1 Then
@@ -678,11 +664,11 @@ Public Class X8086
                 End If
 
             Case &H4 ' add al, imm
-                mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.Add, DataSize.Byte)
+                mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.Add, DataSize.Byte)
                 clkCyc += 4
 
             Case &H5 ' add ax, imm
-                mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.Add, DataSize.Word)
+                mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.Add, DataSize.Word)
                 clkCyc += 4
 
             Case &H6 ' push es
@@ -691,6 +677,7 @@ Public Class X8086
 
             Case &H7 ' pop es
                 mRegisters.ES = PopFromStack()
+                ignoreINTs = True
                 clkCyc += 8
 
             Case &H8 To &HB ' or
@@ -713,11 +700,11 @@ Public Class X8086
                 End If
 
             Case &HC ' or al and imm
-                mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.LogicOr, DataSize.Byte)
+                mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.LogicOr, DataSize.Byte)
                 clkCyc += 4
 
             Case &HD ' or ax and imm
-                mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.LogicOr, DataSize.Word)
+                mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.LogicOr, DataSize.Word)
                 clkCyc += 4
 
             Case &HE ' push cs
@@ -727,6 +714,7 @@ Public Class X8086
             Case &HF ' pop cs
                 If Not mVic20 Then
                     mRegisters.CS = PopFromStack()
+                    ignoreINTs = True
                     clkCyc += 8
                 End If
 
@@ -750,11 +738,11 @@ Public Class X8086
                 End If
 
             Case &H14 ' adc al and imm
-                mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.AddWithCarry, DataSize.Byte)
+                mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.AddWithCarry, DataSize.Byte)
                 clkCyc += 3
 
             Case &H15 ' adc ax and imm
-                mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.AddWithCarry, DataSize.Word)
+                mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.AddWithCarry, DataSize.Word)
                 clkCyc += 3
 
             Case &H16 ' push ss
@@ -765,6 +753,7 @@ Public Class X8086
                 mRegisters.SS = PopFromStack()
                 ' Lesson 4: http://ntsecurity.nu/onmymind/2007/2007-08-22.html
                 ' http://zet.aluzina.org/forums/viewtopic.php?f=6&t=287
+                ' http://www.vcfed.org/forum/archive/index.php/t-41453.html
                 ignoreINTs = True
                 clkCyc += 8
 
@@ -788,11 +777,11 @@ Public Class X8086
                 End If
 
             Case &H1C ' sbb al and imm
-                mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.SubstractWithCarry, DataSize.Byte)
+                mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.SubstractWithCarry, DataSize.Byte)
                 clkCyc += 4
 
             Case &H1D ' sbb ax and imm
-                mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.SubstractWithCarry, DataSize.Word)
+                mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.SubstractWithCarry, DataSize.Word)
                 clkCyc += 4
 
             Case &H1E ' push ds
@@ -801,6 +790,7 @@ Public Class X8086
 
             Case &H1F ' pop ds
                 mRegisters.DS = PopFromStack()
+                ignoreINTs = True
                 clkCyc += 8
 
             Case &H20 To &H23 ' and reg/mem and reg to either
@@ -823,21 +813,21 @@ Public Class X8086
                 End If
 
             Case &H24 ' and al and imm
-                mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.LogicAnd, DataSize.Byte)
+                mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.LogicAnd, DataSize.Byte)
                 clkCyc += 4
 
             Case &H25 ' and ax and imm
-                mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.LogicAnd, DataSize.Word)
+                mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.LogicAnd, DataSize.Word)
                 clkCyc += 4
 
             Case &H26, &H2E, &H36, &H3E ' ES, CS, SS and DS segment override prefix
                 addrMode.Decode(opCode, opCode)
-                mRegisters.ActiveSegmentRegister = (addrMode.Register1 - GPRegisters.RegistersTypes.AH) + GPRegisters.RegistersTypes.ES
-                isStringOp = True
+                mRegisters.ActiveSegmentRegister = addrMode.Register1 - GPRegisters.RegistersTypes.AH + GPRegisters.RegistersTypes.ES
+                newPrefix = True
                 clkCyc += 2
 
             Case &H27 ' daa
-                If (mRegisters.AL And &HF) > 9 OrElse mFlags.AF = 1 Then
+                If mRegisters.AL.LowNib() > 9 OrElse mFlags.AF = 1 Then
                     tmpVal = CUInt(mRegisters.AL) + 6
                     mRegisters.AL += 6
                     mFlags.AF = 1
@@ -875,16 +865,16 @@ Public Class X8086
                 End If
 
             Case &H2C ' sub al and imm
-                mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.Substract, DataSize.Byte)
+                mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.Substract, DataSize.Byte)
                 clkCyc += 4
 
             Case &H2D ' sub ax and imm
-                mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.Substract, DataSize.Word)
+                mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.Substract, DataSize.Word)
                 clkCyc += 4
 
             Case &H2F ' das
-                Dim al = mRegisters.AL
-                If (mRegisters.AL And &HF) > 9 OrElse mFlags.AF = 1 Then
+                Dim al As Byte = mRegisters.AL
+                If mRegisters.AL.LowNib() > 9 OrElse mFlags.AF = 1 Then
                     tmpVal = CShort(mRegisters.AL) - 6
                     mRegisters.AL -= 6
                     mFlags.AF = 1
@@ -922,15 +912,15 @@ Public Class X8086
                 End If
 
             Case &H34 ' xor al and imm
-                mRegisters.AL = Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.LogicXor, DataSize.Byte)
+                mRegisters.AL = Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.LogicXor, DataSize.Byte)
                 clkCyc += 4
 
             Case &H35 ' xor ax and imm
-                mRegisters.AX = Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.LogicXor, DataSize.Word)
+                mRegisters.AX = Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.LogicXor, DataSize.Word)
                 clkCyc += 4
 
             Case &H37 ' aaa
-                If (mRegisters.AL And &HF) > 9 OrElse mFlags.AF = 1 Then
+                If mRegisters.AL.LowNib() > 9 OrElse mFlags.AF = 1 Then
                     mRegisters.AX += &H106
                     mFlags.AF = 1
                     mFlags.CF = 1
@@ -938,9 +928,9 @@ Public Class X8086
                     mFlags.AF = 0
                     mFlags.CF = 0
                 End If
-                mRegisters.AL = mRegisters.AL And &HF
-                mFlags.OF = 0
-                mFlags.SF = 0
+                mRegisters.AL = mRegisters.AL.LowNib()
+                'mFlags.OF = 0
+                'mFlags.SF = 0
                 clkCyc += 8
 
             Case &H38 To &H3B ' cmp reg/mem and reg
@@ -962,15 +952,15 @@ Public Class X8086
                 End If
 
             Case &H3C ' cmp al and imm
-                Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.Compare, DataSize.Byte)
+                Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.Compare, DataSize.Byte)
                 clkCyc += 4
 
             Case &H3D ' cmp ax and imm
-                Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.Compare, DataSize.Word)
+                Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.Compare, DataSize.Word)
                 clkCyc += 4
 
             Case &H3F ' aas
-                If (mRegisters.AL And &HF) > 9 OrElse mFlags.AF = 1 Then
+                If mRegisters.AL.LowNib() > 9 OrElse mFlags.AF = 1 Then
                     mRegisters.AX -= &H106
                     mFlags.AF = 1
                     mFlags.CF = 1
@@ -978,9 +968,7 @@ Public Class X8086
                     mFlags.AF = 0
                     mFlags.CF = 0
                 End If
-                mRegisters.AL = mRegisters.AL And &HF
-                mFlags.OF = 0
-                mFlags.SF = 0
+                mRegisters.AL = mRegisters.AL.LowNib()
                 clkCyc += 8
 
             Case &H40 To &H47 ' inc reg
@@ -1054,7 +1042,7 @@ Public Class X8086
             Case &H68 ' push (80186)
                 ' PRE ALPHA CODE - UNTESTED
                 If mVic20 Then
-                    PushIntoStack(Param(SelPrmIndex.First, , DataSize.Word))
+                    PushIntoStack(Param(ParamIndex.First, , DataSize.Word))
                     clkCyc += 3
                 End If
 
@@ -1063,7 +1051,7 @@ Public Class X8086
                     ' PRE ALPHA CODE - UNTESTED
                     SetAddressing()
                     Dim tmp1 As UInt32 = mRegisters.Val(addrMode.Register1)
-                    Dim tmp2 As UInt32 = Param(SelPrmIndex.First, , DataSize.Word)
+                    Dim tmp2 As UInt32 = Param(ParamIndex.First, , DataSize.Word)
                     If (tmp1 And &H8000) = &H8000 Then tmp1 = tmp1 Or &HFFFF0000UI
                     If (tmp2 And &H8000) = &H8000 Then tmp2 = tmp2 Or &HFFFF0000UI
                     Dim tmp3 As UInt32 = tmp1 * tmp2
@@ -1081,7 +1069,7 @@ Public Class X8086
             Case &H6A ' push (80186)
                 If mVic20 Then
                     ' PRE ALPHA CODE - UNTESTED
-                    PushIntoStack(Param(SelPrmIndex.First, , DataSize.Byte))
+                    PushIntoStack(Param(ParamIndex.First, , DataSize.Byte))
                     clkCyc += 3
                 End If
 
@@ -1090,7 +1078,7 @@ Public Class X8086
                     ' PRE ALPHA CODE - UNTESTED
                     SetAddressing()
                     Dim tmp1 As UInt32 = mRegisters.Val(addrMode.Register1)
-                    Dim tmp2 As UInt32 = To16bitsWithSign(Param(SelPrmIndex.First, , DataSize.Byte))
+                    Dim tmp2 As UInt32 = To16bitsWithSign(Param(ParamIndex.First, , DataSize.Byte))
                     If (tmp1 And &H8000) = &H8000 Then tmp1 = tmp1 Or &HFFFF0000UI
                     If (tmp2 And &H8000) = &H8000 Then tmp2 = tmp2 Or &HFFFF0000UI
                     Dim tmp3 As UInt32 = tmp1 * tmp2
@@ -1127,7 +1115,7 @@ Public Class X8086
                     clkCyc += 4
                 End If
 
-            Case &H72 ' jb/jnae
+            Case &H72 ' jb/jnae/jc (unsigned)
                 If mFlags.CF = 1 Then
                     IPAddrOffet = OffsetIP(DataSize.Byte)
                     clkCyc += 16
@@ -1136,7 +1124,7 @@ Public Class X8086
                     clkCyc += 4
                 End If
 
-            Case &H73 ' jnb/jae
+            Case &H73 ' jnb/jae/jnc (unsigned)
                 If mFlags.CF = 0 Then
                     IPAddrOffet = OffsetIP(DataSize.Byte)
                     clkCyc += 16
@@ -1163,7 +1151,7 @@ Public Class X8086
                     clkCyc += 4
                 End If
 
-            Case &H76 ' jbe/jna
+            Case &H76 ' jbe/jna (unsigned)
                 If mFlags.CF = 1 OrElse mFlags.ZF = 1 Then
                     IPAddrOffet = OffsetIP(DataSize.Byte)
                     clkCyc += 16
@@ -1173,7 +1161,7 @@ Public Class X8086
                 End If
 
 
-            Case &H77 ' jnbe/ja
+            Case &H77 ' ja/jnbe (unsigned)
                 If mFlags.CF = 0 AndAlso mFlags.ZF = 0 Then
                     IPAddrOffet = OffsetIP(DataSize.Byte)
                     clkCyc += 16
@@ -1218,7 +1206,7 @@ Public Class X8086
                     clkCyc += 4
                 End If
 
-            Case &H7C ' jl/jnge
+            Case &H7C ' jl/jnge (signed)
                 If mFlags.SF <> mFlags.OF Then
                     IPAddrOffet = OffsetIP(DataSize.Byte)
                     clkCyc += 16
@@ -1227,7 +1215,7 @@ Public Class X8086
                     clkCyc += 4
                 End If
 
-            Case &H7D ' jnl/jge
+            Case &H7D ' jnl/jge (signed)
                 If mFlags.SF = mFlags.OF Then
                     IPAddrOffet = OffsetIP(DataSize.Byte)
                     clkCyc += 16
@@ -1236,7 +1224,7 @@ Public Class X8086
                     clkCyc += 4
                 End If
 
-            Case &H7E ' jle/jng
+            Case &H7E ' jle/jng (signed)
                 If mFlags.ZF = 1 OrElse (mFlags.SF <> mFlags.OF) Then
                     IPAddrOffet = OffsetIP(DataSize.Byte)
                     clkCyc += 16
@@ -1245,7 +1233,7 @@ Public Class X8086
                     clkCyc += 4
                 End If
 
-            Case &H7F ' jnle/jg
+            Case &H7F ' jg/jnle (signed)
                 If mFlags.ZF = 0 AndAlso (mFlags.SF = mFlags.OF) Then
                     IPAddrOffet = OffsetIP(DataSize.Byte)
                     clkCyc += 16
@@ -1322,14 +1310,20 @@ Public Class X8086
                 SetAddressing(DataSize.Word)
                 SetRegister2ToSegReg()
                 If addrMode.IsDirect Then
-                    SetRegister1Alt(ParamNOPS(SelPrmIndex.First, , DataSize.Byte))
+                    SetRegister1Alt(ParamNOPS(ParamIndex.First, , DataSize.Byte))
                     mRegisters.Val(addrMode.Register2) = mRegisters.Val(addrMode.Register1)
                     clkCyc += 2
                 Else
                     mRegisters.Val(addrMode.Register2) = addrMode.IndMem
                     clkCyc += 8
                 End If
-                ignoreINTs = ignoreINTs Or (addrMode.Register2 = GPRegisters.RegistersTypes.CS)
+                ignoreINTs = ignoreINTs Or
+                        (addrMode.Register2 = GPRegisters.RegistersTypes.CS) Or
+                        (addrMode.Register2 = GPRegisters.RegistersTypes.SS) Or
+                        (addrMode.Register2 = GPRegisters.RegistersTypes.DS) Or
+                        (addrMode.Register2 = GPRegisters.RegistersTypes.ES)
+
+                If addrMode.Register2 = GPRegisters.RegistersTypes.CS Then FlushCycles()
 
             Case &H8F ' pop reg/mem
                 SetAddressing()
@@ -1352,12 +1346,7 @@ Public Class X8086
                 clkCyc += 3
 
             Case &H98 ' cbw
-                If (mRegisters.AL And &H80) = &H80 Then
-                    mRegisters.AH = &HFF
-                Else
-                    mRegisters.AH = &H0
-                End If
-                'mRegisters.AX = To16bitsWithSign(mRegisters.AL)
+                mRegisters.AX = To16bitsWithSign(mRegisters.AL)
                 clkCyc += 2
 
             Case &H99 ' cwd
@@ -1365,8 +1354,8 @@ Public Class X8086
                 clkCyc += 5
 
             Case &H9A ' call direct intersegment
-                IPAddrOffet = Param(SelPrmIndex.First, , DataSize.Word)
-                tmpVal = Param(SelPrmIndex.Second, , DataSize.Word)
+                IPAddrOffet = Param(ParamIndex.First, , DataSize.Word)
+                tmpVal = Param(ParamIndex.Second, , DataSize.Word)
 
                 PushIntoStack(mRegisters.CS)
                 PushIntoStack(mRegisters.IP + opCodeSize)
@@ -1391,12 +1380,13 @@ Public Class X8086
                 clkCyc += 4
 
             Case &H9F ' lahf
-                mRegisters.AH = mFlags.EFlags And &HFF
+                mRegisters.AH = mFlags.EFlags
                 clkCyc += 4
 
             Case &HA0 To &HA3 ' mov mem to acc | mov acc to mem
-                addrMode.Decode(opCode, opCode)
-                addrMode.IndAdr = Param(SelPrmIndex.First, , DataSize.Word)
+                addrMode.Size = opCode And 1
+                addrMode.Direction = (opCode >> 1) And 1
+                addrMode.IndAdr = Param(ParamIndex.First, , DataSize.Word)
                 addrMode.Register1 = If(addrMode.Size = DataSize.Byte, GPRegisters.RegistersTypes.AL, GPRegisters.RegistersTypes.AX)
                 If addrMode.Direction = 0 Then
                     mRegisters.Val(addrMode.Register1) = RAMn
@@ -1407,18 +1397,18 @@ Public Class X8086
 
             Case &HA4 To &HA7, &HAA To &HAF
                 HandleREPMode()
-                isStringOp = True
+                newPrefix = True
 
             Case &HA8 ' test al imm8
-                Eval(mRegisters.AL, Param(SelPrmIndex.First, , DataSize.Byte), Operation.Test, DataSize.Byte)
+                Eval(mRegisters.AL, Param(ParamIndex.First, , DataSize.Byte), Operation.Test, DataSize.Byte)
                 clkCyc += 4
 
             Case &HA9 ' test ax imm16
-                Eval(mRegisters.AX, Param(SelPrmIndex.First, , DataSize.Word), Operation.Test, DataSize.Word)
+                Eval(mRegisters.AX, Param(ParamIndex.First, , DataSize.Word), Operation.Test, DataSize.Word)
                 clkCyc += 4
 
             Case &HB0 To &HBF ' mov imm to reg
-                addrMode.Register1 = (opCode And &H7)
+                addrMode.Register1 = opCode And &H7
                 If (opCode And &H8) = &H8 Then
                     addrMode.Register1 += GPRegisters.RegistersTypes.AX
                     If (opCode And &H4) = &H4 Then addrMode.Register1 += GPRegisters.RegistersTypes.ES
@@ -1426,7 +1416,7 @@ Public Class X8086
                 Else
                     addrMode.Size = DataSize.Byte
                 End If
-                mRegisters.Val(addrMode.Register1) = Param(SelPrmIndex.First)
+                mRegisters.Val(addrMode.Register1) = Param(ParamIndex.First,, addrMode.Size)
                 clkCyc += 4
 
             Case &HC0, &HC1 ' GRP2 byte/word imm8/16 ??? (80186)
@@ -1437,7 +1427,7 @@ Public Class X8086
 
             Case &HC2 ' ret (ret n) within segment adding imm to sp
                 IPAddrOffet = PopFromStack()
-                mRegisters.SP += Param(SelPrmIndex.First, , DataSize.Word)
+                mRegisters.SP += Param(ParamIndex.First, , DataSize.Word)
                 clkCyc += 20
 
             Case &HC3 ' ret within segment
@@ -1446,30 +1436,27 @@ Public Class X8086
 
             Case &HC4 To &HC5 ' les | lds
                 SetAddressing(DataSize.Word)
-                If (addrMode.Register1 And shl2) = shl2 Then
-                    addrMode.Register1 = (addrMode.Register1 + GPRegisters.RegistersTypes.ES) Or shl3
-                Else
-                    addrMode.Register1 = (addrMode.Register1 Or shl3)
-                End If
-                mRegisters.Val(addrMode.Register1) = addrMode.IndMem
+                If (addrMode.Register1 And shl2) = shl2 Then addrMode.Register1 += GPRegisters.RegistersTypes.ES
+                mRegisters.Val(addrMode.Register1 Or shl3) = addrMode.IndMem
                 mRegisters.Val(If(opCode = &HC4, GPRegisters.RegistersTypes.ES, GPRegisters.RegistersTypes.DS)) = RAM16(mRegisters.ActiveSegmentValue, addrMode.IndAdr, 2)
+                ignoreINTs = True
                 clkCyc += 16
 
             Case &HC6 To &HC7 ' mov imm to reg/mem
                 SetAddressing()
                 If addrMode.IsDirect Then
-                    mRegisters.Val(addrMode.Register1) = Param(SelPrmIndex.First, opCodeSize)
+                    mRegisters.Val(addrMode.Register1) = Param(ParamIndex.First, opCodeSize)
                     clkCyc += 4
                 Else
-                    RAMn = Param(SelPrmIndex.First, opCodeSize)
+                    RAMn = Param(ParamIndex.First, opCodeSize)
                     clkCyc += 10
                 End If
 
             Case &HC8 ' enter (80186)
                 If mVic20 Then
                     ' PRE ALPHA CODE - UNTESTED
-                    Dim stackSize = Param(SelPrmIndex.First, , DataSize.Word)
-                    Dim nestLevel = Param(SelPrmIndex.Second, , DataSize.Byte) And &H1F
+                    Dim stackSize = Param(ParamIndex.First, , DataSize.Word)
+                    Dim nestLevel = Param(ParamIndex.Second, , DataSize.Byte) And &H1F
                     PushIntoStack(mRegisters.BP)
                     Dim frameTemp = mRegisters.SP
                     If nestLevel > 0 Then
@@ -1498,7 +1485,7 @@ Public Class X8086
                 End If
 
             Case &HCA ' ret intersegment adding imm to sp (ret n /retf)
-                tmpVal = Param(SelPrmIndex.First, , DataSize.Word)
+                tmpVal = Param(ParamIndex.First, , DataSize.Word)
                 IPAddrOffet = PopFromStack()
                 mRegisters.CS = PopFromStack()
                 mRegisters.SP += tmpVal
@@ -1514,7 +1501,7 @@ Public Class X8086
                 clkCyc += 52
 
             Case &HCD ' int with type specified
-                HandleInterrupt(Param(SelPrmIndex.First, , DataSize.Byte), False)
+                HandleInterrupt(Param(ParamIndex.First, , DataSize.Byte), False)
                 clkCyc += 51
 
             Case &HCE ' into
@@ -1534,25 +1521,27 @@ Public Class X8086
             Case &HD0 To &HD3 : ExecuteGroup2()
 
             Case &HD4 ' aam
-                Dim div As Byte = Param(SelPrmIndex.First, , DataSize.Byte)
-                If div = 0 Then
+                tmpVal = Param(ParamIndex.First, , DataSize.Byte)
+                If tmpVal = 0 Then
                     HandleInterrupt(0, True)
                     Exit Select
                 End If
-                mRegisters.AH = mRegisters.AL \ div
-                mRegisters.AL = mRegisters.AL Mod div
+                mRegisters.AH = mRegisters.AL \ tmpVal
+                mRegisters.AL = mRegisters.AL Mod tmpVal
                 SetSZPFlags(mRegisters.AX, DataSize.Word)
                 clkCyc += 83
 
             Case &HD5 ' aad
-                mRegisters.AL += mRegisters.AH * Param(SelPrmIndex.First, , DataSize.Byte)
+                mRegisters.AL += mRegisters.AH * Param(ParamIndex.First, , DataSize.Byte)
                 mRegisters.AH = 0
                 SetSZPFlags(mRegisters.AX, DataSize.Word)
                 mFlags.SF = 0
                 clkCyc += 60
 
-            Case &HD6 ' xlat 
-                If Not mVic20 Then
+            Case &HD6 ' xlat / salc
+                If mVic20 Then
+                    mRegisters.AL = RAM8(mRegisters.ActiveSegmentValue, mRegisters.BX + mRegisters.AL)
+                Else
                     mRegisters.AL = If(mFlags.CF = 1, &HFF, &H0)
                     clkCyc += 4
                 End If
@@ -1604,7 +1593,7 @@ Public Class X8086
                     clkCyc += 5
                 End If
 
-            Case &HE3 ' jcxz
+            Case &HE3 ' jcxz/jecxz
                 If mRegisters.CX = 0 Then
                     IPAddrOffet = OffsetIP(DataSize.Byte)
                     clkCyc += 18
@@ -1614,21 +1603,21 @@ Public Class X8086
                 End If
 
             Case &HE4 ' in to al from fixed port
-                mRegisters.AL = ReceiveFromPort(Param(SelPrmIndex.First, , DataSize.Byte))
+                mRegisters.AL = ReceiveFromPort(Param(ParamIndex.First, , DataSize.Byte))
                 clkCyc += 10
 
             Case &HE5 ' inw to ax from fixed port
-                mRegisters.AX = ReceiveFromPort(Param(SelPrmIndex.First, , DataSize.Byte))
+                mRegisters.AX = ReceiveFromPort(Param(ParamIndex.First, , DataSize.Byte))
                 clkCyc += 10
 
             Case &HE6  ' out to al to fixed port
                 FlushCycles()
-                SendToPort(Param(SelPrmIndex.First, , DataSize.Byte), mRegisters.AL)
+                SendToPort(Param(ParamIndex.First, , DataSize.Byte), mRegisters.AL)
                 clkCyc += 10
 
             Case &HE7  ' outw to ax to fixed port
                 FlushCycles()
-                SendToPort(Param(SelPrmIndex.First, , DataSize.Byte), mRegisters.AX)
+                SendToPort(Param(ParamIndex.First, , DataSize.Byte), mRegisters.AX)
                 clkCyc += 10
 
             Case &HE8 ' call direct within segment
@@ -1641,8 +1630,8 @@ Public Class X8086
                 clkCyc += 15
 
             Case &HEA ' jmp direct intersegment
-                IPAddrOffet = Param(SelPrmIndex.First, , DataSize.Word)
-                mRegisters.CS = Param(SelPrmIndex.Second, , DataSize.Word)
+                IPAddrOffet = Param(ParamIndex.First, , DataSize.Word)
+                mRegisters.CS = Param(ParamIndex.Second, , DataSize.Word)
                 clkCyc += 15
 
             Case &HEB ' jmp direct within segment short
@@ -1671,12 +1660,12 @@ Public Class X8086
 
             Case &HF2 ' repne/repnz
                 repeLoopMode = REPLoopModes.REPENE
-                isStringOp = True
+                newPrefix = True
                 clkCyc += 2
 
             Case &HF3 ' repe/repz
                 repeLoopMode = REPLoopModes.REPE
-                isStringOp = True
+                newPrefix = True
                 clkCyc += 2
 
             Case &HF4 ' hlt
@@ -1729,20 +1718,26 @@ Public Class X8086
 
         clkCyc += opCodeSize * 4
 
-        If Not isStringOp Then
+        If Not newPrefix Then
             If repeLoopMode <> REPLoopModes.None Then repeLoopMode = REPLoopModes.None
-            If mRegisters.ActiveSegmentChanged AndAlso repeLoopMode = REPLoopModes.None Then
+            If mRegisters.ActiveSegmentChanged Then
                 mRegisters.ResetActiveSegment()
                 clkCyc += 2
             End If
         End If
+
+        ' QBasic
+        If mRegisters.CS = &H4936 AndAlso mRegisters.IP = &H7F8 Then
+            mDebugMode = True
+            FlushCycles()
+        End If
     End Sub
 
     Private Sub ExecuteGroup1() ' &H80 To &H83
         SetAddressing()
 
         Dim arg1 As UInt16 = If(addrMode.IsDirect, mRegisters.Val(addrMode.Register2), addrMode.IndMem)               ' reg
-        Dim arg2 As UInt16 = Param(SelPrmIndex.First, opCodeSize, If(opCode = &H83, DataSize.Byte, addrMode.Size))    ' imm
+        Dim arg2 As UInt16 = Param(ParamIndex.First, opCodeSize, If(opCode = &H83, DataSize.Byte, addrMode.Size))    ' imm
         If opCode = &H83 Then arg2 = To16bitsWithSign(arg2)
 
         Select Case addrMode.Reg
@@ -1866,12 +1861,9 @@ Public Class X8086
         End If
 
         Select Case opCode
-            Case &HD0, &HD1
-                count = 1
-            Case &HD2, &HD3
-                count = mRegisters.CL
-            Case &HC0, &HC1
-                count = Param(SelPrmIndex.First,  , DataSize.Byte)
+            Case &HD0, &HD1 : count = 1
+            Case &HD2, &HD3 : count = mRegisters.CL
+            Case &HC0, &HC1 : count = Param(ParamIndex.First,  , DataSize.Byte)
         End Select
 
         If count = 0 Then
@@ -1888,52 +1880,57 @@ Public Class X8086
                 If count = 1 Then
                     newValue = (oldValue << 1) Or (oldValue >> mask07_15)
                     mFlags.CF = If((oldValue And mask80_8000) <> 0, 1, 0)
-                    mFlags.OF = mFlags.CF Xor ((newValue >> mask07_15) And 1)
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 Else
                     newValue = (oldValue << (count And mask07_15)) Or (oldValue >> (mask8_16 - (count And mask07_15)))
                     mFlags.CF = newValue And 1
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 End If
 
             Case 1 ' 001    --  ror
                 If count = 1 Then
                     newValue = (oldValue >> 1) Or (oldValue << mask07_15)
                     mFlags.CF = oldValue And 1
-                    mFlags.OF = (newValue >> mask07_15) Xor ((newValue >> (mask07_15 - 1)) And 1)
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 Else
                     newValue = (oldValue >> (count And mask07_15)) Or (oldValue << (mask8_16 - (count And mask07_15)))
                     mFlags.CF = If((newValue And mask80_8000) <> 0, 1, 0)
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 End If
 
             Case 2 ' 010    --  rcl
                 If count = 1 Then
                     newValue = (oldValue << 1) Or mFlags.CF
                     mFlags.CF = If((oldValue And mask80_8000) <> 0, 1, 0)
-                    mFlags.OF = mFlags.CF Xor ((newValue >> mask07_15) And 1)
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 Else
                     oldValue = oldValue Or (CUInt(mFlags.CF) << mask8_16)
                     newValue = (oldValue << (count Mod mask9_17)) Or (oldValue >> (mask9_17 - (count Mod mask9_17)))
                     mFlags.CF = If((newValue And mask100_10000) <> 0, 1, 0)
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 End If
 
             Case 3 ' 011    --  rcr
                 If count = 1 Then
                     newValue = (oldValue >> 1) Or (CUInt(mFlags.CF) << mask07_15)
                     mFlags.CF = oldValue And 1
-                    mFlags.OF = (newValue >> mask07_15) Xor ((newValue >> (mask07_15 - 1)) And 1)
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 Else
                     oldValue = oldValue Or (CUInt(mFlags.CF) << mask8_16)
                     newValue = (oldValue >> (count Mod mask9_17)) Or (oldValue << (mask9_17 - (count Mod mask9_17)))
                     mFlags.CF = If((newValue And mask100_10000) <> 0, 1, 0)
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 End If
 
             Case 4, 6 ' 100/110    --  shl/sal
                 If count = 1 Then
                     newValue = oldValue << 1
                     mFlags.CF = If((oldValue And mask80_8000) <> 0, 1, 0)
-                    mFlags.OF = If(mFlags.CF = (newValue >> mask07_15), 0, 1)
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 Else
-                    newValue = If(count > mask8_16, 0, (oldValue << count))
+                    newValue = If(count > mask8_16, 0, oldValue << count)
                     mFlags.CF = If((newValue And mask100_10000) <> 0, 1, 0)
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 End If
                 SetSZPFlags(newValue, addrMode.Size)
 
@@ -1941,11 +1938,12 @@ Public Class X8086
                 If count = 1 Then
                     newValue = oldValue >> 1
                     mFlags.CF = oldValue And 1
-                    mFlags.OF = If((oldValue And mask80_8000) <> 0, 1, 0)
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 Else
-                    newValue = If(count > mask8_16, 0, (oldValue >> (count - 1)))
+                    newValue = If(count > mask8_16, 0, oldValue >> (count - 1))
                     mFlags.CF = newValue And 1
-                    newValue = (newValue >> 1)
+                    newValue = newValue >> 1
+                    mFlags.OF = If(((oldValue Xor newValue) And mask80_8000) <> 0, 1, 0)
                 End If
                 SetSZPFlags(newValue, addrMode.Size)
 
@@ -1958,7 +1956,8 @@ Public Class X8086
                     oldValue = oldValue Or If((oldValue And mask80_8000) <> 0, maskFF00_FFFF0000, 0)
                     newValue = oldValue >> If(count >= mask8_16, mask07_15, count - 1)
                     mFlags.CF = newValue And 1
-                    newValue = newValue >> 1
+                    mFlags.OF = 0
+                    newValue = (newValue >> 1) And maskFF_FFFF
                 End If
                 SetSZPFlags(newValue, addrMode.Size)
 
@@ -1977,12 +1976,12 @@ Public Class X8086
         SetAddressing()
 
         Select Case addrMode.Reg
-            Case 0, 1 ' 000    --  test
+            Case 0 ' 000    --  test
                 If addrMode.IsDirect Then
-                    Eval(mRegisters.Val(addrMode.Register2), ToXbitsWithSign(Param(SelPrmIndex.First, opCodeSize)), Operation.Test, addrMode.Size)
+                    Eval(mRegisters.Val(addrMode.Register2), Param(ParamIndex.First, opCodeSize), Operation.Test, addrMode.Size)
                     clkCyc += 5
                 Else
-                    Eval(addrMode.IndMem, ToXbitsWithSign(Param(SelPrmIndex.First, opCodeSize)), Operation.Test, addrMode.Size)
+                    Eval(addrMode.IndMem, Param(ParamIndex.First, opCodeSize), Operation.Test, addrMode.Size)
                     clkCyc += 11
                 End If
 
@@ -2007,7 +2006,7 @@ Public Class X8086
                     RAMn = tmpVal
                     clkCyc += 16
                 End If
-                mFlags.CF = If((tmpVal And If(addrMode.Size = DataSize.Byte, &HFF, &HFFFF)) = 0, 0, 1)
+                'mFlags.CF = If((tmpVal And If(addrMode.Size = DataSize.Byte, &HFF, &HFFFF)) = 0, 0, 1)
 
             Case 4 ' 100    --  mul
                 If addrMode.IsDirect Then
@@ -2017,7 +2016,7 @@ Public Class X8086
                     Else
                         tmpVal = CUInt(mRegisters.Val(addrMode.Register2)) * mRegisters.AX
                         mRegisters.AX = tmpVal
-                        mRegisters.DX = (tmpVal >> 16)
+                        mRegisters.DX = tmpVal >> 16
                         clkCyc += 118
                     End If
                 Else
@@ -2027,7 +2026,7 @@ Public Class X8086
                     Else
                         tmpVal = CUInt(addrMode.IndMem) * mRegisters.AX
                         mRegisters.AX = tmpVal
-                        mRegisters.DX = (tmpVal >> 16)
+                        mRegisters.DX = tmpVal >> 16
                         clkCyc += 134
                     End If
                 End If
@@ -2040,7 +2039,7 @@ Public Class X8086
                     mFlags.CF = 0
                     mFlags.OF = 0
                 End If
-                If Not mVic20 Then mFlags.ZF = If(tmpVal <> 0, 1, 0) ' This is the test the BIOS uses to detect a VIC20 (8018x)
+                If mVic20 Then mFlags.ZF = If(tmpVal <> 0, 1, 0) ' This is the test the BIOS uses to detect a VIC20 (8018x)
 
             Case 5 ' 101    --  imul
                 If addrMode.IsDirect Then
@@ -2055,8 +2054,8 @@ Public Class X8086
                         mRegisters.AX = tmpVal
                         clkCyc += 70
                     Else
-                        Dim m1 As UInt32 = To32bitsWithSign(mRegisters.AX)
-                        Dim m2 As UInt32 = To32bitsWithSign(mRegisters.Val(addrMode.Register2))
+                        Dim m1 As UInt32 = mRegisters.AX
+                        Dim m2 As UInt32 = mRegisters.Val(addrMode.Register2)
 
                         m1 = If((m1 And &H8000) <> 0, m1 Or &HFFFF0000UI, m1)
                         m2 = If((m2 And &H8000) <> 0, m2 Or &HFFFF0000UI, m2)
@@ -2078,8 +2077,8 @@ Public Class X8086
                         mRegisters.AX = tmpVal
                         clkCyc += 76
                     Else
-                        Dim m1 As UInt32 = To32bitsWithSign(mRegisters.AX)
-                        Dim m2 As UInt32 = To32bitsWithSign(addrMode.IndMem)
+                        Dim m1 As UInt32 = mRegisters.AX
+                        Dim m2 As UInt32 = addrMode.IndMem
 
                         m1 = If((m1 And &H8000) <> 0, m1 Or &HFFFF0000UI, m1)
                         m2 = If((m2 And &H8000) <> 0, m2 Or &HFFFF0000UI, m2)
@@ -2091,10 +2090,7 @@ Public Class X8086
                     End If
                 End If
 
-                mFlags.SF = If((tmpVal And If(addrMode.Size = DataSize.Byte, &H80, &H8000)) <> 0, 1, 0)
-                Dim mask As UInt32 = If(addrMode.Size = DataSize.Byte, &HFF00, &HFFFF0000UI)
-                tmpVal = tmpVal And mask
-                If tmpVal <> 0 AndAlso tmpVal <> mask Then
+                If If(addrMode.Size = DataSize.Byte, mRegisters.AH, mRegisters.DX) <> 0 Then
                     mFlags.CF = 1
                     mFlags.OF = 1
                 Else
@@ -2152,25 +2148,28 @@ Public Class X8086
                 Dim num As UInt32
                 Dim result As UInt32
                 Dim remain As UInt32
-                Dim sign As Boolean
+                Dim signN As Boolean
+                Dim signD As Boolean
 
                 If addrMode.IsDirect Then
                     If addrMode.Size = DataSize.Byte Then
                         num = mRegisters.AX
                         div = To16bitsWithSign(mRegisters.Val(addrMode.Register2))
 
-                        sign = ((num Xor div) And &H8000) <> 0
-                        num = If(num < &H8000, num, ((Not num) + 1) And &HFFFF)
-                        div = If(div < &H8000, div, ((Not div) + 1) And &HFFFF)
+                        signN = (num And &H8000) <> 0
+                        signD = (div And &H8000) <> 0
+                        num = If(signN, ((Not num) + 1) And &HFFFF, num)
+                        div = If(signD, ((Not div) + 1) And &HFFFF, div)
 
                         clkCyc += 80
                     Else
                         num = (CUInt(mRegisters.DX) << 16) Or mRegisters.AX
                         div = To32bitsWithSign(mRegisters.Val(addrMode.Register2))
 
-                        sign = ((num Xor div) And &H80000000UI) <> 0
-                        num = If(num < &H80000000UI, num, ((Not num) + 1) And &HFFFFFFFFUI)
-                        div = If(div < &H80000000UI, div, ((Not div) + 1) And &HFFFFFFFFUI)
+                        signN = (num And &H80000000UI) <> 0
+                        signD = (div And &H80000000UI) <> 0
+                        num = If(signN, ((Not num) + 1) And &HFFFFFFFFUI, num)
+                        div = If(signD, ((Not div) + 1) And &HFFFFFFFFUI, div)
 
                         clkCyc += 144
                     End If
@@ -2179,18 +2178,20 @@ Public Class X8086
                         num = mRegisters.AX
                         div = To16bitsWithSign(addrMode.IndMem)
 
-                        sign = ((num Xor div) And &H8000) <> 0
-                        num = If(num < &H8000, num, ((Not num) + 1) And &HFFFF)
-                        div = If(div < &H8000, div, ((Not div) + 1) And &HFFFF)
+                        signN = (num And &H8000) <> 0
+                        signD = (div And &H8000) <> 0
+                        num = If(signN, ((Not num) + 1) And &HFFFF, num)
+                        div = If(signD, ((Not div) + 1) And &HFFFF, div)
 
                         clkCyc += 86
                     Else
                         num = (CUInt(mRegisters.DX) << 16) Or mRegisters.AX
                         div = To32bitsWithSign(addrMode.IndMem)
 
-                        sign = ((num Xor div) And &H80000000UI) <> 0
-                        num = If(num < &H80000000UI, num, ((Not num) + 1) And &HFFFFFFFFUI)
-                        div = If(div < &H80000000UI, div, ((Not div) + 1) And &HFFFFFFFFUI)
+                        signN = (num And &H80000000UI) <> 0
+                        signD = (div And &H80000000UI) <> 0
+                        num = If(signN, ((Not num) + 1) And &HFFFFFFFFUI, num)
+                        div = If(signD, ((Not div) + 1) And &HFFFFFFFFUI, div)
 
                         clkCyc += 150
                     End If
@@ -2204,16 +2205,21 @@ Public Class X8086
                 result = num \ div
                 remain = num Mod div
 
-                If (result And If(addrMode.Size = DataSize.Byte, &HFF00, &HFFFF0000UI)) <> 0 Then
-                    HandleInterrupt(0, True)
-                    Exit Select
-                End If
-
-                If sign Then
+                If signN <> signD Then
+                    If result > If(addrMode.Size = DataSize.Byte, &H80, &H8000) Then
+                        HandleInterrupt(0, True)
+                        Exit Select
+                    End If
                     result = (Not result) + 1
-                    remain = (Not remain) + 1
+                Else
+                    If result > If(addrMode.Size = DataSize.Byte, &H7F, &H7FFF) Then
+                        HandleInterrupt(0, True)
+                        Exit Select
+                    End If
                 End If
 
+                If signN Then remain = (Not remain) + 1
+
                 If addrMode.Size = DataSize.Byte Then
                     mRegisters.AL = result
                     mRegisters.AH = remain
@@ -2300,18 +2306,20 @@ Public Class X8086
             ExecStringOpCode()
         Else
             While mRegisters.CX > 0
-                mRegisters.CX -= 1 ' We don't really need all the safety checks from AddValues(mRegisters.CX, -1, DataSize.Word)
+                mRegisters.CX -= 1
                 If ExecStringOpCode() Then
                     If (repeLoopMode = REPLoopModes.REPE AndAlso mFlags.ZF = 0) OrElse
-                        (repeLoopMode = REPLoopModes.REPENE AndAlso mFlags.ZF = 1) Then
+                       (repeLoopMode = REPLoopModes.REPENE AndAlso mFlags.ZF = 1) Then
                         Exit While
                     End If
                 End If
+
                 If mDebugMode Then ' TODO: Need to add a parameter to make this optional
                     IncIP(-opCodeSize)
                     Exit Sub
                 End If
             End While
+
             repeLoopMode = REPLoopModes.None
         End If
 
@@ -2347,7 +2355,7 @@ Public Class X8086
                 Return False
 
             Case &HA6  ' cmpsb
-                Eval(RAM8(mRegisters.ActiveSegmentValue, mRegisters.SI), RAM8(mRegisters.ES, mRegisters.DI), Operation.Compare, DataSize.Byte)
+                Eval(RAM8(mRegisters.ActiveSegmentValue, mRegisters.SI,, True), RAM8(mRegisters.ES, mRegisters.DI), Operation.Compare, DataSize.Byte)
                 If mFlags.DF = 0 Then
                     mRegisters.SI += 1
                     mRegisters.DI += 1
@@ -2359,7 +2367,7 @@ Public Class X8086
                 Return True
 
             Case &HA7 ' cmpsw
-                Eval(RAM16(mRegisters.ActiveSegmentValue, mRegisters.SI), RAM16(mRegisters.ES, mRegisters.DI), Operation.Compare, DataSize.Word)
+                Eval(RAM16(mRegisters.ActiveSegmentValue, mRegisters.SI,, True), RAM16(mRegisters.ES, mRegisters.DI), Operation.Compare, DataSize.Word)
                 If mFlags.DF = 0 Then
                     mRegisters.SI += 2
                     mRegisters.DI += 2
@@ -2411,7 +2419,7 @@ Public Class X8086
                 Return False
 
             Case &HAE ' scasb
-                Eval(mRegisters.AL, RAM8(mRegisters.ES, mRegisters.DI), Operation.Compare, DataSize.Byte)
+                Eval(mRegisters.AL, RAM8(mRegisters.ES, mRegisters.DI,, True), Operation.Compare, DataSize.Byte)
                 If mFlags.DF = 0 Then
                     mRegisters.DI += 1
                 Else
@@ -2421,7 +2429,7 @@ Public Class X8086
                 Return True
 
             Case &HAF ' scasw
-                Eval(mRegisters.AX, RAM16(mRegisters.ES, mRegisters.DI), Operation.Compare, DataSize.Word)
+                Eval(mRegisters.AX, RAM16(mRegisters.ES, mRegisters.DI,, True), Operation.Compare, DataSize.Word)
                 If mFlags.DF = 0 Then
                     mRegisters.DI += 2
                 Else
diff --git a/x8086NetEmu/x8086NetEmu.vbproj b/x8086NetEmu/x8086NetEmu.vbproj
index 6baf28d..b5df88b 100644
--- a/x8086NetEmu/x8086NetEmu.vbproj
+++ b/x8086NetEmu/x8086NetEmu.vbproj
@@ -14,7 +14,7 @@
     <AssemblyName>x8086NetEmu</AssemblyName>
     <FileAlignment>512</FileAlignment>
     <MyType>Windows</MyType>
-    <TargetFrameworkVersion>v4.7.1</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
     <TargetFrameworkProfile>
     </TargetFrameworkProfile>
     <IsWebBootstrapper>false</IsWebBootstrapper>
@@ -40,6 +40,16 @@
     </SccAuxPath>
     <SccProvider>
     </SccProvider>
+    <ShouldCreateLogs>True</ShouldCreateLogs>
+    <AdvancedSettingsExpanded>True</AdvancedSettingsExpanded>
+    <UpdateAssemblyVersion>False</UpdateAssemblyVersion>
+    <UpdateAssemblyFileVersion>False</UpdateAssemblyFileVersion>
+    <UpdateAssemblyInfoVersion>False</UpdateAssemblyInfoVersion>
+    <UpdatePackageVersion>False</UpdatePackageVersion>
+    <AssemblyInfoVersionType>SettingsVersion</AssemblyInfoVersionType>
+    <InheritWinAppVersionFrom>None</InheritWinAppVersionFrom>
+    <AssemblyVersionSettings>
+    </AssemblyVersionSettings>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
     <PlatformTarget>x86</PlatformTarget>
@@ -115,6 +125,122 @@
     </WarningsAsErrors>
     <Prefer32Bit>false</Prefer32Bit>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <RemoveIntegerChecks>true</RemoveIntegerChecks>
+    <DocumentationFile>x8086NetEmu.xml</DocumentationFile>
+    <NoWarn>41999,42016,42017,42018,42019,42020,42021,42022,42032,42036</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <WarningsAsErrors>
+    </WarningsAsErrors>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <RemoveIntegerChecks>true</RemoveIntegerChecks>
+    <DocumentationFile>x8086NetEmu.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>41999,42016,42017,42018,42019,42020,42021,42022,42032,42036</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <WarningsAsErrors>
+    </WarningsAsErrors>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug %28Non Win%29|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <RemoveIntegerChecks>true</RemoveIntegerChecks>
+    <DocumentationFile>x8086NetEmu.xml</DocumentationFile>
+    <NoWarn>41999,42016,42017,42018,42019,42020,42021,42022,42032,42036</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <WarningsAsErrors>
+    </WarningsAsErrors>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release %28Non Win%29|x64'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <RemoveIntegerChecks>true</RemoveIntegerChecks>
+    <DocumentationFile>x8086NetEmu.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>41999,42016,42017,42018,42019,42020,42021,42022,42032,42036</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <WarningsAsErrors>
+    </WarningsAsErrors>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <RemoveIntegerChecks>true</RemoveIntegerChecks>
+    <DocumentationFile>x8086NetEmu.xml</DocumentationFile>
+    <NoWarn>41999,42016,42017,42018,42019,42020,42021,42022,42032,42036</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <WarningsAsErrors>
+    </WarningsAsErrors>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <RemoveIntegerChecks>true</RemoveIntegerChecks>
+    <DocumentationFile>x8086NetEmu.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>41999,42016,42017,42018,42019,42020,42021,42022,42032,42036</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <WarningsAsErrors>
+    </WarningsAsErrors>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug %28Non Win%29|AnyCPU'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <RemoveIntegerChecks>true</RemoveIntegerChecks>
+    <DocumentationFile>x8086NetEmu.xml</DocumentationFile>
+    <NoWarn>41999,42016,42017,42018,42019,42020,42021,42022,42032,42036</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <WarningsAsErrors>
+    </WarningsAsErrors>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release %28Non Win%29|AnyCPU'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <RemoveIntegerChecks>true</RemoveIntegerChecks>
+    <DocumentationFile>x8086NetEmu.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>41999,42016,42017,42018,42019,42020,42021,42022,42032,42036</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <WarningsAsErrors>
+    </WarningsAsErrors>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="NAudio, Version=1.8.4.0, Culture=neutral, processorArchitecture=MSIL">
       <HintPath>..\packages\NAudio.1.8.4\lib\net35\NAudio.dll</HintPath>
@@ -123,6 +249,7 @@
     <Reference Include="System.Data" />
     <Reference Include="System.Drawing" />
     <Reference Include="System.Management" />
+    <Reference Include="System.Web" />
     <Reference Include="System.Windows.Forms" />
     <Reference Include="System.Xml" />
     <Reference Include="System.Core" />
@@ -143,8 +270,9 @@
     <Compile Include="Adapters\Adapter.vb" />
     <Compile Include="Adapters\Adapters.vb" />
     <Compile Include="Adapters\Audio\AdlibAdapter.vb" />
+    <Compile Include="Adapters\Audio\SoundBlaster.vb" />
     <Compile Include="Adapters\Audio\SpeakerAdapter.vb" />
-    <Compile Include="Adapters\Disk\FileSystem\FAT12_16.vb" />
+    <Compile Include="Adapters\Disk\FileSystem\FileSystemStructs.vb" />
     <Compile Include="Adapters\Disk\FileSystem\StandardDiskFormat.vb" />
     <Compile Include="Adapters\Disk\FloppyController.vb" />
     <Compile Include="Adapters\Disk\FileSystem\HostFolderAsDisk.vb" />
@@ -159,6 +287,7 @@
     <Compile Include="Adapters\Video\VGA\VGAWinForms.vb" />
     <Compile Include="Adapters\Video\VideoAdapter.vb" />
     <Compile Include="Adapters\Video\VideoChar.vb" />
+    <Compile Include="Adapters\WebUI.vb" />
     <Compile Include="Chipset\RTC.vb" />
     <Compile Include="Chipset\PPI8255_ALT.vb" />
     <Compile Include="Helpers\Binary.vb" />
@@ -268,7 +397,7 @@
   <Import Project="$(MSBuildToolsPath)\Microsoft.VisualBasic.targets" />
   <ProjectExtensions>
     <VisualStudio>
-      <UserProperties BuildVersion_DetectChanges="False" BuildVersion_BuildAction="Both" BuildVersion_UpdateFileVersion="True" BuildVersion_UpdateAssemblyVersion="True" BuildVersion_BuildVersioningStyle="None.None.Increment.None" />
+      <UserProperties BuildVersion_BuildVersioningStyle="None.None.Increment.None" BuildVersion_UpdateAssemblyVersion="True" BuildVersion_UpdateFileVersion="True" BuildVersion_BuildAction="Both" BuildVersion_DetectChanges="False" />
     </VisualStudio>
   </ProjectExtensions>
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
diff --git a/x8086NetEmu/x8087.vb b/x8086NetEmu/x8087.vb
index bbc3363..296c1bd 100644
--- a/x8086NetEmu/x8087.vb
+++ b/x8086NetEmu/x8087.vb
@@ -69,13 +69,13 @@ Public Class x8087
                         FCOM()
                         If fpu.Tags(TOP) = TAGe.Empty Then Stop ' E_Exit("FPU stack underflow")
                         fpu.Tags(TOP) = TAGe.Empty
-                        TOP = ((TOP + 1) And 7)
+                        TOP = (TOP + 1) And 7
                 End Select
             Case &HD9
                 Select Case opCode2
                     Case &HD0 ' FNOP
                     Case &HE0 ' FCHS
-                        fpu.Regs(TOP).d = -1.0 * (fpu.Regs(TOP).d)
+                        fpu.Regs(TOP).d = -1.0 * fpu.Regs(TOP).d
                     Case &HE1 ' FABS
                         fpu.Regs(TOP).d = Math.Abs(fpu.Regs(TOP).d)
                     Case &HF0 ' F2XM1
diff --git a/x8086NetEmuConsole/MainModule.vb b/x8086NetEmuConsole/MainModule.vb
index 91e33c4..46a282f 100644
--- a/x8086NetEmuConsole/MainModule.vb
+++ b/x8086NetEmuConsole/MainModule.vb
@@ -5,20 +5,35 @@ Module MainModule
 
     Sub Main()
         X8086.LogToConsole = False
+
+        AddHandler X8086.Error, Sub(s As Object, e As X8086.EmulatorErrorEventArgs)
+                                    cpu?.Pause()
+                                    Console.WriteLine(e.Message)
+                                    cpu?.Close()
+                                    Environment.Exit(1)
+                                End Sub
+
         cpu = New X8086(True, True)
 
+        AddHandler cpu.EmulationTerminated, Sub() Environment.Exit(0)
+
         cpu.Adapters.Add(New FloppyControllerAdapter(cpu))
         cpu.Adapters.Add(New CGAConsole(cpu))
         cpu.Adapters.Add(New KeyboardAdapter(cpu))
-        'cpu.Adapters.Add(New MouseAdapter(cpu)) ' Not Compatible with MINIX
+        ' cpu.Adapters.Add(New MouseAdapter(cpu)) ' So far, useless in Console mode
 
 #If Win32 Then
         cpu.Adapters.Add(New SpeakerAdpater(cpu))
+        cpu.Adapters.Add(New AdlibAdapter(cpu))
 #End If
 
         LoadSettings()
 
         cpu.Run()
+
+        Do
+            Threading.Thread.Sleep(500)
+        Loop
     End Sub
 
     Private Sub LoadSettings()
diff --git a/x8086NetEmuConsole/My Project/AssemblyInfo.vb b/x8086NetEmuConsole/My Project/AssemblyInfo.vb
index 2ab8e48..c9c2df1 100644
--- a/x8086NetEmuConsole/My Project/AssemblyInfo.vb	
+++ b/x8086NetEmuConsole/My Project/AssemblyInfo.vb	
@@ -31,5 +31,5 @@ Imports System.Runtime.InteropServices
 ' by using the '*' as shown below:
 ' <Assembly: AssemblyVersion("1.0.*")> 
 
-<Assembly: AssemblyVersion("2018.8.27.470")>
-<Assembly: AssemblyFileVersion("2018.8.27.465")>
+<Assembly: AssemblyVersion("2019.2.13.792")>
+<Assembly: AssemblyFileVersion("2019.2.13.787")>
diff --git a/x8086NetEmuConsole/My Project/Settings.Designer.vb b/x8086NetEmuConsole/My Project/Settings.Designer.vb
index 6def46c..030cb18 100644
--- a/x8086NetEmuConsole/My Project/Settings.Designer.vb	
+++ b/x8086NetEmuConsole/My Project/Settings.Designer.vb	
@@ -15,7 +15,7 @@ Option Explicit On
 Namespace My
     
     <Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
-     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.5.0.0"),  _
+     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.8.0.0"),  _
      Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
     Partial Friend NotInheritable Class MySettings
         Inherits Global.System.Configuration.ApplicationSettingsBase
diff --git a/x8086NetEmuConsole/app.config b/x8086NetEmuConsole/app.config
index 4da05d8..df2d1f9 100644
--- a/x8086NetEmuConsole/app.config
+++ b/x8086NetEmuConsole/app.config
@@ -20,4 +20,4 @@
             <!--<add name="EventLog" type="System.Diagnostics.EventLogTraceListener" initializeData="APPLICATION_NAME"/> -->
         </sharedListeners>
     </system.diagnostics>
-<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.1"/></startup></configuration>
+<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/></startup></configuration>
diff --git a/x8086NetEmuConsole/x8086NetEmuConsole.vbproj b/x8086NetEmuConsole/x8086NetEmuConsole.vbproj
index 2afc5ec..337fbc5 100644
--- a/x8086NetEmuConsole/x8086NetEmuConsole.vbproj
+++ b/x8086NetEmuConsole/x8086NetEmuConsole.vbproj
@@ -11,7 +11,7 @@
     <AssemblyName>x8086NetEmuConsole</AssemblyName>
     <FileAlignment>512</FileAlignment>
     <MyType>Console</MyType>
-    <TargetFrameworkVersion>v4.7.1</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
     <TargetFrameworkProfile />
     <SccProjectName>
     </SccProjectName>
@@ -86,6 +86,98 @@
     <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
     <Prefer32Bit>false</Prefer32Bit>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <DocumentationFile>x8086NetEmuConsole.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <DocumentationFile>x8086NetEmuConsole.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug %28Non Win%29|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <DocumentationFile>x8086NetEmuConsole.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release %28Non Win%29|x64'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <DocumentationFile>x8086NetEmuConsole.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <DocumentationFile>x8086NetEmuConsole.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <DocumentationFile>x8086NetEmuConsole.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug %28Non Win%29|AnyCPU'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <DocumentationFile>x8086NetEmuConsole.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release %28Non Win%29|AnyCPU'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <DocumentationFile>x8086NetEmuConsole.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Data" />
diff --git a/x8086NetEmuWinForms/FormEmulator.Designer.vb b/x8086NetEmuWinForms/FormEmulator.Designer.vb
index c3ff31b..bd07397 100644
--- a/x8086NetEmuWinForms/FormEmulator.Designer.vb
+++ b/x8086NetEmuWinForms/FormEmulator.Designer.vb
@@ -66,6 +66,8 @@ Partial Class FormEmulator
         Me.Zoom150ToolStripMenuItem = New System.Windows.Forms.ToolStripMenuItem()
         Me.Zoom200ToolStripMenuItem = New System.Windows.Forms.ToolStripMenuItem()
         Me.Zoom400ToolStripMenuItem = New System.Windows.Forms.ToolStripMenuItem()
+        Me.ToolStripMenuItem6 = New System.Windows.Forms.ToolStripSeparator()
+        Me.ZoomFullScreenToolStripMenuItem = New System.Windows.Forms.ToolStripMenuItem()
         Me.ContextMenuStripMain.SuspendLayout()
         Me.SuspendLayout()
         '
@@ -74,50 +76,50 @@ Partial Class FormEmulator
         Me.ViewToolStripMenuItem.DropDownItems.AddRange(New System.Windows.Forms.ToolStripItem() {Me.DebuggerToolStripMenuItem, Me.ConsoleToolStripMenuItem, Me.ToolStripMenuItem4, Me.CopyTextToolStripMenuItem, Me.PasteTextToolStripMenuItem})
         Me.ViewToolStripMenuItem.Image = Global.x8086NetEmuWinForms.My.Resources.Resources.tools_icon
         Me.ViewToolStripMenuItem.Name = "ViewToolStripMenuItem"
-        Me.ViewToolStripMenuItem.Size = New System.Drawing.Size(152, 22)
+        Me.ViewToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
         Me.ViewToolStripMenuItem.Text = "Tools"
         '
         'DebuggerToolStripMenuItem
         '
         Me.DebuggerToolStripMenuItem.Name = "DebuggerToolStripMenuItem"
-        Me.DebuggerToolStripMenuItem.Size = New System.Drawing.Size(152, 22)
+        Me.DebuggerToolStripMenuItem.Size = New System.Drawing.Size(135, 22)
         Me.DebuggerToolStripMenuItem.Text = "Debugger..."
         '
         'ConsoleToolStripMenuItem
         '
         Me.ConsoleToolStripMenuItem.Name = "ConsoleToolStripMenuItem"
-        Me.ConsoleToolStripMenuItem.Size = New System.Drawing.Size(152, 22)
+        Me.ConsoleToolStripMenuItem.Size = New System.Drawing.Size(135, 22)
         Me.ConsoleToolStripMenuItem.Text = "Console..."
         '
         'ToolStripMenuItem4
         '
         Me.ToolStripMenuItem4.Name = "ToolStripMenuItem4"
-        Me.ToolStripMenuItem4.Size = New System.Drawing.Size(149, 6)
+        Me.ToolStripMenuItem4.Size = New System.Drawing.Size(132, 6)
         '
         'CopyTextToolStripMenuItem
         '
         Me.CopyTextToolStripMenuItem.Name = "CopyTextToolStripMenuItem"
-        Me.CopyTextToolStripMenuItem.Size = New System.Drawing.Size(152, 22)
+        Me.CopyTextToolStripMenuItem.Size = New System.Drawing.Size(135, 22)
         Me.CopyTextToolStripMenuItem.Text = "Copy Text"
         '
         'PasteTextToolStripMenuItem
         '
         Me.PasteTextToolStripMenuItem.Name = "PasteTextToolStripMenuItem"
-        Me.PasteTextToolStripMenuItem.Size = New System.Drawing.Size(152, 22)
+        Me.PasteTextToolStripMenuItem.Size = New System.Drawing.Size(135, 22)
         Me.PasteTextToolStripMenuItem.Text = "Paste Text"
         '
         'ContextMenuStripMain
         '
         Me.ContextMenuStripMain.Items.AddRange(New System.Windows.Forms.ToolStripItem() {Me.EmulatorToolStripMenuItem, Me.MediaToolStripMenuItem, Me.ZoomToolStripMenuItem, Me.ViewToolStripMenuItem})
         Me.ContextMenuStripMain.Name = "ContextMenuStripMain"
-        Me.ContextMenuStripMain.Size = New System.Drawing.Size(153, 114)
+        Me.ContextMenuStripMain.Size = New System.Drawing.Size(181, 114)
         '
         'EmulatorToolStripMenuItem
         '
         Me.EmulatorToolStripMenuItem.DropDownItems.AddRange(New System.Windows.Forms.ToolStripItem() {Me.CPUClockToolStripMenuItem, Me.EmulationSpeedToolStripMenuItem, Me.ToolStripMenuItem5, Me.INT13EmulationToolStripMenuItem, Me.VIC20EmulationToolStripMenuItem, Me.ToolStripMenuItem1, Me.SoftResetToolStripMenuItem, Me.HardResetToolStripMenuItem, Me.ToolStripMenuItem2, Me.LoadStateToolStripMenuItem, Me.SaveStateToolStripMenuItem, Me.ToolStripMenuItem3, Me.ExitToolStripMenuItem})
         Me.EmulatorToolStripMenuItem.Image = Global.x8086NetEmuWinForms.My.Resources.Resources.icon
         Me.EmulatorToolStripMenuItem.Name = "EmulatorToolStripMenuItem"
-        Me.EmulatorToolStripMenuItem.Size = New System.Drawing.Size(152, 22)
+        Me.EmulatorToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
         Me.EmulatorToolStripMenuItem.Text = "Emulator"
         '
         'CPUClockToolStripMenuItem
@@ -282,28 +284,28 @@ Partial Class FormEmulator
         '
         Me.MediaToolStripMenuItem.Image = Global.x8086NetEmuWinForms.My.Resources.Resources.media_icon
         Me.MediaToolStripMenuItem.Name = "MediaToolStripMenuItem"
-        Me.MediaToolStripMenuItem.Size = New System.Drawing.Size(152, 22)
+        Me.MediaToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
         Me.MediaToolStripMenuItem.Text = "Media..."
         '
         'ZoomToolStripMenuItem
         '
         Me.ZoomToolStripMenuItem.AutoToolTip = True
-        Me.ZoomToolStripMenuItem.DropDownItems.AddRange(New System.Windows.Forms.ToolStripItem() {Me.Zoom25ToolStripMenuItem, Me.Zoom50ToolStripMenuItem, Me.Zoom100ToolStripMenuItem, Me.Zoom150ToolStripMenuItem, Me.Zoom200ToolStripMenuItem, Me.Zoom400ToolStripMenuItem})
+        Me.ZoomToolStripMenuItem.DropDownItems.AddRange(New System.Windows.Forms.ToolStripItem() {Me.Zoom25ToolStripMenuItem, Me.Zoom50ToolStripMenuItem, Me.Zoom100ToolStripMenuItem, Me.Zoom150ToolStripMenuItem, Me.Zoom200ToolStripMenuItem, Me.Zoom400ToolStripMenuItem, Me.ToolStripMenuItem6, Me.ZoomFullScreenToolStripMenuItem})
         Me.ZoomToolStripMenuItem.Image = Global.x8086NetEmuWinForms.My.Resources.Resources.zoom_icon
         Me.ZoomToolStripMenuItem.Name = "ZoomToolStripMenuItem"
-        Me.ZoomToolStripMenuItem.Size = New System.Drawing.Size(152, 22)
+        Me.ZoomToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
         Me.ZoomToolStripMenuItem.Text = "Zoom"
         '
         'Zoom25ToolStripMenuItem
         '
         Me.Zoom25ToolStripMenuItem.Name = "Zoom25ToolStripMenuItem"
-        Me.Zoom25ToolStripMenuItem.Size = New System.Drawing.Size(102, 22)
+        Me.Zoom25ToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
         Me.Zoom25ToolStripMenuItem.Text = "25%"
         '
         'Zoom50ToolStripMenuItem
         '
         Me.Zoom50ToolStripMenuItem.Name = "Zoom50ToolStripMenuItem"
-        Me.Zoom50ToolStripMenuItem.Size = New System.Drawing.Size(102, 22)
+        Me.Zoom50ToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
         Me.Zoom50ToolStripMenuItem.Text = "50%"
         '
         'Zoom100ToolStripMenuItem
@@ -311,27 +313,38 @@ Partial Class FormEmulator
         Me.Zoom100ToolStripMenuItem.Checked = True
         Me.Zoom100ToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked
         Me.Zoom100ToolStripMenuItem.Name = "Zoom100ToolStripMenuItem"
-        Me.Zoom100ToolStripMenuItem.Size = New System.Drawing.Size(102, 22)
+        Me.Zoom100ToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
         Me.Zoom100ToolStripMenuItem.Text = "100%"
         '
         'Zoom150ToolStripMenuItem
         '
         Me.Zoom150ToolStripMenuItem.Name = "Zoom150ToolStripMenuItem"
-        Me.Zoom150ToolStripMenuItem.Size = New System.Drawing.Size(102, 22)
+        Me.Zoom150ToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
         Me.Zoom150ToolStripMenuItem.Text = "150%"
         '
         'Zoom200ToolStripMenuItem
         '
         Me.Zoom200ToolStripMenuItem.Name = "Zoom200ToolStripMenuItem"
-        Me.Zoom200ToolStripMenuItem.Size = New System.Drawing.Size(102, 22)
+        Me.Zoom200ToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
         Me.Zoom200ToolStripMenuItem.Text = "200%"
         '
         'Zoom400ToolStripMenuItem
         '
         Me.Zoom400ToolStripMenuItem.Name = "Zoom400ToolStripMenuItem"
-        Me.Zoom400ToolStripMenuItem.Size = New System.Drawing.Size(102, 22)
+        Me.Zoom400ToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
         Me.Zoom400ToolStripMenuItem.Text = "400%"
         '
+        'ToolStripMenuItem6
+        '
+        Me.ToolStripMenuItem6.Name = "ToolStripMenuItem6"
+        Me.ToolStripMenuItem6.Size = New System.Drawing.Size(177, 6)
+        '
+        'ZoomFullScreenToolStripMenuItem
+        '
+        Me.ZoomFullScreenToolStripMenuItem.Name = "ZoomFullScreenToolStripMenuItem"
+        Me.ZoomFullScreenToolStripMenuItem.Size = New System.Drawing.Size(180, 22)
+        Me.ZoomFullScreenToolStripMenuItem.Text = "Full Screen"
+        '
         'FormEmulator
         '
         Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
@@ -390,4 +403,6 @@ Partial Class FormEmulator
     Friend WithEvents INT13EmulationToolStripMenuItem As ToolStripMenuItem
     Friend WithEvents VIC20EmulationToolStripMenuItem As ToolStripMenuItem
     Friend WithEvents ToolStripMenuItem5 As ToolStripSeparator
+    Friend WithEvents ToolStripMenuItem6 As ToolStripSeparator
+    Friend WithEvents ZoomFullScreenToolStripMenuItem As ToolStripMenuItem
 End Class
diff --git a/x8086NetEmuWinForms/FormEmulator.vb b/x8086NetEmuWinForms/FormEmulator.vb
index 4a4903d..2c02fa5 100644
--- a/x8086NetEmuWinForms/FormEmulator.vb
+++ b/x8086NetEmuWinForms/FormEmulator.vb
@@ -33,6 +33,9 @@ Public Class FormEmulator
     Private fromColRow As Point
     Private toColRow As Point
 
+    Private lastZoomLevel As Double
+    Private lastLocation As Point
+
     Private v20Emulation As Boolean
     Private int13Emulation As Boolean
 
@@ -68,12 +71,12 @@ Public Class FormEmulator
         AddHandler ConsoleToolStripMenuItem.Click, Sub() ShowConsole()
         AddHandler SoftResetToolStripMenuItem.Click, Sub()
                                                          runningApp = ""
-                                                         Me.Invoke(New MethodInvoker(AddressOf SetTitleText))
+                                                         Me.Invoke(Sub() SetTitleText())
                                                          cpu.SoftReset()
                                                      End Sub
         AddHandler HardResetToolStripMenuItem.Click, Sub()
                                                          runningApp = ""
-                                                         Me.Invoke(New MethodInvoker(AddressOf SetTitleText))
+                                                         Me.Invoke(Sub() SetTitleText())
                                                          cpu.HardReset()
                                                      End Sub
         AddHandler MediaToolStripMenuItem.Click, Sub() RunMediaManager()
@@ -118,6 +121,7 @@ Public Class FormEmulator
                                                  If (e1.KeyData And Keys.Control) = Keys.Control AndAlso Convert.ToBoolean(GetAsyncKeyState(Keys.RControlKey)) Then
                                                      Cursor.Clip = Rectangle.Empty
                                                      CursorVisible = True
+                                                     If cpu.Mouse IsNot Nothing Then cpu.Mouse.IsCaptured = False
 
                                                      Select Case e1.KeyCode
                                                          Case Keys.Home
@@ -144,7 +148,7 @@ Public Class FormEmulator
                                             If e1.Button = Windows.Forms.MouseButtons.Middle Then ContextMenuStripMain.Show(Cursor.Position)
                                         End Sub
 #End If
-        AddHandler cpu.MIPsUpdated, Sub() Me.Invoke(New MethodInvoker(AddressOf SetTitleText))
+        AddHandler cpu.MIPsUpdated, Sub() Me.Invoke(Sub() SetTitleText())
     End Sub
 
     Private Sub WarnAboutRestart()
@@ -217,7 +221,7 @@ Public Class FormEmulator
                                     sysMenIntegercut,
                                     cpu.Clock / X8086.MHz,
                                     cpu.SimulationMultiplier * 100,
-                                    $"{cpu.VideoAdapter.Name.Split(" "c)(0)} Mode {cpu.VideoAdapter.VideoMode:X2}{If(cpu.VideoAdapter.MainMode = VideoAdapter.MainModes.Text, "ð£", "ð")} | Zoom {cpu.VideoAdapter.Zoom * 100}%",
+                                    $"{cpu.VideoAdapter.Name.Split(" "c)(0)} Mode {cpu.VideoAdapter.VideoMode:X2}{If(cpu.VideoAdapter.MainMode = VideoAdapter.MainModes.Text, "T", "G")} | Zoom {cpu.VideoAdapter.Zoom * 100}%",
                                     cpu.MIPs,
                                     If(cpu.IsHalted, "Halted", If(cpu.DebugMode, "Debugging", If(cpu.IsPaused, "Paused", "Running"))),
                                     If(runningApp <> "", $" | {runningApp}", ""))
@@ -235,8 +239,10 @@ Public Class FormEmulator
     End Sub
 
     Private Sub StartEmulation()
-        cpu = New X8086(v20Emulation, True, AddressOf StartEmulation)
-
+        cpu = New X8086(v20Emulation, int13Emulation, Sub()
+                                                          SaveSettings()
+                                                          StartEmulation()
+                                                      End Sub)
         cpuState = New EmulatorState(cpu)
 
         If videoPort IsNot Nothing Then
@@ -249,21 +255,22 @@ Public Class FormEmulator
         videoPort.Focus()
 
         cpu.Adapters.Add(New FloppyControllerAdapter(cpu))
-        cpu.Adapters.Add(New CGAWinForms(cpu, videoPort, If(ConsoleCrayon.RuntimeIsMono, VideoAdapter.FontSources.TrueType, VideoAdapter.FontSources.BitmapFile), "asciivga.dat"))
-        'cpu.Adapters.Add(New VGAWinForms(cpu, videoPort, If(ConsoleCrayon.RuntimeIsMono, VideoAdapter.FontSources.TrueType, VideoAdapter.FontSources.BitmapFile), "asciivga.dat"))
+        cpu.Adapters.Add(New CGAWinForms(cpu, videoPort, If(ConsoleCrayon.RuntimeIsMono, VideoAdapter.FontSources.TrueType, VideoAdapter.FontSources.BitmapFile), "asciivga.dat", True))
+        'cpu.Adapters.Add(New VGAWinForms(cpu, videoPort, If(ConsoleCrayon.RuntimeIsMono, VideoAdapter.FontSources.TrueType, VideoAdapter.FontSources.BitmapFile), "asciivga.dat", True))
         cpu.Adapters.Add(New KeyboardAdapter(cpu))
-        'cpu.Adapters.Add(New MouseAdapter(cpu)) ' This breaks many things (For example, MINIX won't start)
+        cpu.Adapters.Add(New MouseAdapter(cpu)) ' This breaks many things (For example, MINIX won't start, PC Tools' PCShell doesn't respond)
 
 #If Win32 Then
         cpu.Adapters.Add(New SpeakerAdpater(cpu))
         cpu.Adapters.Add(New AdlibAdapter(cpu))
+        cpu.Adapters.Add(New SoundBlaster(cpu, cpu.Adapters.Last()))
 #End If
 
-        cpu.VideoAdapter.AutoSize()
+        cpu.VideoAdapter?.AutoSize()
 
         X8086.LogToConsole = False
 
-        'cpu.LoadBIN("80186_tests\div.bin", &HF000, &H0)
+        'cpu.LoadBIN("80186_tests\jump2.bin", &HF000, &H0)
         'cpu.Run(True, &HF000, 0)
         cpu.Run()
         If cpu.DebugMode Then ShowDebugger()
@@ -297,28 +304,29 @@ Public Class FormEmulator
                                             Dim GetFileName = Function() As String
                                                                   Dim b As New List(Of Byte)
                                                                   Dim addr As UInt32 = X8086.SegmentOffetToAbsolute(cpu.Registers.DS, cpu.Registers.DX)
-                                                                  While cpu.RAM(addr) <> 0
-                                                                      b.Add(cpu.RAM(addr))
+                                                                  While cpu.Memory(addr) <> 0
+                                                                      b.Add(cpu.Memory(addr))
                                                                       addr += 1
                                                                   End While
                                                                   Return System.Text.Encoding.ASCII.GetString(b.ToArray())
                                                               End Function
 
-                                            runningApp = GetFileName() ' ParseRunningApp()
+                                            runningApp = GetFileName()
 
                                             Select Case cpu.Registers.AL
                                                 Case 0 : mode = "L&X" ' Load & Execute
-                                                Case 1 : mode = "UND" ' Undocumented
+                                                Case 1 : mode = "LOD" ' Load
                                                 Case 2 : mode = "UNK" ' Unknown
-                                                Case 3 : mode = "LOD" ' Load
-                                                Case 4 : mode = "MSC" ' Whatever this means: Called by MSC spawn() when P_NOWAIT is specified
+                                                Case 3 : mode = "LOO" ' Load Overlay
+                                                Case 4 : mode = "MSC" ' Load & Execute in background
                                             End Select
 
-                                            Const offset As UInt32 = &H12
-                                            Dim cs As UInt32 = cpu.RAM16(cpu.Registers.ES, cpu.Registers.BX, offset)
-                                            Dim ip As UInt32 = cpu.RAM16(cpu.Registers.ES, cpu.Registers.BX, offset + If(cpu.Registers.AL = 1, 4, 2))
-                                            X8086.Notify($"DOS {mode}: {runningApp} -> {cpu.Registers.ES:X4}:{cpu.Registers.BX:X4}", X8086.NotificationReasons.Dbg)
-                                            X8086.Notify($"DOS {mode}: {runningApp} -> {cs:X4}:{ip:X4}", X8086.NotificationReasons.Dbg)
+                                            'Const offset As UInt32 = &H12
+                                            'Dim cs As UInt32 = cpu.RAM16(cpu.Registers.ES, cpu.Registers.BX, offset)
+                                            'Dim ip As UInt32 = cpu.RAM16(cpu.Registers.ES, cpu.Registers.BX, offset + If(cpu.Registers.AL = 1, 4, 2))
+                                            'X8086.Notify($"DOS {mode}: {runningApp} -> {cpu.Registers.ES:X4}:{cpu.Registers.BX:X4}", X8086.NotificationReasons.Dbg)
+                                            X8086.Notify($"DOS {mode}: {runningApp}", X8086.NotificationReasons.Dbg)
+                                            'X8086.Notify($"   CS:IP {cpu.Registers.CS:X4}:{cpu.Registers.IP + 2:X4}", X8086.NotificationReasons.Dbg)
                                     End Select
 
                                     ' Return False to notify the emulator that the interrupt was not handled.
@@ -373,9 +381,11 @@ Public Class FormEmulator
                                         End Sub
 
         AddHandler videoPort.MouseMove, Sub(s As Object, e As MouseEventArgs)
-                                            If isLeftMouseButtonDown Then
-                                                toColRow = New Point(e.X / videoPort.Width * cpu.VideoAdapter.TextResolution.Width,
-                                                                     e.Y / videoPort.Height * cpu.VideoAdapter.TextResolution.Height)
+                                            If CursorVisible Then
+                                                If isLeftMouseButtonDown Then
+                                                    toColRow = New Point(e.X / videoPort.Width * cpu.VideoAdapter.TextResolution.Width,
+                                                                         e.Y / videoPort.Height * cpu.VideoAdapter.TextResolution.Height)
+                                                End If
                                             End If
                                         End Sub
 
@@ -399,11 +409,19 @@ Public Class FormEmulator
 
         AddHandler videoPort.Click, Sub(s1 As Object, e1 As EventArgs)
                                         If isSelectingText Then Exit Sub
-                                        Cursor.Clip = Me.RectangleToScreen(videoPort.Bounds)
-                                        CursorVisible = False
+                                        CaptureMouse()
                                     End Sub
     End Sub
 
+    Private Sub CaptureMouse()
+        Cursor.Clip = Me.RectangleToScreen(videoPort.Bounds)
+        CursorVisible = False
+        If cpu.Mouse IsNot Nothing Then
+            cpu.Mouse.MidPoint = PointToClient(New Point(videoPort.Width / 2, videoPort.Height / 2))
+            cpu.Mouse.IsCaptured = True
+        End If
+    End Sub
+
     Private Sub ShowConsole()
         If fConsole Is Nothing Then
             fConsole = New FormConsole()
@@ -433,7 +451,36 @@ Public Class FormEmulator
     End Sub
 
     Private Sub SetZoomFromMenu(sender As Object, e As EventArgs) Handles Zoom25ToolStripMenuItem.Click, Zoom50ToolStripMenuItem.Click, Zoom100ToolStripMenuItem.Click,
-                                                                        Zoom150ToolStripMenuItem.Click, Zoom200ToolStripMenuItem.Click, Zoom400ToolStripMenuItem.Click
+                                                                        Zoom150ToolStripMenuItem.Click, Zoom200ToolStripMenuItem.Click, Zoom400ToolStripMenuItem.Click,
+                                                                        ZoomFullScreenToolStripMenuItem.Click
+
+        If Me.TopMost Then
+            Me.FormBorderStyle = FormBorderStyle.FixedSingle
+            Me.Location = lastLocation
+            Me.TopMost = False
+            SetZoomLevel(lastZoomLevel)
+        End If
+
+        If sender Is ZoomFullScreenToolStripMenuItem Then
+            lastZoomLevel = cpu.VideoAdapter.Zoom
+            lastLocation = Me.Location
+
+            Me.FormBorderStyle = FormBorderStyle.None
+            Me.Location = Point.Empty
+            Me.TopMost = True
+
+            While cpu.VideoAdapter.TextResolution.Width * cpu.VideoAdapter.CellSize.Width * cpu.VideoAdapter.Zoom < Screen.FromControl(Me).Bounds.Size.Width AndAlso
+                  cpu.VideoAdapter.TextResolution.Height * cpu.VideoAdapter.CellSize.Height * cpu.VideoAdapter.Zoom < Screen.FromControl(Me).Bounds.Size.Height
+                SetZoomLevel(cpu.VideoAdapter.Zoom + 0.01)
+            End While
+            ZoomFullScreenToolStripMenuItem.Checked = True
+
+            Me.Size = Screen.FromControl(Me).Bounds.Size
+
+            CaptureMouse()
+
+            Exit Sub
+        End If
 
         Dim zoomText As String = CType(sender, ToolStripMenuItem).Text
         Dim zoomPercentage As Integer = Integer.Parse(zoomText.Replace("%", ""))
@@ -483,7 +530,7 @@ Public Class FormEmulator
         Else
             If showPrompt Then
                 If MsgBox($"It looks like this is the first time you run the emulator.{Environment.NewLine}" +
-                          $"Use the 'RightCtrl + Home' hotkey to access the emulator settings.{Environment.NewLine}{Environment.NewLine}" +
+                          $"Use the 'RightCtrl + Home' hotkey to access the emulator settings or click over the title bar.{Environment.NewLine}{Environment.NewLine}" +
                           $"Would you like to configure the emulator's floppies and hard drives now?", MsgBoxStyle.Information Or MsgBoxStyle.YesNo) = MsgBoxResult.Yes Then
                     RunMediaManager()
                 End If
@@ -508,7 +555,15 @@ Public Class FormEmulator
             Next
 
             SetCPUClockSpeed(Double.Parse(xml.<clockSpeed>.Value))
-            SetZoomLevel(Double.Parse(xml.<videoZoom>.Value))
+            If xml.<extras>.<fullScreen>.Value IsNot Nothing AndAlso Boolean.Parse(xml.<extras>.<fullScreen>.Value) Then
+                SetZoomLevel(Double.Parse(xml.<extras>.<lastZoomLevel>.Value))
+                Threading.Tasks.Task.Run(Sub()
+                                             Threading.Thread.Sleep(250)
+                                             Me.Invoke(Sub() SetZoomFromMenu(ZoomFullScreenToolStripMenuItem, New EventArgs()))
+                                         End Sub)
+            Else
+                SetZoomLevel(Double.Parse(xml.<videoZoom>.Value))
+            End If
 
             If cpu.FloppyContoller IsNot Nothing Then
                 For i As Integer = 0 To 512 - 1
@@ -588,6 +643,8 @@ Public Class FormEmulator
                                   <debuggerVisible><%= fDebugger IsNot Nothing %></debuggerVisible>
                                   <emulateINT13><%= int13Emulation %></emulateINT13>
                                   <vic20><%= v20Emulation %></vic20>
+                                  <fullScreen><%= Me.TopMost %></fullScreen>
+                                  <lastZoomLevel><%= lastZoomLevel %></lastZoomLevel>
                               </extras>)
     End Sub
 
@@ -642,7 +699,7 @@ Public Class FormEmulator
         cpu.Registers.BP = xml.<registers>.<BP>.Value
         cpu.Registers.ActiveSegmentRegister = [Enum].Parse(GetType(X8086.GPRegisters.RegistersTypes), xml.<registers>.<AS>.Value)
 
-        cpu.Memory = Convert.FromBase64String(xml.<memory>.Value)
+        Array.Copy(Convert.FromBase64String(xml.<memory>.Value), cpu.Memory, cpu.Memory.Length)
         cpu.DebugMode = Boolean.Parse(xml.<debugMode>.Value)
 
         cpu.VideoAdapter.VideoMode = [Enum].Parse(GetType(CGAAdapter.VideoModes), xml.<videoMode>.Value)
@@ -690,9 +747,9 @@ Public Class FormEmulator
                 Dim expectedData() As Byte = IO.File.ReadAllBytes(expectedFileName)
                 For i As Integer = 0 To expectedData.Length - 1
                     'If expectedData(i) <> 0 Then
-                    If expectedData(i) <> cpu.RAM8(0, i) Then
+                    If expectedData(i) <> cpu.RAM8(0, i,, True) Then
                         failed = True
-                        MsgBox($"{file.Name} failed at offset {i}{Environment.NewLine}Expected: {expectedData(i):X2}{Environment.NewLine}Found: {cpu.RAM8(0, i):X2}")
+                        MsgBox($"{file.Name} failed at offset {i}{Environment.NewLine}Expected: {expectedData(i):X2}{Environment.NewLine}Found: {cpu.RAM8(0, i,, True):X2}")
                     End If
                     'End If
                 Next
diff --git a/x8086NetEmuWinForms/My Project/AssemblyInfo.vb b/x8086NetEmuWinForms/My Project/AssemblyInfo.vb
index 971e6d0..6c3e363 100644
--- a/x8086NetEmuWinForms/My Project/AssemblyInfo.vb	
+++ b/x8086NetEmuWinForms/My Project/AssemblyInfo.vb	
@@ -31,5 +31,5 @@ Imports System.Runtime.InteropServices
 ' by using the '*' as shown below:
 ' <Assembly: AssemblyVersion("1.0.*")> 
 
-<Assembly: AssemblyVersion("2018.8.27.4508")>
-<Assembly: AssemblyFileVersion("2018.8.27.4506")>
+<Assembly: AssemblyVersion("2019.2.13.6350")>
+<Assembly: AssemblyFileVersion("2019.2.13.6348")>
diff --git a/x8086NetEmuWinForms/My Project/Settings.Designer.vb b/x8086NetEmuWinForms/My Project/Settings.Designer.vb
index 9961a4c..ff6a9f9 100644
--- a/x8086NetEmuWinForms/My Project/Settings.Designer.vb	
+++ b/x8086NetEmuWinForms/My Project/Settings.Designer.vb	
@@ -15,7 +15,7 @@ Option Explicit On
 Namespace My
     
     <Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
-     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.5.0.0"),  _
+     Global.System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.8.0.0"),  _
      Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
     Partial Friend NotInheritable Class MySettings
         Inherits Global.System.Configuration.ApplicationSettingsBase
diff --git a/x8086NetEmuWinForms/Tools/FormConsole.vb b/x8086NetEmuWinForms/Tools/FormConsole.vb
index 0aba50e..a699615 100644
--- a/x8086NetEmuWinForms/Tools/FormConsole.vb
+++ b/x8086NetEmuWinForms/Tools/FormConsole.vb
@@ -60,13 +60,13 @@ Public Class FormConsole
     End Sub
 
     Private Sub UpdateRtf()
-        Me.Invoke(New MethodInvoker(Sub()
-                                        SyncLock Me
-                                            RichTextBoxConsole.Rtf = rtfTextStd.Replace("%", rtfText)
-                                            RichTextBoxConsole.SelectionStart = RichTextBoxConsole.TextLength
-                                            RichTextBoxConsole.ScrollToCaret()
-                                        End SyncLock
-                                    End Sub))
+        Me.Invoke(Sub()
+                      SyncLock Me
+                          RichTextBoxConsole.Rtf = rtfTextStd.Replace("%", rtfText)
+                          RichTextBoxConsole.SelectionStart = RichTextBoxConsole.TextLength
+                          RichTextBoxConsole.ScrollToCaret()
+                      End SyncLock
+                  End Sub)
     End Sub
 
     Private ReadOnly Property MillTime As String
diff --git a/x8086NetEmuWinForms/Tools/FormDebugger.Designer.vb b/x8086NetEmuWinForms/Tools/FormDebugger.Designer.vb
index 5ad4e6a..88f122b 100644
--- a/x8086NetEmuWinForms/Tools/FormDebugger.Designer.vb
+++ b/x8086NetEmuWinForms/Tools/FormDebugger.Designer.vb
@@ -672,7 +672,7 @@ Partial Class FormDebugger
         Me.ButtonStep.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.ButtonStep.FlatAppearance.BorderColor = System.Drawing.Color.DimGray
         Me.ButtonStep.FlatStyle = System.Windows.Forms.FlatStyle.Flat
-        Me.ButtonStep.Location = New System.Drawing.Point(882, 604)
+        Me.ButtonStep.Location = New System.Drawing.Point(942, 604)
         Me.ButtonStep.Name = "ButtonStep"
         Me.ButtonStep.Size = New System.Drawing.Size(97, 32)
         Me.ButtonStep.TabIndex = 13
@@ -692,7 +692,7 @@ Partial Class FormDebugger
         Me.ListViewCode.HideSelection = False
         Me.ListViewCode.Location = New System.Drawing.Point(551, 18)
         Me.ListViewCode.Name = "ListViewCode"
-        Me.ListViewCode.Size = New System.Drawing.Size(531, 578)
+        Me.ListViewCode.Size = New System.Drawing.Size(591, 578)
         Me.ListViewCode.TabIndex = 15
         Me.ListViewCode.UseCompatibleStateImageBehavior = False
         Me.ListViewCode.View = System.Windows.Forms.View.Details
@@ -718,7 +718,7 @@ Partial Class FormDebugger
         Me.ButtonRefresh.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.ButtonRefresh.FlatAppearance.BorderColor = System.Drawing.Color.DimGray
         Me.ButtonRefresh.FlatStyle = System.Windows.Forms.FlatStyle.Flat
-        Me.ButtonRefresh.Location = New System.Drawing.Point(779, 604)
+        Me.ButtonRefresh.Location = New System.Drawing.Point(839, 604)
         Me.ButtonRefresh.Name = "ButtonRefresh"
         Me.ButtonRefresh.Size = New System.Drawing.Size(97, 32)
         Me.ButtonRefresh.TabIndex = 12
@@ -788,7 +788,7 @@ Partial Class FormDebugger
         Me.ButtonRun.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.ButtonRun.FlatAppearance.BorderColor = System.Drawing.Color.DimGray
         Me.ButtonRun.FlatStyle = System.Windows.Forms.FlatStyle.Flat
-        Me.ButtonRun.Location = New System.Drawing.Point(985, 604)
+        Me.ButtonRun.Location = New System.Drawing.Point(1045, 604)
         Me.ButtonRun.Name = "ButtonRun"
         Me.ButtonRun.Size = New System.Drawing.Size(97, 32)
         Me.ButtonRun.TabIndex = 14
@@ -846,7 +846,7 @@ Partial Class FormDebugger
         Me.CheckBoxBytesOrChars.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CheckBoxBytesOrChars.AutoSize = True
         Me.CheckBoxBytesOrChars.FlatStyle = System.Windows.Forms.FlatStyle.Flat
-        Me.CheckBoxBytesOrChars.Location = New System.Drawing.Point(761, 615)
+        Me.CheckBoxBytesOrChars.Location = New System.Drawing.Point(821, 615)
         Me.CheckBoxBytesOrChars.Name = "CheckBoxBytesOrChars"
         Me.CheckBoxBytesOrChars.Size = New System.Drawing.Size(12, 11)
         Me.CheckBoxBytesOrChars.TabIndex = 11
@@ -903,7 +903,7 @@ Partial Class FormDebugger
         Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
         Me.BackColor = System.Drawing.Color.FromArgb(CType(CType(33, Byte), Integer), CType(CType(33, Byte), Integer), CType(CType(33, Byte), Integer))
-        Me.ClientSize = New System.Drawing.Size(1094, 648)
+        Me.ClientSize = New System.Drawing.Size(1154, 648)
         Me.Controls.Add(Me.CheckBoxBytesOrChars)
         Me.Controls.Add(Me.ButtonMemForward)
         Me.Controls.Add(Me.ButtonMemBack)
diff --git a/x8086NetEmuWinForms/Tools/FormDebugger.vb b/x8086NetEmuWinForms/Tools/FormDebugger.vb
index 24265bc..64998b0 100644
--- a/x8086NetEmuWinForms/Tools/FormDebugger.vb
+++ b/x8086NetEmuWinForms/Tools/FormDebugger.vb
@@ -3,6 +3,13 @@ Imports x8086NetEmu
 Imports System.Text
 
 Public Class FormDebugger
+    Public Enum LastInstructionMode
+        Normal
+        [Call]
+        Interrupt
+        Repe
+    End Enum
+
     Private Structure Breakpoint
         Public Segment As Integer
         Public Offset As Integer
@@ -73,6 +80,11 @@ Public Class FormDebugger
     Private baseCS As Integer
     Private baseIP As Integer
 
+    Private lastInstruction As Queue(Of LastInstructionMode) = New Queue(Of LastInstructionMode)
+    Private isShiftKeyDown As Boolean
+    Private instructionDecoded As Boolean
+    Private abortF8 As Boolean
+
     Private debugMode As DebugModes = DebugModes.Step
 
     Private loopWaiter As AutoResetEvent
@@ -119,8 +131,8 @@ Public Class FormDebugger
 
         Dim uiRefreshThread As New Thread(Sub()
                                               Do
-                                                  UpdateUI()
-                                                  Thread.Sleep(1000)
+                                                  If Not ignoreEvents Then UpdateUI()
+                                                  Thread.Sleep(500)
                                               Loop Until abortThreads
                                           End Sub) With {
                                             .IsBackground = True
@@ -141,6 +153,7 @@ Public Class FormDebugger
             isInit = False
             ignoreEvents = True
             abortThreads = True
+            abortF8 = True
 
             ohpWaiter.Set()
             loopWaiter.Set()
@@ -150,15 +163,22 @@ Public Class FormDebugger
     End Sub
 
     Private Sub FormDebugger_KeyDown(sender As Object, e As KeyEventArgs) Handles Me.KeyDown
+        isShiftKeyDown = e.Shift
+
         Select Case e.KeyCode
             Case Keys.F5
                 If debugMode = DebugModes.Step Then StartStopRunMode()
             Case Keys.F8
+                abortF8 = True
                 If debugMode = DebugModes.Run Then debugMode = DebugModes.Step
                 StepInto()
         End Select
     End Sub
 
+    Private Sub FormDebugger_KeyUp(sender As Object, e As KeyEventArgs) Handles Me.KeyUp
+        isShiftKeyDown = e.Shift
+    End Sub
+
     Private Sub ButtonStep_Click(sender As Object, e As EventArgs) Handles ButtonStep.Click
         debugMode = DebugModes.Step
         StepInto()
@@ -264,9 +284,12 @@ Public Class FormDebugger
                                                          loopWaiter.Set()
                                                      End Sub
             'AddHandler mEmulator.EmulationTerminated, Sub() If isRunning Then StartStopRunMode()
+            AddHandler mEmulator.InstructionDecoded, Sub() instructionDecoded = True
             isInit = True
 
-            StepInto()
+            'StepInto()
+            mEmulator.DoReschedule = True
+            mEmulator.DebugMode = True
         End Set
     End Property
 
@@ -276,16 +299,16 @@ Public Class FormDebugger
         SyncLock syncObject
             ignoreEvents = True
 
-            Me.Invoke(New MethodInvoker(Sub()
-                                            GenCodeAhead()
-                                            UpdateFlagsAndRegisters()
+            Me.Invoke(Sub()
+                          GenCodeAhead()
+                          UpdateFlagsAndRegisters()
 
-                                            If Now.Second Mod 2 = 0 Then
-                                                UpdateMemory()
-                                                SetSegmentTextBoxesState()
-                                                UpdateStack()
-                                            End If
-                                        End Sub))
+                          If Now.Second Mod 2 = 0 Then
+                              UpdateMemory()
+                              SetSegmentTextBoxesState()
+                              UpdateStack()
+                          End If
+                      End Sub)
             ignoreEvents = False
         End SyncLock
     End Sub
@@ -319,7 +342,7 @@ Public Class FormDebugger
                 Dim mem As String = ""
                 Dim bcr As String = "    "
                 For k = 0 To 15
-                    b = mEmulator.RAM(address + i + k)
+                    b = mEmulator.Memory(address + i + k)
                     If k = 8 Then mem += "- "
                     mem += $"{b:X2} "
                     If b <= 31 OrElse b > 122 Then
@@ -372,6 +395,7 @@ Public Class FormDebugger
 
     Private Function EvaluateExpression(value As String) As EvaluateResult
         If value = "" Then Return New EvaluateResult()
+        'value = value.ToUpper()
         Dim result As Integer = 0
 
         If value.Contains("AS") Then
@@ -505,7 +529,7 @@ Public Class FormDebugger
 
             For ptr As Integer = startOffset To endOffset Step -2
                 Dim address As String = X8086.SegmentOffetToAbsolute(.Registers.SS, ptr).ToString("X5")
-                Dim value As Integer = .RAM16(.Registers.SS, ptr)
+                Dim value As Integer = .RAM16(.Registers.SS, ptr,, True)
 
                 Dim item As ListViewItem
                 If index < ListViewStack.Items.Count Then
@@ -663,7 +687,76 @@ Public Class FormDebugger
         '    ' TODO: Implement a better solution to the case when this code is executed and historyPointer is set to -1
         'End Try
 
-        mEmulator.StepInto()
+        If isShiftKeyDown Then
+            Tasks.Task.Run(AddressOf RunShiftF8)
+        Else
+            mEmulator.StepInto()
+        End If
+    End Sub
+
+    Private Sub RunShiftF8()
+        Dim oc As Byte
+
+        Dim processOpCode = Sub(ignoreNormal As Boolean)
+                                oc = mEmulator.RAM8(mEmulator.Registers.CS, mEmulator.Registers.IP,, True)
+
+                                Select Case oc
+                                    Case &H9A, &HE8 : lastInstruction.Enqueue(LastInstructionMode.Call)
+                                    Case &HFF
+                                        Dim am As New X8086.AddressingMode()
+                                        am.Decode(oc, mEmulator.RAM8(mEmulator.Registers.CS, mEmulator.Registers.IP, 1, True))
+                                        If am.Reg = 2 OrElse am.Reg = 3 Then
+                                            lastInstruction.Enqueue(LastInstructionMode.Call)
+                                        Else
+                                            If Not ignoreNormal Then lastInstruction.Enqueue(LastInstructionMode.Normal)
+                                        End If
+                                    Case &HCC To &HCE : lastInstruction.Enqueue(LastInstructionMode.Interrupt)
+                                        ' Not yet supported
+                                        'Case &HF2, &HF3 : lastInstruction.Enqueue(LastInstructionMode.Repe)
+                                    Case Else : If Not ignoreNormal Then lastInstruction.Enqueue(LastInstructionMode.Normal)
+                                End Select
+                            End Sub
+
+        Dim kickEmulation = Sub()
+                                instructionDecoded = False
+                                mEmulator.StepInto()
+                                Tasks.Task.Run(Sub()
+                                                   While Not instructionDecoded
+                                                       Thread.Sleep(1)
+                                                   End While
+                                               End Sub).Wait()
+                            End Sub
+
+        ignoreEvents = True
+        processOpCode(False)
+
+        Do
+            Select Case lastInstruction.Peek()
+                Case LastInstructionMode.Normal
+                    lastInstruction.Dequeue()
+                    mEmulator.StepInto()
+                    Exit Do
+                Case LastInstructionMode.Call
+                    kickEmulation()
+                    oc = mEmulator.RAM8(mEmulator.Registers.CS, mEmulator.Registers.IP,, True)
+                    If oc = &HC2 OrElse oc = &HC3 OrElse oc = &HCA OrElse oc = &HCB Then
+                        kickEmulation()
+                        lastInstruction.Dequeue()
+                        If lastInstruction.Count = 0 Then Exit Do
+                    End If
+                Case LastInstructionMode.Interrupt
+                    kickEmulation()
+                    oc = mEmulator.RAM8(mEmulator.Registers.CS, mEmulator.Registers.IP,, True)
+                    If oc = &HCA OrElse oc = &HCF Then
+                        kickEmulation()
+                        lastInstruction.Dequeue()
+                        If lastInstruction.Count = 0 Then Exit Do
+                    End If
+            End Select
+            processOpCode(True)
+        Loop While Not abortF8 AndAlso lastInstruction.Count > 0
+        lastInstruction.Clear()
+        ignoreEvents = False
     End Sub
 
     Private Sub RunLoop()
@@ -772,9 +865,7 @@ Public Class FormDebugger
             ohpWaiter.WaitOne(30)
             If abortThreads Then Exit Sub
 
-            If offsetHistoryDirection <> 0 Then
-                Me.Invoke(New MethodInvoker(Sub() OffsetHistoryPointer(offsetHistoryDirection)))
-            End If
+            If offsetHistoryDirection <> 0 Then Me.Invoke(Sub() OffsetHistoryPointer(offsetHistoryDirection))
         Loop
     End Sub
 
diff --git a/x8086NetEmuWinForms/Tools/FormDiskExplorer.vb b/x8086NetEmuWinForms/Tools/FormDiskExplorer.vb
index bfaba30..f696732 100644
--- a/x8086NetEmuWinForms/Tools/FormDiskExplorer.vb
+++ b/x8086NetEmuWinForms/Tools/FormDiskExplorer.vb
@@ -5,7 +5,9 @@ Public Class FormDiskExplorer
     Private sdf As StandardDiskFormat
     Private selectedParitionIndex As Integer
     Private ignoreNextEvent As Boolean
-    Private isMouseDown As Boolean
+    Private draggedItems As New List(Of String)
+    Private isLeftMouseDown As Boolean
+    Private mouseDownLocation As Point
 
     Public Sub Initialize(fileName As String)
         sdf = New StandardDiskFormat(New IO.FileStream(fileName, IO.FileMode.Open, IO.FileAccess.Read, IO.FileShare.ReadWrite))
@@ -34,7 +36,7 @@ Public Class FormDiskExplorer
 
                                                                 Dim rootNode As TreeNode
                                                                 Dim volLabels As IEnumerable(Of String) = (From de In sdf.RootDirectoryEntries(selectedParitionIndex)
-                                                                                                           Where (de.Attribute And FAT12_16.EntryAttributes.VolumeName) = FAT12_16.EntryAttributes.VolumeName
+                                                                                                           Where (de.Attribute And FAT12.EntryAttributes.VolumeName) = FAT12.EntryAttributes.VolumeName
                                                                                                            Select (de.FileName))
 
                                                                 TreeViewDirs.Nodes.Clear()
@@ -49,25 +51,26 @@ Public Class FormDiskExplorer
                                                             End Sub
 
         For i As Integer = 0 To sdf.MasterBootRecord.Partitions.Length - 1
-            If sdf.MasterBootRecord.Partitions(i).SystemId = StandardDiskFormat.SystemIds.FAT_12 OrElse sdf.MasterBootRecord.Partitions(i).SystemId = StandardDiskFormat.SystemIds.FAT_16 Then
-                ComboBoxPartitions.Items.Add(sdf.MasterBootRecord.Partitions(i).ToString() +
+            Select Case sdf.MasterBootRecord.Partitions(i).SystemId
+                Case StandardDiskFormat.SystemIds.FAT_12, StandardDiskFormat.SystemIds.FAT_16, StandardDiskFormat.SystemIds.FAT_BIGDOS
+                    ComboBoxPartitions.Items.Add(sdf.MasterBootRecord.Partitions(i).ToString() +
                                              $" {If(sdf.IsBootable(i), "BOOT", "")} [H:{sdf.Heads(i)} C:{sdf.Cylinders(i)} S:{sdf.Sectors(i)}]")
-            End If
+            End Select
         Next
 
         If ComboBoxPartitions.Items.Count > 0 Then ComboBoxPartitions.SelectedIndex = 0
     End Sub
 
-    Private Sub DisplayFileSystem(parentNode As TreeNode, entries() As FAT12_16.DirectoryEntry)
+    Private Sub DisplayFileSystem(parentNode As TreeNode, entries() As FAT12.DirectoryEntry)
         If entries Is Nothing Then entries = sdf.RootDirectoryEntries(selectedParitionIndex)
 
         Dim directories = From de In entries
-                          Where (de.Attribute And FAT12_16.EntryAttributes.Directory) = FAT12_16.EntryAttributes.Directory AndAlso
+                          Where (de.Attribute And FAT12.EntryAttributes.Directory) = FAT12.EntryAttributes.Directory AndAlso
                                 Convert.ToByte(de.FileNameChars(0)) < &H5E
                           Order By de.FileName
         Dim files = From de In entries
-                    Where (de.Attribute And FAT12_16.EntryAttributes.Directory) <> FAT12_16.EntryAttributes.Directory AndAlso
-                          (de.Attribute And FAT12_16.EntryAttributes.VolumeName) <> FAT12_16.EntryAttributes.VolumeName AndAlso
+                    Where (de.Attribute And FAT12.EntryAttributes.Directory) <> FAT12.EntryAttributes.Directory AndAlso
+                          (de.Attribute And FAT12.EntryAttributes.VolumeName) <> FAT12.EntryAttributes.VolumeName AndAlso
                           Convert.ToByte(de.FileNameChars(0)) < &H5E
                     Order By GetTypeDescription(de.FileExtension)
 
@@ -146,13 +149,13 @@ Public Class FormDiskExplorer
         Return index
     End Function
 
-    Private Function FindNode(d As FAT12_16.DirectoryEntry, parentNode As TreeNode) As TreeNode
+    Private Function FindNode(d As FAT12.DirectoryEntry, parentNode As TreeNode) As TreeNode
         For Each n As TreeNode In parentNode.Nodes
-            If n.Tag IsNot Nothing AndAlso CType(n.Tag, FAT12_16.DirectoryEntry) = d Then
+            If n.Tag IsNot Nothing AndAlso CType(n.Tag, FAT12.DirectoryEntry) = d Then
                 Return n
             ElseIf n.Nodes.Count > 0 Then
                 n = FindNode(d, n)
-                If n?.Tag IsNot Nothing AndAlso CType(n.Tag, FAT12_16.DirectoryEntry) = d Then Return n
+                If n?.Tag IsNot Nothing AndAlso CType(n.Tag, FAT12.DirectoryEntry) = d Then Return n
             End If
         Next
         Return Nothing
@@ -175,7 +178,7 @@ Public Class FormDiskExplorer
         Dim node As TreeNode = e.Node
         If node Is Nothing Then Exit Sub
 
-        Dim entry As FAT12_16.DirectoryEntry = CType(node.Tag, FAT12_16.DirectoryEntry)
+        Dim entry As FAT12.DirectoryEntry = CType(node.Tag, FAT12.DirectoryEntry)
         DisplayFileSystem(node, sdf.GetDirectoryEntries(0, If(entry.StartingCluster = 0, -1, entry.StartingCluster)))
     End Sub
 
@@ -186,6 +189,9 @@ Public Class FormDiskExplorer
         Dim bsc() As Byte = sdf.BootSector(selectedParitionIndex).BootStrapCode
         Array.Copy(bsc, 0, emu.Memory, 0, bsc.Length)
 
+        ListViewCode.Items.Clear()
+        If Not sdf.MasterBootRecord.IsBootable Then Exit Sub
+
         For i As Integer = 0 To bsc.Length - 1
             address = X8086.SegmentOffetToAbsolute(0, i).ToString("X")
             ins = emu.Decode(0, i)
@@ -252,74 +258,126 @@ Public Class FormDiskExplorer
     End Sub
 
     Private Sub ListViewFileSystem_DoubleClick(sender As Object, e As EventArgs) Handles ListViewFileSystem.DoubleClick
+        isLeftMouseDown = False
         If ListViewFileSystem.SelectedItems.Count <> 1 Then Exit Sub
 
         Dim slvi As ListViewItem = ListViewFileSystem.SelectedItems(0)
-        If slvi.Tag IsNot Nothing Then ' It's a folder
+        If slvi.Tag IsNot Nothing Then ' It's a folder or a file
             Dim objs() As Object = CType(slvi.Tag, Object())
             Dim node As TreeNode = CType(objs(0), TreeNode)
-            Dim entry As FAT12_16.DirectoryEntry = CType(objs(1), FAT12_16.DirectoryEntry)
-            If (entry.Attribute And FAT12_16.EntryAttributes.Directory) = FAT12_16.EntryAttributes.Directory Then ' It's a directory
+            Dim entry As FAT12.DirectoryEntry = CType(objs(1), FAT12.DirectoryEntry)
+            If (entry.Attribute And FAT12.EntryAttributes.Directory) = FAT12.EntryAttributes.Directory Then ' It's a directory
                 DisplayFileSystem(node, sdf.GetDirectoryEntries(0, entry.StartingCluster))
             Else ' It's a file
                 Dim b() As Byte = sdf.ReadFile(selectedParitionIndex, entry)
                 Dim targetFileName As String = IO.Path.Combine(IO.Path.GetTempPath(), entry.FullFileName)
                 IO.File.WriteAllBytes(targetFileName, b)
                 Try
-                    Process.Start(targetFileName)
+                    Process.Start(targetFileName).WaitForExit()
+                    IO.File.Delete(targetFileName)
                 Catch ex As Exception
+                    MsgBox(ex.Message, MsgBoxStyle.Exclamation)
                 End Try
             End If
         End If
     End Sub
 
-    Private Sub ListViewFileSystem_MouseDown(sender As Object, e As MouseEventArgs) Handles ListViewFileSystem.MouseDown
-        isMouseDown = True
+    Private Sub SaveDirectory(tmpDirectory As String, entry As FAT12.DirectoryEntry)
+        For Each subEntry As FAT12.DirectoryEntry In sdf.GetDirectoryEntries(0, entry.StartingCluster)
+            If subEntry.FileName.StartsWith(".") Then Continue For
+            If (subEntry.Attribute And FAT12.EntryAttributes.Directory) = FAT12.EntryAttributes.Directory Then ' It's a directory
+                SaveDirectory(tmpDirectory, subEntry)
+            Else
+                SaveFile(tmpDirectory, subEntry)
+            End If
+        Next
     End Sub
 
-    Private Sub ListViewFileSystem_MouseMove(sender As Object, e As MouseEventArgs) Handles ListViewFileSystem.MouseMove
-        If isMouseDown Then
-            Dim filesCount As Integer = ListViewFileSystem.SelectedItems.Count
-            Dim si(filesCount - 1) As DataObjectEx.SelectedItem
+    Private Function SaveFile(tmpDirectory As String, entry As FAT12.DirectoryEntry) As String
+        Dim targetFileName As String = IO.Path.Combine(tmpDirectory, entry.FullFileName)
+        If IO.File.Exists(targetFileName) Then IO.File.Delete(targetFileName)
+        IO.File.WriteAllBytes(targetFileName, sdf.ReadFile(selectedParitionIndex, entry))
+        Return targetFileName
+    End Function
 
-            For i As Integer = 0 To ListViewFileSystem.SelectedItems.Count - 1
-                Dim objs() As Object = CType(ListViewFileSystem.SelectedItems(i).Tag, Object())
-                Dim entry As FAT12_16.DirectoryEntry = CType(objs(1), FAT12_16.DirectoryEntry)
+    Private Sub ListViewFileSystem_MouseMove(sender As Object, e As MouseEventArgs) Handles ListViewFileSystem.MouseMove
+        If Not isLeftMouseDown OrElse draggedItems.Count > 0 Then Exit Sub
+        If Math.Sqrt((mouseDownLocation.X - e.X) ^ 2 + (mouseDownLocation.Y - e.Y) ^ 2) < 6 Then Exit Sub
+
+        Dim tmpDirectory As String = IO.Path.GetTempPath()
+
+        For Each slvi As ListViewItem In ListViewFileSystem.SelectedItems
+            If slvi.Tag IsNot Nothing Then ' It's a folder or a file
+                Dim entry As FAT12.DirectoryEntry = CType(CType(slvi.Tag, Object())(1), FAT12.DirectoryEntry)
+                If (entry.Attribute And FAT12.EntryAttributes.Directory) = FAT12.EntryAttributes.Directory Then ' It's a directory
+                    Dim subDirectory As String = IO.Path.Combine(tmpDirectory, entry.FileName)
+                    If Not IO.Directory.Exists(subDirectory) Then IO.Directory.CreateDirectory(subDirectory)
+                    SaveDirectory(subDirectory, entry)
+                    draggedItems.Add(subDirectory)
+                Else ' It's a file
+                    draggedItems.Add(SaveFile(tmpDirectory, entry))
+                End If
+            End If
+        Next
 
-                si(i).FileName = entry.FullFileName
-                si(i).WriteTime = entry.WriteDateTime
-                si(i).FileSize = entry.FileSize
-            Next
+        If draggedItems.Count > 0 Then ListViewFileSystem.DoDragDrop(New DataObject(DataFormats.FileDrop, draggedItems.ToArray()), DragDropEffects.Move)
+    End Sub
 
-            Dim dox As New DataObjectEx(si, Function(selItem As DataObjectEx.SelectedItem) As Byte()
-                                                Dim b() As Byte = Nothing
-                                                Me.Invoke(New MethodInvoker(Sub()
-                                                                                For i As Integer = 0 To ListViewFileSystem.SelectedItems.Count - 1
-                                                                                    Dim objs() As Object = CType(ListViewFileSystem.SelectedItems(i).Tag, Object())
-                                                                                    Dim entry As FAT12_16.DirectoryEntry = CType(objs(1), FAT12_16.DirectoryEntry)
-
-                                                                                    If selItem.FileName = entry.FullFileName AndAlso
-                                                                                        selItem.WriteTime = entry.WriteDateTime AndAlso
-                                                                                        selItem.FileSize = entry.FileSize Then
-                                                                                        b = sdf.ReadFile(selectedParitionIndex, entry)
-                                                                                    End If
-                                                                                Next
-                                                                            End Sub))
-
-                                                Return b
-                                            End Function)
-            dox.SetData(NativeMethods.CFSTR_FILEDESCRIPTORW, Nothing)
-            dox.SetData(NativeMethods.CFSTR_FILECONTENTS, Nothing)
-            dox.SetData(NativeMethods.CFSTR_PERFORMEDDROPEFFECT, Nothing)
-
-            'ListViewFileSystem.DoDragDrop(dox, DragDropEffects.All)
-            Clipboard.SetDataObject(dox)
-            isMouseDown = False
-        End If
+    Private Sub ListViewFileSystem_MouseDown(sender As Object, e As MouseEventArgs) Handles ListViewFileSystem.MouseDown
+        isLeftMouseDown = (e.Button = MouseButtons.Left)
+        mouseDownLocation = e.Location
     End Sub
 
     Private Sub ListViewFileSystem_MouseUp(sender As Object, e As MouseEventArgs) Handles ListViewFileSystem.MouseUp
-        If Clipboard.ContainsFileDropList() Then SendKeys.Send("^V")
-        isMouseDown = False
+        isLeftMouseDown = Not (e.Button = MouseButtons.Left)
+        If Not isLeftMouseDown Then
+            'draggedItems.ForEach(Sub(di) IO.File.Delete(di))
+            draggedItems.Clear()
+        End If
     End Sub
+
+    'Private Sub ListViewFileSystem_MouseMove(sender As Object, e As MouseEventArgs) Handles ListViewFileSystem.MouseMove
+    '    If isMouseDown Then
+    '        Dim filesCount As Integer = ListViewFileSystem.SelectedItems.Count
+    '        Dim si(filesCount - 1) As DataObjectEx.SelectedItem
+
+    '        For i As Integer = 0 To ListViewFileSystem.SelectedItems.Count - 1
+    '            Dim objs() As Object = CType(ListViewFileSystem.SelectedItems(i).Tag, Object())
+    '            Dim entry As FAT12_16.DirectoryEntry = CType(objs(1), FAT12_16.DirectoryEntry)
+
+    '            si(i).FileName = entry.FullFileName
+    '            si(i).WriteTime = entry.WriteDateTime
+    '            si(i).FileSize = entry.FileSize
+    '        Next
+
+    '        Dim dox As New DataObjectEx(si, Function(selItem As DataObjectEx.SelectedItem) As Byte()
+    '                                            Dim b() As Byte = Nothing
+    '                                            Me.Invoke(New MethodInvoker(Sub()
+    '                                                                            For i As Integer = 0 To ListViewFileSystem.SelectedItems.Count - 1
+    '                                                                                Dim objs() As Object = CType(ListViewFileSystem.SelectedItems(i).Tag, Object())
+    '                                                                                Dim entry As FAT12_16.DirectoryEntry = CType(objs(1), FAT12_16.DirectoryEntry)
+
+    '                                                                                If selItem.FileName = entry.FullFileName AndAlso
+    '                                                                                    selItem.WriteTime = entry.WriteDateTime AndAlso
+    '                                                                                    selItem.FileSize = entry.FileSize Then
+    '                                                                                    b = sdf.ReadFile(selectedParitionIndex, entry)
+    '                                                                                End If
+    '                                                                            Next
+    '                                                                        End Sub))
+
+    '                                            Return b
+    '                                        End Function)
+    '        dox.SetData(NativeMethods.CFSTR_FILEDESCRIPTORW, Nothing)
+    '        dox.SetData(NativeMethods.CFSTR_FILECONTENTS, Nothing)
+    '        dox.SetData(NativeMethods.CFSTR_PERFORMEDDROPEFFECT, Nothing)
+
+    '        ListViewFileSystem.DoDragDrop(dox, DragDropEffects.All)
+    '        'Clipboard.SetDataObject(dox)
+    '        isMouseDown = False
+    '    End If
+    'End Sub
+
+    'Private Sub ListViewFileSystem_MouseUp(sender As Object, e As MouseEventArgs) Handles ListViewFileSystem.MouseUp
+    '    'If Clipboard.ContainsFileDropList() Then SendKeys.Send("^V")
+    'End Sub
 End Class
\ No newline at end of file
diff --git a/x8086NetEmuWinForms/app.config b/x8086NetEmuWinForms/app.config
index 4da05d8..df2d1f9 100644
--- a/x8086NetEmuWinForms/app.config
+++ b/x8086NetEmuWinForms/app.config
@@ -20,4 +20,4 @@
             <!--<add name="EventLog" type="System.Diagnostics.EventLogTraceListener" initializeData="APPLICATION_NAME"/> -->
         </sharedListeners>
     </system.diagnostics>
-<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.1"/></startup></configuration>
+<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/></startup></configuration>
diff --git a/x8086NetEmuWinForms/x8086NetEmuWinForms.vbproj b/x8086NetEmuWinForms/x8086NetEmuWinForms.vbproj
index 0201818..7fec7cd 100644
--- a/x8086NetEmuWinForms/x8086NetEmuWinForms.vbproj
+++ b/x8086NetEmuWinForms/x8086NetEmuWinForms.vbproj
@@ -11,7 +11,7 @@
     <AssemblyName>x8086NetEmuWinForms</AssemblyName>
     <FileAlignment>512</FileAlignment>
     <MyType>WindowsForms</MyType>
-    <TargetFrameworkVersion>v4.7.1</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
     <TargetFrameworkProfile />
     <SccProjectName>
     </SccProjectName>
@@ -39,7 +39,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DefineDebug>true</DefineDebug>
     <DefineTrace>true</DefineTrace>
-    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <OutputPath>bin\</OutputPath>
     <DefineConstants>Win32 = True</DefineConstants>
     <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
     <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
@@ -52,7 +52,7 @@
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
     <DefineTrace>true</DefineTrace>
-    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <OutputPath>bin\</OutputPath>
     <DefineConstants>Win32 = True</DefineConstants>
     <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
     <Optimize>true</Optimize>
@@ -70,7 +70,7 @@
     <DebugSymbols>true</DebugSymbols>
     <DefineDebug>true</DefineDebug>
     <DefineTrace>true</DefineTrace>
-    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <OutputPath>bin\</OutputPath>
     <DefineConstants>Win32 = False</DefineConstants>
     <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
     <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
@@ -82,7 +82,7 @@
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release %28Non Win%29|x86'">
     <DefineTrace>true</DefineTrace>
-    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <OutputPath>bin\</OutputPath>
     <DefineConstants>Win32 = False</DefineConstants>
     <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
     <Optimize>true</Optimize>
@@ -96,6 +96,100 @@
   <PropertyGroup>
     <ApplicationManifest>My Project\app.manifest</ApplicationManifest>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <RemoveIntegerChecks>true</RemoveIntegerChecks>
+    <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug %28Non Win%29|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release %28Non Win%29|x64'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <RemoveIntegerChecks>true</RemoveIntegerChecks>
+    <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = True</DefineConstants>
+    <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug %28Non Win%29|AnyCPU'">
+    <DebugSymbols>true</DebugSymbols>
+    <DefineDebug>true</DefineDebug>
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>full</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release %28Non Win%29|AnyCPU'">
+    <DefineTrace>true</DefineTrace>
+    <OutputPath>..\x8086NetEmu\bin\</OutputPath>
+    <DefineConstants>Win32 = False</DefineConstants>
+    <DocumentationFile>x8086NetEmuWinForms.xml</DocumentationFile>
+    <Optimize>true</Optimize>
+    <NoWarn>42016,41999,42017,42018,42019,42032,42036,42020,42021,42022</NoWarn>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Data" />
@@ -247,7 +341,7 @@
   <Import Project="$(MSBuildToolsPath)\Microsoft.VisualBasic.targets" />
   <ProjectExtensions>
     <VisualStudio>
-      <UserProperties BuildVersion_BuildAction="Both" BuildVersion_UpdateFileVersion="True" BuildVersion_UpdateAssemblyVersion="True" BuildVersion_BuildVersioningStyle="None.None.Increment.None" BuildVersion_DetectChanges="False" />
+      <UserProperties BuildVersion_DetectChanges="False" BuildVersion_BuildVersioningStyle="None.None.Increment.None" BuildVersion_UpdateAssemblyVersion="True" BuildVersion_UpdateFileVersion="True" BuildVersion_BuildAction="Both" />
     </VisualStudio>
   </ProjectExtensions>
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
