name "huge"

; this example shows how to add huge unpacked bcd numbers.

; this allows to over come the 16 bit and even 32 bit limitation.
; because 32 digit decimal value holds over 100 bits!
; with some effort the number of digits can be increased.

ORG     100h

; skip data:
JMP     code

; the number of digits in numbers:
; it's important to reserve 0 as most significant digit, to avoid overflow.
; so if you need to operate with 250 digit values, you need to declare len = 251
len     EQU     32

; every decimal digit is stored in a separate byte.

; first number is: 423454612361234512344535179521
num1    DB      0,0,4,2,3,4,5,4,6,1,2,3,6,1,2,3,4,5,1,2,3,4,4,5,3,5,1,7,9,5,2,1
; second number is: 712378847771981123513137882498
num2    DB      0,0,7,1,2,3,7,8,8,4,7,7,7,1,9,8,1,1,2,3,5,1,3,1,3,7,8,8,2,4,9,8

; we will calculate this:

; sum = num1 + num2

; 423454612361234512344535179521 + 712378847771981123513137882498 =
;              = 1135833460133215635857673062019

sum     DB      len dup(0) ; declare array to keep the result.

; you may check the result on paper, or click Start , then Run, then type "calc" and hit enter key.

code:   NOP ; entry point (nop does nothing, it's nope).

; digit pointer:
XOR     BX, BX

; setup the loop:
MOV     CX, len
MOV     BX, len-1  ; point to lest significant digit!

next_digit:

; add digits:
MOV     AL, num1[BX]
ADC     AL, num2[BX]

; this is a very useful instruction that
; adjusts the value of addition
; to be string compatible
AAA

; aaa stands for ascii add adjust.
; --- algorithm behind aaa ---
; if low nibble of al > 9 or af = 1 then:
;     al = al + 6
;     ah = ah + 1
;     af = 1
;     cf = 1
; else
;     af = 0
;     cf = 0
;
; in both cases: clear the high nibble of al.
; --- end of aaa logic ---

; store result:
MOV     sum[BX], AL

; point to next digit:
DEC     BX

LOOP    next_digit

; include carry in result (if any):
ADC     sum[BX], 0


; print out the result:
MOV     CX, len

; start printing from most significant digit:
MOV     BX, 0

print_d:
MOV     AL, sum[BX]
; convert to ascii char:
OR      AL, 30h

MOV     AH, 0eh
INT     10h

INC     BX

LOOP    print_d

; wait for any key press:
MOV AH, 0
INT 16h

RET  ; stop









; [SOURCE]: C:\emu8086\examples\0_sample_add_huge_numbers.asm
